[[ch8]]
== Mining and Consensus
== マイニングと合意形成

[[mining]]
=== Introduction
=== イントロダクション

((("consensus", id="ix_ch08-asciidoc0", range="startofrange")))((("mining", id="ix_ch08-asciidoc1", range="startofrange")))((("miners")))Mining is the process by which new bitcoin is added to the money supply. Mining also serves to secure the bitcoin system against fraudulent transactions or transactions spending the same amount of bitcoin more than once, known as a double-spend. Miners provide processing power to the bitcoin network in exchange for the opportunity to be rewarded bitcoin. 

((("consensus", id="ix_ch08-asciidoc0", range="startofrange")))((("mining", id="ix_ch08-asciidoc1", range="startofrange")))((("miners")))マイニングは新しいbitcoinを新たに供給するプロセスであり、また詐欺的な取引であったり二重使用と呼ばれる同じbitcoinを２度以上使う取引をできないようにしているプロセスです。マイナーはbitcoin報酬を得ることと引き換えにBitcoinネットワークに処理能力を提供します。

Miners validate new transactions and record them on the global ledger. A new block, containing transactions that occurred since the last block, is "mined" every 10 minutes, thereby adding those transactions to the blockchain. Transactions that become part of a block and added to the blockchain are considered "confirmed," which allows the new owners of bitcoin to spend the bitcoin they received in those transactions. 

マイナーは新しいトランザクションを検証し、これらをグローバルな元帳に記録します。一番最後のブロック以降に生じたトランザクションを含む新しいブロックは10分ごとに"採掘"され、ブロックチェーンにこれらのトランザクションが追加されます。ブロックチェーンに追加された、またはブロックの一部になったトランザクションは"確認済"となり、これらのトランザクションで送付されたbitcoinを新しい所有者が使用することができるようになります。

Miners receive two types of rewards for mining: new coins created with each new block, and transaction fees from all the transactions included in the block. To earn this reward, the miners compete to solve a difficult mathematical problem based on a cryptographic hash algorithm. The solution to the problem, called the proof of work, is included in the new block and acts as proof that the miner expended significant computing effort. The competition to solve the proof-of-work algorithm to earn reward and the right to record transactions on the blockchain is the basis for bitcoin's security model. 

マイナーは二種類のマイニングに対する報酬を受け取ります。１つはそれぞれの新しいブロックを作ったことに対する新しいbitcoin、もう１つはブロックに含まれている全トランザクションから得られるトランザクション手数料です。これらの報酬を得るために、マイナーたちは暗号学的ハッシュアルゴリズムに基づいた難解な数学的な問題を競って解決しなければいけません。proof of workと呼ばれるこの問題への解法は新しいブロックに含められ、マイナーが十分なコンピュータリソースを注ぎ込んだことの証明として機能することになります。報酬を稼ぐためのproof-of-workアルゴリズムの解法とトランザクションをブロックチェーンに記録する権利をマイナーたちが競争するという仕組みは、Bitcoinのセキュリティモデルの基礎をなしています。

((("new coin generation")))The process of new coin generation is called mining because the reward is designed to simulate diminishing returns, just like mining for precious metals. Bitcoin's money supply is created through mining, similar to how a central bank issues new money by printing bank notes. ((("bitcoin","rate of issuance")))The amount of newly created bitcoin a miner can add to a block decreases approximately every four years (or precisely every 210,000 blocks). It started at 50 bitcoin per block in January of 2009 and halved to 25 bitcoin per block in November of 2012. It will halve again to 12.5 bitcoin per block sometime in 2016. Based on this formula, bitcoin mining rewards decrease exponentially until approximately the year 2140, when all bitcoin (20.99999998 million) will have been issued. After 2140, no new bitcoins will be issued.

((("new coin generation")))新しいbitcoinの生成プロセスはマイニングと呼ばれています。なぜなら、貴金属を採掘するように報酬が減っていくように設計されているからです。Bitcoinの供給はマイニングを通して行われ、これはあたかも紙幣を刷ることで新しいお金を発行している中央銀行のようなものです。((("bitcoin","rate of issuance")))マイニングを通して新たに作られるbitcoinの量はおおよそ４年ごと(正確には210,000ブロックごとに)減っていきます。2009年1月の時点で１ブロックあたり50bitcoinから始まり、2012年11月には半分の１ブロックあたり25bitcoinになりました。次は2016年のどこかで１ブロックあたり12.5bitcoinと半分になるだろうと考えられています。この公式に当てはめると、Bitcoinマイニングの報酬は全てのbitcoin(20.99999998 million)が発行され終わるおおよそ2140年まで指数関数的に減少していきます。2140年以降はもう新しいbitcoinが発行されることはありません。

((("fees, transaction")))((("transactions","fees")))Bitcoin miners also earn fees from transactions. Every transaction may include a transaction fee, in the form of a surplus of bitcoin between the transaction's inputs and outputs. The winning bitcoin miner gets to "keep the change" on the transactions included in the winning block. Today, the fees represent 0.5% or less of a bitcoin miner's income, the vast majority coming from the newly minted bitcoins. However, as the reward decreases over time and the number of transactions per block increases, a greater proportion of bitcoin mining earnings will come from fees. After 2140, all bitcoin miner earnings will be in the form of transaction fees.

((("fees, transaction")))((("transactions","fees")))Bitcoinマイナーはまたトランザクションから手数料を得ます。全てのトランザクションにはトランザクション手数料が含まれている可能性があり、トランザクションインプットとトランザクションアウトプットの差として与えられます。マイニング競争に勝ったマイナーは???? 今日、この手数料はBitcoinマイナーの収入の0.5%以下であり、主な収入は新しくマイニングされたbitcoinになっています。しかし、時間が経つごとにこの報酬は減っていき１ブロックに含まれるトランザクション数が増えていくと、Bitcoinマイニング収入の多くの部分はトランザクション手数料からになるでしょう。2140年以降になると、全てのBitcoinマイナーの収入はトランザクション手数料の形で得られるようになります。

The word "mining" is somewhat misleading. By evoking the extraction of precious metals, it focuses our attention on the reward for mining, the new bitcoins in each block. Although mining is incentivized by this reward, the primary purpose of mining is not the reward or the generation of new coins. If you view mining only as the process by which coins are created, you are mistaking the means (incentives) as a goal of the process. Mining is the main process of the decentralized clearinghouse, by which transactions are validated and cleared. Mining secures the bitcoin system and enables the emergence of network-wide consensus without a central authority. 

"マイニング"という言葉は、ちょっと紛らわしい言葉です。貴金属を採掘するという意味で、マイニングに対する報酬に注意が行ってしまいます。マイニングはこの報酬がインセンティブとなりますが、元々のマイニングの目的は新しいbitcoinを生成することによる報酬ではないのです。もしマイニングをbitcoinを作り出すプロセスだと思っているのであれば、このプロセスの意味を取り違えています。マイニングは分散的な手形交換所であり、マイニングによってトランザクションが検証されます。マイニングはBitcoinシステムを安全なものにし、またマイニングがあることで中央当局なしにネットワーク上での合意形成が可能になったのです。

Mining is the invention that makes bitcoin special, a decentralized security mechanism that is the basis for peer-to-peer digital cash. The reward of newly minted coins and transaction fees is an incentive scheme that aligns the actions of miners with the security of the network, while simultaneously implementing the monetary supply. 

マイニングはBitcoinを特別なものにしている発明であり、peer-to-peerのデジタルキャッシュを基礎とした分散的セキュリティ機構です。新たなbitcoinやトランザクション手数料という報酬は、マイナーたちにBitcoinネットワークのセキュリティを守らせるインセンティブの枠組みであり、また一方では同時に通貨供給の目的も果たしているのです。

In this chapter, we will first examine mining as a monetary supply mechanism and then look at the most important function of mining: the decentralized emergent consensus mechanism that underpins bitcoin's security.

この章では、最初に通貨供給メカニズムとしてのマイニングを説明し、その後マイニングの最も重要な性質でありBitcoinセキュリティの土台であるdecentralized emergent consensusについて説明します。

==== Bitcoin Economics and Currency Creation
==== Bitcoin経済と通貨の発行

((("currency creation", id="ix_ch08-asciidoc2", range="startofrange")))((("mining","currency creation", id="ix_ch08-asciidoc3", range="startofrange")))Bitcoins are "minted" during the creation of each block at a fixed and diminishing rate. Each block, generated on average every 10 minutes, contains entirely new bitcoins, created from nothing. Every 210,000 blocks, or approximately every four years, the currency issuance rate is decreased by 50%. For the first four years of operation of the network, each block contained 50 new bitcoins.

((("currency creation", id="ix_ch08-asciidoc2", range="startofrange")))((("mining","currency creation", id="ix_ch08-asciidoc3", range="startofrange")))bitcoinは１ブロックごとのbitcoin発行量の公式に基づきブロックごとに鋳造されます。この新たなbitcoinはおおよそ10分ごとに生成されるブロックに含まれ何もないところから生成されます。210,000ブロックごとに、または約４年ごとに、通貨発行量は半分に減ります。Bitcoinネットワークが稼働を始めてからの最初の４年間はそれぞれのブロックが50bitcoinを発行していました。

In November 2012, the new bitcoin issuance rate was decreased to 25 bitcoins per block and it will decrease again to 12.5 bitcoins at block 420,000, which will be mined sometime in 2016. The rate of new coins decreases like this exponentially over 64 "halvings" until block 13,230,000 (mined approximately in year 2137), when it reaches the minimum currency unit of 1 satoshi. Finally, after 13.44 million blocks, in approximately 2140, almost 2,099,999,997,690,000 satoshis, or almost 21 million bitcoins, will be issued. Thereafter, blocks will contain no new bitcoins, and miners will be rewarded solely through the transaction fees. <<bitcoin_money_supply>> shows the total bitcoin in circulation over time, as the issuance of currency decreases.

2012年11月に新しいbitcoin発行量は１ブロックごとに25bitcoinに減り、420,000ブロックがマイニングされる2016年のどこかで更に12.5bitcoinに減ります。この１ブロックあたりの発行量は指数関数的に減少し、64回の半減を繰り返して13,230,000ブロック(おおよそ2137年にマイニングされるはずのブロック)まで減少していきます。これ以降はbitcoinの最小通貨単位である1satoshiを下回ってしまうため新しくbitcoinを発行できなくなり、最終的には2140年あたりに1344万ブロック(13.44Mブロック)でほぼ2100万bitcoin(2,099,999,997,690,000satoshi)が発行されることになります。この後、ブロックには新しいbitcoinが含まれなくなり、マイナーは単にトランザクション手数料を通して報酬を得るようになります。<<bitcoin_money_supply>>図は通貨発行量が減るにつれて時間ともにbitcoin総量がどのように増えていくかを示しています。

[[bitcoin_money_supply]]
.Supply of bitcoin currency over time based on a geometrically decreasing issuance rate
.幾何級数的に減少していく発行率に基づく、時間経過ごとのbitcoin通貨発行量
image::images/msbt_0801.png["BitcoinMoneySupply"]

[NOTE]
====
The maximum number of coins mined is the _upper limit_ of possible mining rewards for bitcoin. In practice, a miner may intentionally mine a block taking less than the full reward. Such blocks have already been mined and more may be mined in the future, resulting in a lower total issuance of the currency.

採掘されるbitcoinの最大値は、bitcoinに対するマイニング報酬の _上限_ です。
実際、マイナーは故意に
====

In the example code in <<max_money>>, we calculate the total amount of bitcoin that will be issued.

<<max_money>>図にある例コードで将来発行されるbitcoin総量を計算しています。

[[max_money]]
.A script for calculating how much total bitcoin will be issued
====
[source, python]
----
include::code/max_money.py[]
----
====

<<max_money_run>> shows the output produced by running this script.

<<max_money_run>>図にはこのスクリプトによって出力される結果を示しています。

[[max_money_run]]
.Running the max_money.py script
.max_money.pyスクリプトの実行
====
[source,bash]
----
$ python max_money.py 
Total BTC to ever be created: 2099999997690000 Satoshis
----
====

((("inflation, resisting")))The finite and diminishing issuance creates a fixed monetary supply that resists inflation. Unlike a fiat currency, which can be printed in infinite numbers by a central bank, bitcoin can never be inflated by printing.

((("inflation, resisting")))１ブロックあたりの通貨発行量を減少させbitcoinの総量を有限にすることでインフレを防ぐことができます。中央銀行によって無限に発行可能な法定通貨と違い、bitcoinは通貨発行によってインフレが起きることは決してありません。

.Deflationary Money
.デフレマネー
****
((("deflationary money")))The most important and debated consequence of a fixed and diminishing monetary issuance is that the currency will tend to be inherently _deflationary_. Deflation is the phenomenon of appreciation of value due to a mismatch in supply and demand that drives up the value (and exchange rate) of a currency. The opposite of inflation, price deflation means that the money has more purchasing power over time.

((("deflationary money")))とても重要なこととして、bitcoin総量が有限であるためこの通貨は本質的に _デフレ_ 傾向が生じることになります。デフレは通貨価格(または通貨交換レート)をつり上げようとする需要側と供給側のミスマッチのために生じる適正価格の調整現象です。インフレと逆に、通貨価格のデフレはお金の購買力が相対的に上がるということを意味します。

Many economists argue that a deflationary economy is a disaster that should be avoided at all costs. That is because in a period of rapid deflation, people tend to hoard money instead of spending it, hoping that prices will fall. Such a phenomenon unfolded during Japan's "Lost Decade," when a complete collapse of demand pushed the currency into a deflationary spiral. 

多くのエコノミストたちはデフレ経済はどんなに費用をかけてでも回避すべき災害なのかを議論しています。というのは、急劇なデフレが生じると人々はお金を使わず蓄積しようとし、より物価が下落することを望むようになってしまうためです。このような需要がなくなってしまうデフレスパイラルに突入すると、日本の"失われた１０年"ような現象が生じるようになります。

Bitcoin experts argue that deflation is not bad per se. Rather, deflation is associated with a collapse in demand because that is the only example of deflation we have to study. In a fiat currency with the possibility of unlimited printing, it is very difficult to enter a deflationary spiral unless there is a complete collapse in demand and an unwillingness to print money. Deflation in bitcoin is not caused by a collapse in demand, but by a predictably constrained supply. 

Bitcoinの専門家たちはデフレそれ自体は悪いものではないと話しています。むしろ、需要がなくなることに伴いデフレが生じるということは、デフレを学習する上での単なる例でしかないと考えています。無限に発行可能な法定通貨の場合、完全に需要がなくなり、かつ追加の通貨発行をしないようにしなければデフレスパイラルが簡単には生じません。Bitcoinでのデフレは需要がなくなることによって起こるものではなく、あらかじめ決めておくことができる制限された供給側によって引き起こされるものです。

In practice, it has become evident that the hoarding instinct caused by a deflationary currency can be overcome by discounting from vendors, until the discount overcomes the hoarding instinct of the buyer. Because the seller is also motivated to hoard, the discount becomes the equilibrium price at which the two hoarding instincts are matched. With discounts of 30% on the bitcoin price, most bitcoin retailers are not experiencing difficulty overcoming the hoarding instinct and generating revenue. It remains to be seen whether the deflationary aspect of the currency is really a problem when it is not driven by rapid economic retraction.(((range="endofrange", startref="ix_ch08-asciidoc3")))(((range="endofrange", startref="ix_ch08-asciidoc2")))

現実には、デフレの場合ベンダーが価格を下げても人々の貯蓄が優先され、これが買う側が貯蓄をやめるくらいに価格が下がるまで続くことは明らかです。売り側も貯蓄したいと考えるため、価格の下落は買う側と売り側の双方の思惑が均衡した価格になるまで続きます。bitcoinの場合価格が30%下がっても、多くのbitcoin販売者は貯蓄よりも利益を得ることを考えます。速い経済的収縮によって促進されない時この通貨にデフレが生じるという見方は本当に問題であるかどうか知られる状態であり続けます。です。????
(((range="endofrange", startref="ix_ch08-asciidoc3")))(((range="endofrange", startref="ix_ch08-asciidoc2")))
****

=== Decentralized Consensus
=== 分散化された合意形成

((("consensus","decentralized")))((("decentralized consensus")))In the previous chapter we looked at the blockchain, the global public ledger (list) of all transactions, which everyone in the bitcoin network accepts as the authoritative record of ownership. 

((("consensus","decentralized")))((("decentralized consensus")))前の章でブロックチェーンというグローバルな公的な元帳を説明しました。これは、Bitcoinネットワークに参加している人全員が所有権の権威レコードとして認めているものです。

But how can everyone in the network agree on a single universal "truth" about who owns what, without having to trust anyone? All traditional payment systems depend on a trust model that has a central authority providing a clearinghouse service, basically verifying and clearing all transactions. Bitcoin has no central authority, yet somehow every full node has a complete copy of a public ledger that it can trust as the authoritative record. The blockchain is not created by a central authority, but is assembled independently by every node in the network. Somehow, every node in the network, acting on information transmitted across insecure network connections, can arrive at the same conclusion and assemble a copy of the same public ledger as everyone else. This chapter examines the process by which the bitcoin network achieves global consensus without central authority.

しかし、Bitcoinネットワークに参加している皆さんは、誰が何を所有しているかという一つの普遍的な"真実"を、誰も信頼することなくどのようにして認めているのでしょうか。今までの全ての支払いシステムは全ての取引を検証しまたclearingする手形取引サービスを提供する中央集権的信頼モデルに依存しています。???? Bitcoinには中央集権的な仕組みはありません。しかし、ほぼ全てのfull nodeが権威レコードとして信頼できる公的な元帳の完全なコピーを持っています。このブロックチェーンは中央権力によって作られる訳ではありませんが、Bitcoinネットワークに属している全てのノードによって独立に組み立てられます。そして、どういうわけかBitcoinネットワークに属する全てのノードは結果的に他の全てのノードと同じ公的な元帳のコピーを組み立てることになります。信頼できないネットワークから送られた情報に基づき動作するにも関わらず。この章では中央権力なくBitcoinネットワークがグローバルな合意形成に到達するプロセスを説明します。

((("Nakamoto, Satoshi")))Satoshi Nakamoto's main invention is the decentralized mechanism for((("emergent consensus"))) _emergent consensus_. Emergent, because consensus is not achieved explicitly—there is no election or fixed moment when consensus occurs. Instead, consensus is an emergent artifact of the asynchronous interaction of thousands of independent nodes, all following simple rules. All the properties of bitcoin, including currency, transactions, payments, and the security model that does not depend on central authority or trust, derive from this invention. 

((("Nakamoto, Satoshi")))Satoshi Nakamotoの主要な発明は((("emergent consensus")))_emergent consensus(結果的に作られた同意)_ に対する分散メカニズムです。emergentというのは、選挙や同意したときに起きる決められた行動による明示的な同意ではないという意味です。ここでの同意は数千の独立したノードの非同期的相互作用の結果として生まれた人工物で、全ノードは次のシンプルなルールに従っています。通貨、トランザクション、支払い、および中央権力や信頼に依存しないセキュリティモデルといったBitcoinの全ての特徴はこの発明から導かれます。

Bitcoin's decentralized consensus emerges from the interplay of four processes that occur independently on nodes across the network: 

Bitcoinの分散化された合意形成は、Bitcoinネットワークを通して独立的に各ノードで起こる以下４つのプロセスの相互作用から生じてきます。

* Independent verification of each transaction, by every full node, based on a comprehensive list of criteria
* Independent aggregation of those transactions into new blocks by mining nodes, coupled with demonstrated computation through a proof-of-work algorithm
* Independent verification of the new blocks by every node and assembly into a chain
* Independent selection, by every node, of the chain with the most cumulative computation demonstrated through proof of work

* 独立したトランザクション検証(全てのfull nodeによるcomprehensiveな判断条件リストに基づく検証)
* 独立したトランザクション集積(proof-of-workアルゴリズムを通して実行された計算と結びつけられた、マイニングノードによるトランザクションのブロックへの集積)
* 独立した新規ブロック検証とブロックチェーンへの埋め込み(全てのノードによって新しいブロックが検証され、このブロックがブロックチェーンに取り込まれる)
* 独立したブロックチェーン選択(proof of workを通して証明された最も多くの累積計算量を持っているブロックチェーンが全てのノードで選ばれる)

In the next few sections we will examine these processes and how they interact to create the emergent property of network-wide consensus that allows any bitcoin node to assemble its own copy of the authoritative, trusted, public, global ledger.

次のいくつかの節で、これらのプロセスについて説明し、どのようにしてノードが相互作用をしてBitcoinネットワーク全体のemergentな合意形成をしているのかを説明します。

[[tx_verification]]
=== Independent Verification of Transactions
=== 独立したトランザクション検証

((("consensus","transactions independent verification")))((("transactions","independent verification of")))In <<transactions>>, we saw how wallet software creates transactions by collecting UTXO, providing the appropriate unlocking scripts, and then constructing new outputs assigned to a new owner. The resulting transaction is then sent to the neighboring nodes in the bitcoin network so that it can be propagated across the entire bitcoin network. 

((("consensus","transactions independent verification")))((("transactions","independent verification of")))<<transactions>>では、どのようにしてウォレットがUTXOを集めてトランザクションを作り、適切なunlocking scriptを付与して新しい所有者に割り当てられた新しいアウトプットを作るかを見ました。結果的に作られたトランザクションはBitcoinネットワーク全体に伝搬できるようにBitcoinネットワーク内の隣接ノードに送られます。

However, before forwarding transactions to its neighbors, every bitcoin node that receives a transaction will first verify the transaction. This ensures that only valid transactions are propagated across the network, while invalid transactions are discarded at the first node that encounters them. 

しかし、隣接ノードにトランザクションが転送される前に、トランザクションを受け取った全てのBitcoinノードは最初にトランザクションを検証します。これによって有効なトランザクションだけがBitcoinネットワーク内を伝搬することを保証しており、無効なトランザクションは最初にこのトランザクションに会ったノードによって破棄されます。

((("emergent consensus","criteria for")))((("transactions","verification criteria for")))Each node verifies every transaction against a long checklist of criteria:

((("emergent consensus","criteria for")))((("transactions","verification criteria for")))それぞれのノードは全てのトランザクションを以下の長いチェックリストを判断基準として検証します。

* The transaction's syntax and data structure must be correct.
* トランザクションの文法またはデータ構造は正しいか
* Neither lists of inputs or outputs are empty.
* インプットとアウトプットのいずれも空でないか
* The transaction size in bytes is less than +MAX_BLOCK_SIZE+.
* バイト単位のトランザクションデータサイズが +MAX_BLOCK_SIZE+ よりも小さいか
* Each output value, as well as the total, must be within the allowed range of values (less than 21m coins, more than 0).
* それぞれのアウトプットvalueおよびtotal valueは許されている値の範囲内(0より大きく、2100万bitcoinよりも小さい)にあるか
* None of the inputs have hash=0, N=–1 (coinbase transactions should not be relayed).
* インプットのいずれもhash=0, N=-1でないか(coinbaseトランザクションはリレーされていくべきでない)
* +nLockTime+ is less than or equal to +INT_MAX+.
* +nLockTime+ は +INT_MAX+ より小さいかまたは等しいか
* The transaction size in bytes is greater than or equal to 100.
* バイト単位でのトランザクションデータサイズは100より大きいかまたは等しいか
* The number of signature operations contained in the transaction is less than the signature operation limit.
* トランザクションに含まれている署名オペレーション数は、署名オペレーション回数上限よりも小さいか
* The unlocking script (+scriptSig+) can only push numbers on the stack, and the locking script (+scriptPubkey+) must match +isStandard+ forms (this rejects "nonstandard" transactions).
* unlocking script( +scriptSig+ )はスタックに数字をpushすることだけでき、locking script( +scriptPubkey+ )は +isStandard+ 形式に合っているか(これにより"非標準"トランザクションとして拒否されます)
* A matching transaction in the pool, or in a block in the main branch, must exist.
* トランザクションプールの中かメインブランチブロックチェーンの中のブロックに、同じトランザクションがあるか
* For each input, if the referenced output exists in any other transaction in the pool, the transaction must be rejected.
* それぞれのインプットに対して、もしこのインプットが参照しているアウトプットをトランザクションプールの他のトランザクションも参照していた場合、このトランザクションを拒否する
* For each input, look in the main branch and the transaction pool to find the referenced output transaction. If the output transaction is missing for any input, this will be an orphan transaction. Add to the orphan transactions pool, if a matching transaction is not already in the pool.
* それぞれのインプットに対して、メインブランチブロックチェーンの中かトランザクションプールの中にインプットが参照しているトランザクションアウトプットが見つかるかを確認する。もし参照しているアウトプットが見つからなければ、これはorphanトランザクションです。orphanトランザクションプールにまだこのトランザクションがなければ、orphanトランザクションプールにこのトランザクションを追加する
* For each input, if the referenced output transaction is a coinbase output, it must have at least +COINBASE_MATURITY+ (100) confirmations. 
* それぞれのインプットに対して、もしインプットが参照しているアウトプットがcoinbaseアウトプットだった場合、+COINBASE_MATURITY+ (100) 検証数を少なくとも持っているか
* For each input, the referenced output must exist and cannot already be spent.
* それぞれのインプットに対して、参照しているアウトプットがすでに使用されて使用不可になっていないか
* Using the referenced output transactions to get input values, check that each input value, as well as the sum, are in the allowed range of values (less than 21m coins, more than 0).
* 参照しているアウトプットを使って、それぞれのインプットvalueとその総和が許されている値の範囲内(0より大きく、2100万bitcoinよりも小さい)にあるか
* Reject if the sum of input values is less than sum of output values.
* もしインプットvalueの総和がアウトプットvalueの総和よりも小さければ拒否する
* Reject if transaction fee would be too low to get into an empty block.
* もしトランザクション手数料が少なすぎて空ブロックに入れることができない場合は拒否する
* The unlocking scripts for each input must validate against the corresponding output locking scripts.
* それぞれのインプットにあるunlocking scriptは、対応したアウトプットのlocking scriptを解除できるか

These conditions can be seen in detail in the functions +AcceptToMemoryPool+, +CheckTransaction+, and +CheckInputs+ in the bitcoin reference client. Note that the conditions change over time, to address new types of denial-of-service attacks or sometimes to relax the rules so as to include more types of transactions. 

これらの条件はBitcoin Referenceクライアントにある +AcceptToMemoryPool+ 、 +CheckTransaction+ 、 +CheckInputs+ 関数を見ることで詳細を確認できます。この条件は、新しい種類のDOS攻撃に対応したり、またさらにトランザクションの種類を増やすためにときどき緩めたりと、時間とともに変わっていくことに注意してください。

By independently verifying each transaction as it is received and before propagating it, every node builds a pool of valid (but unconfirmed) transactions known as the _transaction pool_, _memory pool_ or _mempool_.

トランザクションを受け取ったときや他のノードに伝搬させたりする前に独立にそれぞれのトランザクションを検証することによって、全てのノードが _トランザクションプール_ 、 _メモリプール_ または _mempool_ と呼ばれるプールを構築します。

=== Mining Nodes
=== マイニングノード

((("mining","nodes")))((("nodes","mining")))Some of the nodes on the bitcoin network are specialized nodes called _miners_. In <<ch01_intro_what_is_bitcoin>> we introduced Jing, a computer engineering student in Shanghai, China, who is a bitcoin miner. Jing earns bitcoin by running a((("mining rigs"))) "mining rig," which is a specialized computer-hardware system designed to mine bitcoins. Jing's specialized mining hardware is connected to a server running a full bitcoin node. Unlike Jing, some miners mine without a full node, as we will see in <<mining_pools>>. Like every other full node, Jing's node receives and propagates unconfirmed transactions on the bitcoin network. Jing's node, however, also aggregates these transactions into new blocks.

((("mining","nodes")))((("nodes","mining")))いくつかのBitcoinノードは _マイナー_ よ呼ばれる特別なBitcoinノードです。<<ch01_intro_what_is_bitcoin>>で、上海にいるコンピュータエンジニアの学生でBitcoinマイナーであるジンを紹介しました。ジンは、bitcoinをマイニングするために作られた特別なコンピュータ ((("mining rigs"))) "mining rig" を走らせてbitcoinを稼いでいます。ジンの特別なマイニングハードウェアはfull Bitcoin nodeが走っているサーバに接続されています。ジンと違い、いくつかのマイナーは<<mining_pools>>で見るようにfull nodeを使うことなくマイニングをしています。

Jing's node is listening for new blocks, propagated on the bitcoin network, as do all nodes. However, the arrival of a new block has special significance for a mining node. The competition among miners effectively ends with the propagation of a new block that acts as an announcement of a winner. To miners, receiving a new block means someone else won the competition and they lost. However, the end of one round of a competition is also the beginning of the next round. The new block is not just a checkered flag, marking the end of the race; it is also the starting pistol in the race for the next block.

ジンのBitcoinノードは、全てのBitcoinノードがするように、Bitcoinネットワーク上を伝搬している新しいブロックを待っています。しかし、新しいブロックが来ることはマイニングノードにとって特別な意味を持ちます。新しいブロックが伝搬してくるということは事実上マイナー同士の競争が終わったということです。この伝搬は競争の勝者を伝えることになるからです。マイナーに新しいブロックが届くということは他の誰かが競争に勝ちそれ以外の人は負けたということを意味します。しかし、このラウンドの終わりは次のラウンドの始まりです。新しいブロックはレースの終わりを示す単なるチェッカーフラッグではなく、次のブロックに対するスターティングピストルでもあります。

=== Aggregating Transactions into Blocks
=== ブロックへのトランザクション集約

((("blockchains","assembling blocks into")))((("blocks","assembling")))((("blocks","candidate, aggregating")))((("candidate blocks","aggregating")))((("mining","aggregating transactions and")))((("transaction pools","adding blocks to")))((("transactions","aggregating into blocks")))After validating transactions, a bitcoin node will add them to the((("memory pool"))) _memory pool_, or _transaction pool_, where transactions await until they can be included (mined) into a block. Jing's node collects, validates, and relays new transactions just like any other node. Unliky other nodes, however, Jing's node will then aggregate these transactions into a _candidate block_.

((("blockchains","assembling blocks into")))((("blocks","assembling")))((("blocks","candidate, aggregating")))((("candidate blocks","aggregating")))((("mining","aggregating transactions and")))((("transaction pools","adding blocks to")))((("transactions","aggregating into blocks")))トランザクションを検証した後、Bitcoinノードは ((("memory pool"))) _メモリプール_ または _トランザクションプール_ にそれらのトランザクションを追加します。このプールにあるトランザクションはブロックに含められる(マイニングされる)までこのプールで待機しています。ジンのBitcoinノードは他のBitcoinノードと同じようにトランザクションを集め検証し新しいトランザクションをリレーします。しかし、他のBitcoinノードと違うのは、ジンのBitcoinノードはこれらのトランザクションを _候補ブロック_ に集めておくことです。

Let's follow the blocks that were created during the time Alice bought a cup of coffee from Bob's Cafe (see <<cup_of_coffee>>). Alice's transaction was included in block 277,316. For the purpose of demonstrating the concepts in this chapter, let's assume that block was mined by Jing's mining system and follow Alice's transaction as it becomes part of this new block.

アリスがボブのコーヒーショップでコーヒー代を払ったときに作られたブロックを追ってみましょう(<<cup_of_coffee>>参照)。アリスのトランザクションはブロック277,316に含まれていました。この章でやりたいことを説明しやすくするために、このブロックがジンのマイニングシステムによって採掘され、アリスのトランザクションがこの新しいブロックの一部になっているとしましょう。

Jing's mining node maintains a local copy of the blockchain, the list of all blocks created since the beginning of the bitcoin system in 2009. By the time Alice buys the cup of coffee, Jing's node has assembled a chain up to block 277,314. Jing's node is listening for transactions, trying to mine a new block and also listening for blocks discovered by other nodes. As Jing's node is mining, it receives block 277,315 through the bitcoin network. The arrival of this block signifies the end of the competition for block 277,315 and the beginning of the competition to create block 277,316.  

ジンのマイニングBitcoinノードはブロックチェーンのローカルコピーを保持しており、このブロックチェーンには2009年にBitcoinシステムが稼働を始めてから作られた全てのブロックが含まれています。アリスがコーヒー代を支払った頃にジンのBitcoinノードはブロック277,314までブロックチェーンを組み立てました。ジンのBitcoinノードはトランザクションを待っていたり、新しいブロックをマイニングしたり、または他のBitcoinノードが発見したブロックを待っていたりしています。ジンのBitcoinノードがマイニングしているときにBitcoinネットワークからブロック277,315を受け取りました。このブロックの到着したということは、ブロック277,315の競争が終わり、ブロック277,316を作る競争が始まったということを意味します。

During the previous 10 minutes, while Jing's node was searching for a solution to block 277,315, it was also collecting transactions in preparation for the next block. By now it has collected a few hundred transactions in the memory pool. Upon receiving block 277,315 and validating it, Jing's node will also check all the transactions in the memory pool and remove any that were included in block 277,315. Whatever transactions remain in the memory pool are unconfirmed and are waiting to be recorded in a new block. 

ブロック277,315が到着する前の10分間、ジンのBitcoinノードはブロック277,315に対する解を探しながら、同時に次のブロックの準備のためトランザクションを集めていました。現在まで数百個のトランザクションをメモリプールに集めました。ブロック277,315を受け取り検証するとすぐに、ジンのBitcoinノードはメモリプールにある全てのトランザクションをチェックしブロック277,315に含まれていたトランザクションをメモリプールから削除していきます。

Jing's node immediately constructs a new empty block, a candidate for block 277,316. This block is called a candidate block because it is not yet a valid block, as it does not contain a valid proof of work. The block becomes valid only if the miner succeeds in finding a solution to the proof-of-work algorithm.

ジンのBitcoinノードはすぐにブロック277,316の候補となる新しい空ブロックの構築を始めました。このブロックはまだ有効なブロックになっていないので候補ブロックと呼ばれています。このブロックは候補ブロックと呼ばれており、有効なproof of workが含まれていないまだ有効になっていないブロックです。このブロックは、マイナーがproof-of-workアルゴリズムへの解を見つけるときにのみ有効になるのです。

==== Transaction Age, Fees, and Priority
==== トランザクション年齢、トランザクション手数料、トランザクション優先度

((("candidate blocks","age of transactions", id="ix_ch08-asciidoc4", range="startofrange")))((("candidate blocks","priority of transactions", id="ix_ch08-asciidoc5", range="startofrange")))((("candidate blocks","transaction fees", id="ix_ch08-asciidoc6", range="startofrange")))((("fees, transaction", id="ix_ch08-asciidoc7", range="startofrange")))((("transactions","age of", id="ix_ch08-asciidoc8", range="startofrange")))((("transactions","priority of", id="ix_ch08-asciidoc9", range="startofrange")))To construct the candidate block, Jing's bitcoin node selects transactions from the memory pool by applying a priority metric to each transaction and adding the highest priority transactions first. Transactions are prioritized based on the "age" of the UTXO that is being spent in their inputs, allowing for old and high-value inputs to be prioritized over newer and smaller inputs. Prioritized transactions can be sent without any fees, if there is enough space in the block. 

((("candidate blocks","age of transactions", id="ix_ch08-asciidoc4", range="startofrange")))((("candidate blocks","priority of transactions", id="ix_ch08-asciidoc5", range="startofrange")))((("candidate blocks","transaction fees", id="ix_ch08-asciidoc6", range="startofrange")))((("fees, transaction", id="ix_ch08-asciidoc7", range="startofrange")))((("transactions","age of", id="ix_ch08-asciidoc8", range="startofrange")))((("transactions","priority of", id="ix_ch08-asciidoc9", range="startofrange")))候補ブロックを構築するために、ジンのBitcoinノードはメモリプールからトランザクションを選びます。この選び方はそれぞれのトランザクションごとに優先度を計算し、最も優先度が高いものから先に選びます。トランザクション優先度は未使用トランザクションであるUTXOの"年齢"に基づき計算され、新しくより小さいvalueインプットを持つトランザクションよりも古く大きなvalueインプットを持つトランザクションが優先されます。優先されたトランザクションは、もしこのブロックに十分なスペースがあればトランザクション手数料がないトランザクションも送られます。

The priority of a transaction is calculated as the sum of the value and age of the inputs divided by the total size of the transaction:

トランザクションの優先度は、インプットのvalueと年齢の積の総和をトランザクションの総データサイズで割ったもので計算しています。

----
Priority = Sum (Value of input * Input Age) / Transaction Size
----

In this equation, the value of an input is measured in the base unit, satoshis (1/100m of a bitcoin). The age of a UTXO is the number of blocks that have elapsed since the UTXO was recorded on the blockchain, measuring how many blocks "deep" into the blockchain it is. The size of the transaction is measured in bytes.

この方程式にあるインプットのvalueはsatoshi単位(bitcoinの１億分の１)で計られます。UTXOの年齢はUTXOがブロックチェーンに記録されてから積み重ねられたブロック数で、このUTXOが含まれているブロックがブロックチェーンのトップから何ブロック"深いか"で計ります。トランザクションのデータサイズはバイト単位で計られます。

For a transaction to be considered "high priority," its priority must be greater than 57,600,000, which corresponds to one bitcoin (100m satoshis), aged one day (144 blocks), in a transaction of 250 bytes total size:

トランザクションが"優先度が高い"と判断されるようになるためには、優先度が57,600,000よりも大きくなければいけません。これは、インプットのvalueが1bitcoin(１億satoshi)、年齢が１日(144ブロック)、トランザクションのデータサイズが250バイトに相当します。

----
High Priority > 100,000,000 satoshis * 144 blocks / 250 bytes = 57,600,000
----

The first 50 kilobytes of transaction space in a block are set aside for high-priority transactions. Jing's node will fill the first 50 kilobytes, prioritizing the highest priority transactions first, regardless of fee. This allows high-priority transactions to be processed even if they carry zero fees.

ブロック内のトランザクションスペースの最初の50KBは、優先度が高いトランザクションのために取ってあります。このため、ジンのBitcoinノードは、トランザクション手数料に関わらず、最初の50KBを最も優先度が高いトランザクションで埋めます。優先度が高いトランザクションはトランザクション手数料がゼロであっても処理されます。

Jing's mining node then fills the rest of the block up to the maximum block size (+MAX_BLOCK_SIZE+ in the code), with transactions that carry at least the minimum fee, prioritizing those with the highest fee per kilobyte of transaction.

その後、ジンのマイニングBitcoinノードはブロックの残りをブロックサイズの最大値(コード内の +MAX_BLOCK_SIZE+ )までトランザクションで埋めます。ここで埋められるトランザクションは、最低トランザクション手数料以上を持ち、かつ最も高いトランザクション手数料をトランザクションのデータサイズ(KB単位)で割った値による優先度が高いトランザクションです。

If there is any space remaining in the block, Jing's mining node might choose to fill it with no-fee transactions. Some miners choose to mine transactions without fees on a best-effort basis. Other miners may choose to ignore transactions without fees. 

もしブロックにまだスペースがあれば、ジンのマイニングBitcoinノードはトランザクション手数料がないトランザクションを残りブロックスペースに埋めることを選択するかもしれません。いくつかのマイナーは最善努力としてトランザクション手数料をマイニングすることを選びますが、他のマイナーはトランザクション手数料がないトランザクションは無視するかもしれません。

Any transactions left in the memory pool, after the block is filled, will remain in the pool for inclusion in the next block. As transactions remain in the memory pool, their inputs "age," as the UTXO they spend get deeper into the blockchain with new blocks added on top. Because a transaction's priority depends on the age of its inputs, transactions remaining in the pool will age and therefore increase in priority. Eventually a transaction without fees might reach a high enough priority to be included in the block for free. 

このブロックが全て埋められた後、メモリプールに残されたトランザクションは次のブロックに含めるためにメモリプールに残されます。トランザクションがメモリプールに残る時間が長くなるにつれて、このトランザクションインプットの年齢はどんどん上がっていきます。これは、新しいブロックがブロックチェーンの上にどんどん追加されるためです。トランザクションの優先度はこのトランザクションのインプットの年齢に依るので、メモリプールに残ったままになっているトランザクションは古くなり優先度が上がっていきます。結局トランザクション手数料を持たないトランザクションは十分に高い優先度になり無料でブロックに取り込まれます。

((("transactions","expiration, lack of")))Bitcoin transactions do not have an expiration time-out. A transaction that is valid now will be valid in perpetuity. However, if a transaction is only propagated across the network once, it will persist only as long as it is held in a mining node memory pool. When a mining node is restarted, its memory pool is wiped clear, because it is a transient non-persistent form of storage. Although a valid transaction might have been propagated across the network, if it is not executed it may eventually not reside in the memory pool of any miner. Wallet software is expected to retransmit such transactions or reconstruct them with higher fees if they are not successfully executed within a reasonable amount of time.

((("transactions","expiration, lack of")))Bitcoinトランザクションに期限はありません。今有効なトランザクションは永遠に有効です。しかし、もしトランザクションがBitcoinネットワーク内を一度しか伝搬されないとすると、このトランザクションはマイニングBitcoinノードのメモリプールに保持されている間だけしか存在することはできません。マイニングBitcoinノードが再起動されたとき、そのメモリプールは初期化されデータが削除されます。というのは、メモリプールが一時的なストレージであるためです。有効なトランザクションはBitcoinネットワークを通じて伝搬されるかもしれませんが、結局もし伝搬されなければ長期間メモリプールに居続けることはできないことになります。ウォレットには、そのようなトランザクションを再送信したり、また適度な時間以内でうまく処理されないようであればより高いトランザクション手数料を設定してトランザクションを再構築するようなことが期待されています。

When Jing's node aggregates all the transactions from the memory pool, the new candidate block has 418 transactions with total transaction fees of 0.09094928 bitcoin. You can see this block in the blockchain using the Bitcoin Core client command-line interface, as shown in <<block277316>>.(((range="endofrange", startref="ix_ch08-asciidoc9")))(((range="endofrange", startref="ix_ch08-asciidoc8")))(((range="endofrange", startref="ix_ch08-asciidoc7")))(((range="endofrange", startref="ix_ch08-asciidoc6")))(((range="endofrange", startref="ix_ch08-asciidoc5")))(((range="endofrange", startref="ix_ch08-asciidoc4")))

ジンのBitcoinノードはメモリプールから全てのトランザクションを集め、新しい候補ブロックは総トランザクション手数料が0.09094928bitcoinになる418個のトランザクションを持つようになりました。<<block277316>>に示しているように、Bitcoin Coreクライアントのコマンドラインインターフェイスを使うことで、ブロックチェーン内のこのブロックを確認することができます。(((range="endofrange", startref="ix_ch08-asciidoc9")))(((range="endofrange", startref="ix_ch08-asciidoc8")))(((range="endofrange", startref="ix_ch08-asciidoc7")))(((range="endofrange", startref="ix_ch08-asciidoc6")))(((range="endofrange", startref="ix_ch08-asciidoc5")))(((range="endofrange", startref="ix_ch08-asciidoc4")))

====
[source,bash]
----
$ bitcoin-cli getblockhash 2773160000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4

$ bitcoin-cli getblock 0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4
----
====
[[block277316]]
.Block 277,316
.ブロック277,316 
====
[source,json]
----
{
    "hash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
    "confirmations" : 35561,
    "size" : 218629,
    "height" : 277316,
    "version" : 2,
    "merkleroot" : "c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e",
    "tx" : [
        "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
        "b268b45c59b39d759614757718b9918caf0ba9d97c56f3b91956ff877c503fbe",

        ... 417 more transactions ...

       ],
    "time" : 1388185914,
    "nonce" : 924591752,
    "bits" : "1903a30c",
    "difficulty" : 1180923195.25802612,
    "chainwork" : "000000000000000000000000000000000000000000000934695e92aaf53afa1a",
    "previousblockhash" : "0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569",
    "nextblockhash" : "000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"
}
----
====

==== The Generation Transaction
==== Generationトランザクション

((("coinbase transaction", id="ix_ch08-asciidoc10", range="startofrange")))The first transaction added to the block is a special transaction, called a _generation transaction_ or _coinbase transaction_. This transaction is constructed by Jing's node and is his reward for the mining effort. Jing's node creates the generation transaction as a payment to his own wallet: "Pay Jing's address 25.09094928 bitcoin." The total amount of reward that Jing collects for mining a block is the sum of the coinbase reward (25 new bitcoins) and the transaction fees (0.09094928) from all the transactions included in the block as shown in <<generation_tx_example>>: 

((("coinbase transaction", id="ix_ch08-asciidoc10", range="startofrange")))ブロックに最初の追加されたトランザクションは特別なトランザクションで、 _generationトランザクション_ または _coinbaseトランザクション_ と呼ばれています。このトランザクションはジンのBitcoinノードによって構築され、マイニング労力に対する彼の報酬になります。ジンのBitcoinノードは彼自身のウォレットへの支払いとしてgenerationトランザクションを作ります。具体的には "ジンのBitcoinアドレスに25.09094928bitcoinを支払う" のようなものです。ジンがブロックをマイニングしたことに対する報酬総額は、coinbase報酬(新規の25bitcoin)と、ブロックに含まれている全てのトランザクションから得られたトランザクション手数料(0.09094928bitcoin)の和になります。これは、 <<generation_tx_example>> に示されています。


====
----
$ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1
----
====

[[generation_tx_example]]
.Generation transaction
.generationトランザクション
====
[source,json]
----
{
    "hex" : "01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000",
    "txid" : "d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f",
    "version" : 1,
    "locktime" : 0,
    "vin" : [
        {
            "coinbase" : "03443b0403858402062f503253482f",
            "sequence" : 4294967295
        }
    ],
    "vout" : [
        {
            "value" : 25.09094928,
            "n" : 0,
            "scriptPubKey" : {
                "asm" : "02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG",
                "hex" : "2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac",
                "reqSigs" : 1,
                "type" : "pubkey",
                "addresses" : [
                    "1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N"
                ]
            }
        }
    ],
    "blockhash" : "0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4",
    "confirmations" : 35566,
    "time" : 1388185914,
    "blocktime" : 1388185914
}
----
====

Unlike regular transactions, the generation transaction does not consume (spend) UTXO as inputs. Instead, it has only one input, called the _coinbase_, which creates bitcoin from nothing. The generation transaction has one output, payable to the miner's own bitcoin address. The output of the generation transaction sends the value of 25.09094928 bitcoins to the miner's bitcoin address, in this case +1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N+. 

通常のトランザクションと違って、generationトランザクションはインプットとしてUTXOを持ちません。その代わり、 _coinbase_ と呼ばれるたった１つのインプットを持ち、これが何もないところからbitcoinを生み出すことになります。generationトランザクションは１つのアウトプットを持ち、これはマイナー自身のBitcoinアドレスへの支払いになっています。このため、上記のgenerationトランザクションのアウトプットは、マイナーのBitcoinアドレスである +1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N+ に25.09094928bitcoinを送ることになります。

==== Coinbase Reward and Fees
==== coinbase報酬と手数料

((("coinbase data","fees and")))((("coinbase reward, calculating")))((("fees, transaction","calculating")))((("fees, transaction","generation transactions and")))((("generation transaction","coinbase rewards and")))((("generation transaction","fees and")))To construct the generation transaction, Jing's node first calculates the total amount of transaction fees by adding all the inputs and outputs of the 418 transactions that were added to the block. The fees are calculated as:

((("coinbase data","fees and")))((("coinbase reward, calculating")))((("fees, transaction","calculating")))((("fees, transaction","generation transactions and")))((("generation transaction","coinbase rewards and")))((("generation transaction","fees and")))generationトランザクションを構築するために、ジンのBitcoinノードは最初にトランザクション手数料の総額を計算します。この総額は、ブロックに追加された418個のトランザクションのインプットとアウトプットから計算され、トランザクション手数料は以下のようになります。

----
Total Fees = Sum(Inputs) - Sum(Outputs)
----

In block 277,316, the total transaction fees are 0.09094928 bitcoins. 

ブロック277,316にあるトランザクション手数料の総額は0.09094928bitcoinです。

Next, Jing's node calculates the correct reward for the new block. The reward is calculated based on the block height, starting at 50 bitcoins per block and reduced by half every 210,000 blocks. Because this block is at height 277,316, the correct reward is 25 bitcoins. 

次に、ジンのBitcoinノードは新しいブロックに対する正規の報酬を計算します。この報酬はブロック高に基づいて計算され、最初は１ブロックあたり50bitcoinから始まり210,000ブロックごとに半分に減っていきます。このブロックのブロック高は277,316であるため、正規の報酬は25bitcoinです。

The calculation can be seen in function +GetBlockValue+ in the Bitcoin Core client, as shown in <<getblockvalue_source>>.

この計算は<<getblockvalue_source>>にあるようにBitcoin Coreクライアントにある +GetBlockValue+ 関数で確認できます。

[[getblockvalue_source]]
.Calculating the block reward—Function GetBlockValue, Bitcoin Core Client, main.cpp, line 1305
.ブロックの報酬を計算する関数GetBlockValue(Bitcoin Coreクライアントのmain.cpp 1305行目)
====
[source, cpp]
----
int64_t GetBlockValue(int nHeight, int64_t nFees)
{
    int64_t nSubsidy = 50 * COIN;
    int halvings = nHeight / Params().SubsidyHalvingInterval();

    // Force block reward to zero when right shift is undefined.
    if (halvings >= 64)
        return nFees;

    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.
    nSubsidy >>= halvings;

    return nSubsidy + nFees;
}
----
====

The initial subsidy is calculated in satoshis by multiplying 50 with the +COIN+ constant (100,000,000 satoshis). This sets the initial reward (+nSubsidy+) at 5 billion satoshis. 

初期報酬は、 +COIN+ 定数(100,000,000satoshi)に50を掛けてsatoshi単位で表したものになっています。これによって初期報酬( +nSubsidy+ )が50億satoshiになっています。

((("halvings, calculating")))Next, the function calculates the number of +halvings+ that have occurred by dividing the current block height by the halving interval (+SubsidyHalvingInterval+). In the case of block 277,316, with a halving interval every 210,000 blocks, the result is 1 halving. 

((("halvings, calculating")))次に、この関数は半減ブロック数( +SubsidyHalvingInterval+ )で現在のブロック高を割るごとに起こった半減数 +halvings+ を計算しています。ブロック277,316の場合、半減ブロック数が210,000ブロックごとであるため結果は1回の半減数となります。

The maximum number of halvings allowed is 64, so the code imposes a zero reward (return only the fees) if the 64 halvings is exceeded.

許されている半減数の最大値は64回で、もし64回の半減数を越えるとこのコードでは新しいブロックに対する報酬が0になります(単にトランザクション手数料のみが返る)。

Next, the function uses the binary-right-shift operator to divide the reward (+nSubsidy+) by two for each round of halving. In the case of block 277,316, this would binary-right-shift the reward of 5 billion satoshis once (one halving) and result in 2.5 billion satoshis, or 25 bitcoins. The binary-right-shift operator is used because it is more efficient for division by two than integer or floating-point division. 

次に、この関数は２進数右シフト演算子を使って報酬(+nSubsidy+)を半減ごとに２で割っています。ブロック277,316の場合、これは50億satoshiの報酬を１回だけ２進数右シフト演算(１回半減)を行い報酬は25億satoshi(2.5 billion satoshi)となります。２進数右シフト演算子は、整数または浮動小数点での割り算よりもより効果的に２で割ることができるために使われています。

Finally, the coinbase reward (+nSubsidy+) is added to the transaction fees (+nFees+), and the sum is returned. 

最終的に、coinbase報酬( +nSubsidy+ )にはトランザクション手数料( +nFees+ )が加えられ、この和が返されます。

==== Structure of the Generation Transaction
==== generationトランザクションの構造

((("generation transaction","structure of")))With these calculations, Jing's node then constructs the generation transaction to pay himself 25.09094928 bitcoin.

((("generation transaction","structure of")))これらの計算を行うことで、ジンのBitcoinノードは彼自身に25.09094928bitcoinを支払うためにgenerationトランザクションを構築します。

As you can see in <<generation_tx_example>>, the generation transaction has a special format. Instead of a transaction input specifying a previous UTXO to spend, it has a "coinbase" input. We examined transaction inputs in <<tx_in_structure>>. Let's compare a regular transaction input with a generation transaction input. <<table_8-1>> shows the structure of a regular transaction, while <<table_8-2>> shows the structure of the generation transaction's input.

<<generation_tx_example>>を見ると分かるように、generationトランザクションは特別なフォーマットをしています。使用する前のUTXOを特定するトランザクションインプットと違って、これは"coinbase"インプットを持っています。<<tx_in_structure>>の中でトランザクションインプットを説明しました。ここでは、通常のトランザクションインプットとgenerationトランザクションインプットを比較してみましょう。<<table_8-1>>は通常のトランザクションの構造を示していて、<<table_8-2>>はgenerationトランザクションインプットの構造を示しています。

[[table_8-1]]
.The structure of a "normal" transaction input
."通常"のトランザクションインプットの構造
[options="header"]
|=======
|Size| Field | Description
|サイズ| フィールド名 | 説明
| 32 bytes | Transaction Hash | Pointer to the transaction containing the UTXO to be spent
| 32 bytes | Transaction Hash | 使われるUTXOを含むトランザクションハッシュ
| 4 bytes | Output Index | The index number of the UTXO to be spent, first one is 0
| 4 bytes | Output Index | 使われるUTXOのトランザクション内インデックス、一番最初のアウトプットの場合は0
| 1-9 bytes (VarInt) | Unlocking-Script Size | Unlocking-Script length in bytes, to follow
| 1-9 bytes (VarInt) | Unlocking-Script Size | unlocking-scriptのバイト長
| Variable | Unlocking-Script | A script that fulfills the conditions of the UTXO locking script.
| Variable | Unlocking-Script | UTXOのlocking scriptを満たすscript
| 4 bytes | Sequence Number | Currently disabled Tx-replacement feature, set to 0xFFFFFFFF
|=======

[[table_8-2]]
.The structure of a generation transaction input
.generationトランザクションインプットの構造
[options="header"]
|=======
|Size| Field | Description
|サイズ| フィールド名 | 説明
| 32 bytes | Transaction Hash | All bits are zero: Not a transaction hash reference
| 4 bytes | Output Index | All bits are ones: 0xFFFFFFFF
| 1-9 bytes (VarInt) | Coinbase Data Size | Length of the coinbase data, from 2 to 100 bytes
| Variable | Coinbase Data | Arbitrary data used for extra nonce and mining tags
in v2 blocks, must begin with block height
| 4 bytes | Sequence Number | Set to 0xFFFFFFFF
| 32 bytes | トランザクションハッシュ | 全てのbitが０: トランザクションハッシュ参照ではない
| 4 bytes | Output Index | 全てのbitが１: 0xFFFFFFFF
| 1-9 bytes (VarInt) | coinbaseデータサイズ | coinbaseデータサイズの長さ(2から100byte)
| Variable | coinbaseデータ |  Arbitrary data used for extra nonce and mining tags
in v2 blocks, must begin with block height
| 4 bytes | Sequence Number | Set to 0xFFFFFFFF
|=======

In a generation transaction, the first two fields are set to values that do not represent a UTXO reference. Instead of a "Transaction Hash," the first field is filled with 32 bytes all set to zero. The "Output Index" is filled with 4 bytes all set to 0xFF (255 decimal). The "Unlocking Script" is replaced by coinbase data, an arbitrary data field used by the miners. 

gerationトランザクションでは、最初の２つのフィールドはUTXOへの参照を表現していない値が設定されています。通常のトランザクションの"Transaction Hash"の代わりに、最初のフィールドは全てが0の32バイトで埋められています。"Output Index"は全てが0xFF(１０進数で255)に設定された4バイトで埋められています。"Unlocking Script"はcoinbaseデータで置き換えられており、マイナーによって使われる任意のデータを入れられるフィールドになっています。

==== Coinbase Data
==== Coinbaseデータ

((("coinbase data", id="ix_ch08-asciidoc11", range="startofrange")))((("generation transaction","coinbase data", id="ix_ch08-asciidoc12", range="startofrange")))((("unlocking scripts","generation transactions and")))Generation transactions do not have an unlocking script (a.k.a., +scriptSig+) field. Instead, this field is replaced by coinbase data, which must be between 2 and 100 bytes. Except for the first few bytes, the rest of the coinbase data can be used by miners in any way they want; it is arbitrary data. 

((("coinbase data", id="ix_ch08-asciidoc11", range="startofrange")))((("generation transaction","coinbase data", id="ix_ch08-asciidoc12", range="startofrange")))((("unlocking scripts","generation transactions and")))generationトランザクションはunlocking scriptフィールド(a.k.a, +scriptSig+ )を持っていません。その代わりに、このフィールドはcoinbaseデータで置き換えられています。このフィールドに入るデータは2バイトから100バイトの間のデータになっていなければいけません。

In the genesis block, for example, Satoshi Nakamoto added the text "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks" in the coinbase data, using it as a proof of the date and to convey a message. Currently, miners use the coinbase data to include extra nonce values and strings identifying the mining pool, as we will see in the following sections. 

例えば起源ブロックのcoinbaseデータに、Satoshi Nakamotoは日付と"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"というテキストを加えました。Satoshi Nakamotoはこれを日付の証明と伝えたいメッセージのために使用しています。以下の節で見るように、現在マイナーはcoinbaseデータを余分なnonce valueやマイニングプールを特定する文字列を含めることに使っています。

The first few bytes of the coinbase used to be arbitrary, but that is no longer the case. As per Bitcoin Improvement Proposal 34 (BIP0034), version-2 blocks (blocks with the version field set to 2) must contain the block height index as a script "push" operation in the beginning of the coinbase field. 

coinbaseデータの最初の数バイトは任意に使われていましたが、現在はもはやこのようにはなっていません。Bitcoin Improvement Proposal 34 (BIP0034)により、version-2 ブロック(ブロックのversionフィールドが2)は、scriptの"push"オペレーションとしてブロック高をcoinbaseフィールドの最初に含めなければいけません。

In block 277,316 we see that the coinbase (see <<generation_tx_example>>), which is in the "Unlocking Script" or +scriptSig+ field of the transaction input, contains the hexadecimal value +03443b0403858402062f503253482f+. Let's decode this value. 

ブロック277,316では、このcoinbase(<<generation_tx_example>>参照)のトランザクションインプットにある"Unlocking script"または +scriptSig+ に +03443b0403858402062f503253482f+ という１６進数が含まれています。これをデコードしてみましょう。

The first byte, +03+, instructs the script execution engine to push the next three bytes onto the script stack (see <<tx_script_ops_table_pushdata>>). The next three bytes, +0x443b04+, are the block height encoded in little-endian format (backward, least significant byte first). Reverse the order of the bytes and the result is +0x043b44+, which is 277,316 in decimal. 

最初の１バイト +03+ はscript実行エンジンに次の３バイトをscriptスタックにpushするということを教えています(<<tx_script_ops_table_pushdata>>参照)。次の３バイト +0x443b04+ は、リトルエンディアン(逆読み、最下位バイトが最初に来る)でエンコードされたブロック高です。バイトの順番を逆にして +0x043b44+ にし、これを１０進数で読むと277,316になります。

The next few hexadecimal digits (+03858402062+) are used to encode an extra _nonce_ (see <<extra_nonce>>), or random value, used to find a suitable proof of work solution.

次の数個の１６進数(+03858402062+)は、proof of work適切解を探すための余分な _nonce_ (<<extra_nonce>>参照)、またはランダムな値をエンコードするために使われます。

The final part of the coinbase data (+2f503253482f+) is the ASCII-encoded string +/P2SH/+, which indicates that the mining node that mined this block supports the((("pay-to-script-hash (P2SH)","coinbase data and"))) pay-to-script-hash (P2SH) improvement defined in BIP0016. The introduction of the P2SH capability required a "vote" by miners to endorse either BIP0016 or BIP0017. Those endorsing the BIP0016 implementation were to include +/P2SH/+ in their coinbase data. Those endorsing the BIP0017 implementation of P2SH were to include the string +p2sh/CHV+ in their coinbase data. The BIP0016 was elected as the winner, and many miners continued including the string +/P2SH/+ in their coinbase to indicate support for this feature.

(CONFLICT)
coinbaseデータの最後の部分(+2f503253482f+)は +/P2SH/+ のASCIIコードで、このブロックを採掘したマイニングBitcoinノードがBIP0016で定義されている((("pay-to-script-hash (P2SH)","coinbase data and"))) pay-to-script-hash (P2SH) 改善をサポートしているということを示しています。
P2SH利用性の導入は、マイナーによる"投票"

<<satoshi_words>> uses the libbitcoin library introduced in <<alt_libraries>> to extract the coinbase data from the genesis block, displaying Satoshi's message. Note that the libbitcoin library contains a static copy of the genesis block, so the example code can retrieve the genesis block directly from the library. 

<<satoshi_words>>は<<alt_libraries>>で紹介したlibbitcoinライブラリを使っており、起源ブロックからcoinbaseデータを抽出してSatoshiのメッセージを表示するものです。libbitcoinライブラリは起源ブロックの静的なコピーを持っており、この例コードではこのライブラリから直接起源ブロックを取得することができます。

[[satoshi_words]]
.Extract the coinbase data from the genesis block
.起源ブロックからのcoinbaseデータの抽出
====
[source, cpp]
----
include::code/satoshi-words.cpp[]
----
====

We compile the code with the GNU C++ compiler and run the resulting executable, as shown in <<satoshi_words_run>>.(((range="endofrange", startref="ix_ch08-asciidoc12")))(((range="endofrange", startref="ix_ch08-asciidoc11")))(((range="endofrange", startref="ix_ch08-asciidoc10")))

<<satoshi_words_run>>では、このコードをGNU C++ コンパイラでコンパイルし、出力される実行ファイルを実行しています。(((range="endofrange", startref="ix_ch08-asciidoc12")))(((range="endofrange", startref="ix_ch08-asciidoc11")))(((range="endofrange", startref="ix_ch08-asciidoc10")))

[[satoshi_words_run]]
.Compiling and running the satoshi-words example code
.satoshi-words例コードのコンパイルと実行
====
[source,bash]
----
$ # Compile the code
$  g++ -o satoshi-words satoshi-words.cpp $(pkg-config --cflags --libs libbitcoin)
$ # Run the executable
$ ./satoshi-words
^D��<GS>^A^DEThe Times 03/Jan/2009 Chancellor on brink of second bailout for banks
----
====

=== Constructing the Block Header
=== ブロックヘッダの構築

((("block headers","constructing")))To construct the block header, the mining node needs to fill in six fields, as listed in <<block_header_structure_ch08>>.

((("block headers","constructing")))ブロックヘッダを構築するために、このマイニングBitcoinノードは<<block_header_structure_ch08>>にリストアップしてある６つのフィールドを埋める必要があります。

[[block_header_structure_ch08]]
.The structure of the block header
.ブロックヘッダの構造
[options="header"]
|=======
|Size| Field | Description
| 4 bytes | Version | A version number to track software/protocol upgrades
| 32 bytes | Previous Block Hash | A reference to the hash of the previous (parent) block in the chain
| 32 bytes | Merkle Root | A hash of the root of the merkle tree of this block's transactions
| 4 bytes | Timestamp | The approximate creation time of this block (seconds from Unix Epoch)
| 4 bytes | Difficulty Target | The proof-of-work algorithm difficulty target for this block
| 4 bytes | Nonce | A counter used for the proof-of-work algorithm
|=======

At the time that block 277,316 was mined, the version number describing the block structure is version 2, which is encoded in little-endian format in 4 bytes as +0x02000000+. 

ブロック277,316が採掘された時点でこのブロック構造を記述しているversionは2で、このブロックには4byteをリトルエンディアンでエンコードした +0x02000000+ が入っています。

Next, the mining node needs to add the((("Previous Block Hash"))) "Previous Block Hash." That is the hash of the block header of block 277,315, the previous block received from the network, which Jing's node has accepted and selected as the parent of the candidate block 277,316. The block header hash for block 277,315 is:

次に、このマイニングBitcoinノードは((("Previous Block Hash"))) "１つ前のブロックハッシュ"を追加する必要があります。これはブロック277,315のブロックヘッダのハッシュです。このBitcoinネットワークから受け取った１つ前のハッシュは、ジンのBitcoinノードが受理し、候補ブロック277,316の親として選んだブロックです。ブロック277,315のブロックヘッダハッシュは以下です。

----
0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569
----

((("merkle trees","constructing block headers with")))The next step is to summarize all the transactions with a merkle tree, in order to add the merkle root to the block header. The generation transaction is listed as the first transaction in the block. Then, 418 more transactions are added after it, for a total of 419 transactions in the block. As we saw in the <<merkle_trees>>, there must be an even number of "leaf" nodes in the tree, so the last transaction is duplicated, creating 420 nodes, each containing the hash of one transaction. The transaction hashes are then combined, in pairs, creating each level of the tree, until all the transactions are summarized into one node at the "root" of the tree. The root of the merkle tree summarizes all the transactions into a single 32-byte value, which you can see listed as "merkle root" in <<block277316>>, and here: 

((("merkle trees","constructing block headers with")))次のステップは、merkle rootをブロックヘッダに加えるために、全てのトランザクションをmerkle treeにまとめることです。generationトランザクションはブロックの最初のトランザクションになっています。418個のトランザクションはこのgenerationトランザクションのあとに追加され、全部で419個のトランザクションがブロックの中にあることになります。<<merkle_trees>>で見たように、merkle treeは偶数個の"葉"ノードを持たなければいけません。このため、最後のトランザクションは重複することになり、420個の葉ノードが作られます。それぞれ葉ノードはトランザクションのハッシュを保持しています。トランザクションハッシュはペアを組んで結びつけられ、merkle treeの階層を作っていき、全てのトランザクションがmerkle treeの"root"に１つの葉ノードが作られるまで続きます。merkle treeのrootは全てのトランザクションを１つの32バイトの値にまとめ、この値は<<block277316>>にある"merkle root"を見ることで確認でき、その値は以下になっています。

----
c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e
----
    
((("timestamping blocks")))The mining node will then add a 4-byte timestamp, encoded as a Unix "Epoch" timestamp, which is based on the number of seconds elapsed from January 1, 1970, midnight UTC/GMT. The time +1388185914+ is equal to Friday, 27 Dec 2013, 23:11:54 UTC/GMT.

((("timestamping blocks")))マイニングBitcoinノードはこのときUnixの"Epoch"タイムスタンプのようにエンコードされた4バイトのタイムスタンプを追加します。Unixの"Epoch"タイムスタンプは、1970年1月1日 深夜0:00 UTC/GMTから経過した秒数に基づいています。時刻 +1388185914+ は2013年12月27日金曜日 23:11:54 UTC/GMTと同じです。

((("difficulty target","constructing block headers and")))The node then fills in the difficulty target, which defines the required proof-of-work difficulty to make this a valid block. The difficulty is stored in the block as a "difficulty bits" metric, which is a mantissa-exponent encoding of the target. The encoding has a 1-byte exponent, followed by a 3-byte mantissa (coefficient). In block 277,316, for example, the difficulty bits value is +0x1903a30c+. The first part +0x19+ is a hexadecimal exponent, while the next part, +0x03a30c+, is the coefficient. The concept of a difficulty target is explained in <<difficulty_target>> and the "difficulty bits" representation is explained in <<difficulty_bits>>.

((("difficulty target","constructing block headers and")))この後このBitcoinノードはdiffifulty targetを埋めます。これはこのブロックを有効なブロックにするために必要とされるproof-of-work difficultyを定義しています。このdifficultyはブロック内に"difficulty bits"として保存されていて、指数表記の形でエンコードされています。このエンコーディングは1バイトの指数部、3バイトの仮数部(係数)を持っています。例えばブロック277,316の場合、difficulty bitsの値は +0x1903a30c+ です。最初の部分 +0x19+ は１６進数指数部で、次の部分 +0x03a30c+ は係数です。difficulty targetのコンセプトについては <<difficulty_target>> で説明し、"difficulty bits"表現については <<difficulty_bits>> で説明します。

((("nonce,","initializing in block header")))The final field is the nonce, which is initialized to zero. 

((("nonce,","initializing in block header")))最後のフィールドはnonceで、初期値は0です。

With all the other fields filled, the block header is now complete and the process of mining can begin. The goal is now to find a value for the nonce that results in a block header hash that is less than the difficulty target. The mining node will need to test billions or trillions of nonce values before a nonce is found that satisfies the requirement.

全ての他のフィールドを埋めると、ブロックヘッダは完全なものとなりマイニングプロセスを始めることができます。このゴールはdifficulty targetよりも小さいブロックヘッダハッシュになるnonceに対する値を見つけることです。このマイニングBitcoinノードは必要条件を満たすようなnonceを見つける前に１０億個または１兆個のnonceの値を調べてみる必要があるのです。

=== Mining the Block
=== ブロックのマイニング

((("blocks","mining", id="ix_ch08-asciidoc13", range="startofrange")))((("mining","blocks", id="ix_ch08-asciidoc14", range="startofrange")))Now that a candidate block has been constructed by Jing's node, it is time for Jing's hardware mining rig to "mine" the block, to find a solution to the proof-of-work algorithm that makes the block valid. Throughout this book we have studied cryptographic hash functions as used in various aspects of the bitcoin system. The hash function SHA256 is the function used in bitcoin's mining process. 

((("blocks","mining", id="ix_ch08-asciidoc13", range="startofrange")))((("mining","blocks", id="ix_ch08-asciidoc14", range="startofrange")))今や候補ブロックはジンのBitcoinノードによって構築され、ジンのハードウェアmining rigがブロックを"採掘"し、ブロックを有効にするproof-of-workアルゴリズムに対する解を見つけるときです。この本を通して、Bitcoinシステムのいろいろな面で暗号学的ハッシュ関数を使い学んできました。ハッシュ関数SHA256はBitcoinのマイニングプロセスの中で使われる暗号学的ハッシュ関数です。

In the simplest terms, mining is the process of hashing the block header repeatedly, changing one parameter, until the resulting hash matches a specific target. The hash function's result cannot be determined in advance, nor can a pattern be created that will produce a specific hash value. This feature of hash functions means that the only way to produce a hash result matching a specific target is to try again and again, randomly modifying the input until the desired hash result appears by chance. 

最もシンプルに言うと、マイニングとは１つのパラメータを変えながらブロックヘッダを繰り返しハッシュ化するプロセスで、出力されるハッシュが特別なターゲットに一致するまで行われます。ハッシュ関数の結果は、先に立って決めることはできず、また特別なハッシュ値を作り出すためのパターンを作り出すこともできません。このハッシュ関数の特徴は次のことを意味しています。特別な条件に合うハッシュを作り出すただ１つの方法は、入力をランダムに修正しながら偶然に欲しいハッシュが現れるまで試行を繰り返し繰り返し行うことです。

==== Proof-Of-Work Algorithm
==== Proof-Of-Workアルゴリズム

((("mining","proof-of-work algorithm and", id="ix_ch08-asciidoc15", range="startofrange")))((("Proof-Of-Work algorithm", id="ix_ch08-asciidoc16", range="startofrange")))A hash algorithm takes an arbitrary-length data input and produces a fixed-length deterministic result, a digital fingerprint of the input. For any specific input, the resulting hash will always be the same and can be easily calculated and verified by anyone implementing the same hash algorithm. The key characteristic of a cryptographic hash algorithm is that it is virtually impossible to find two different inputs that produce the same fingerprint. As a corollary, it is also virtually impossible to select an input in such a way as to produce a desired fingerprint, other than trying random inputs.

((("mining","proof-of-work algorithm and", id="ix_ch08-asciidoc15", range="startofrange")))((("Proof-Of-Work algorithm", id="ix_ch08-asciidoc16", range="startofrange")))ハッシュアルゴリズムは任意の長さのデータ入力を取り、このデータ入力のデジタルフィンガープリントとして固定長の決定性を持った結果を作り出します。どんな特別な入力に対しても、出力されるハッシュは常に同じで、たやすく計算でき、同じハッシュアルゴリズムを実装している人は誰でも検証できます。暗号学的ハッシュアルゴリズムのキーとなる特徴は、同じフィンガープリントを作り出す２つの違った入力を探すことは至難の業であることです。これからの自然の帰結として、ランダムな入力を試すよりも簡単に欲しいフィンガープリントを作り出すような入力を選ぶこともまた至難の技なのです。

With SHA256, the output is always 256 bits long, regardless of the size of the input. In <<sha256_example1>>, we will use the Python interpreter to calculate the SHA256 hash of the phrase, "I am Satoshi Nakamoto." 

SHA256だと出力結果は常に256bitの長さになり、これは入力のデータサイズに関わらず決まります。<<sha256_example1>>では、Pythonインタプリタを使ってフレーズ "I am Satoshi Nakamoto." のSHA256ハッシュを計算しています。

[[sha256_example1]]
.SHA256 example
.SHA256での例
====
[source,bash]
----
$ python
----
[source,pycon]
----
Python 2.7.1
>>> import hashlib
>>> print hashlib.sha256("I am Satoshi Nakamoto").hexdigest()
5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e
----
====

<<sha256_example1>> shows the result of calculating the hash of +"I am Satoshi Nakamoto"+: +5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e+. This 256-bit number is the _hash_ or _digest_ of the phrase and depends on every part of the phrase. Adding a single letter, punctuation mark, or any other character will produce a different hash.

<<sha256_example1>>は +"I am Satoshi Nakamoto"+ のハッシュ +5d7c7ba21cbbcd75d14800b100252d5b428e5b1213d27c385bc141ca6b47989e+ を計算した結果を示しています。この256bitの数字はこのフレーズの _ハッシュ_ または _ダイジェスト_ であり、このフレーズの全ての部分に依っています。１個の文字、句読点、または他のいかなる文字でも追加すると異なるハッシュが生成されます。

Now, if we change the phrase, we should expect to see completely different hashes. Let's try that by adding a number to the end of our phrase, using the simple Python scripting in <<sha256_example_generator>>.

今、もしこのフレーズを変えると完全に違ったハッシュが生成されるはずです。フレーズの最後に数字を追加して作った新しいフレーズのハッシュが全く違うハッシュになることを試してみましょう。ハッシュ生成には <<sha256_example_generator>> にあるシンプルなPythonスクリプトを使います。

[[sha256_example_generator]]
.SHA256 A script for generating many hashes by iterating on a nonce
.nonce生成を繰り返すことで多くのSHA256ハッシュを生成するスクリプト
====
[source, python]
----
include::code/hash_example.py[]
----
====

Running this will produce the hashes of several phrases, made different by adding a number at the end of the text. By incrementing the number, we can get different hashes, as shown in <<sha256_example_generator_output>>.

これを実行すると、テキストの最後に数字を追加して違った形に作られたいくつかのフレーズのハッシュが生成されます。<<sha256_example_generator_output>>に示している通り、数字を１つずつ増やしていくと違ったハッシュを得ることができます。

((("nonce")))
[[sha256_example_generator_output]]
.SHA256 output of a script for generating many hashes by iterating on a nonce
.nonce生成を繰り返すことで多くのSHA256ハッシュを生成するスクリプト実行出力
====
[source,bash]
----
$ python hash_example.py
----

----
I am Satoshi Nakamoto0 => a80a81401765c8eddee25df36728d732...
I am Satoshi Nakamoto1 => f7bc9a6304a4647bb41241a677b5345f...
I am Satoshi Nakamoto2 => ea758a8134b115298a1583ffb80ae629...
I am Satoshi Nakamoto3 => bfa9779618ff072c903d773de30c99bd...
I am Satoshi Nakamoto4 => bce8564de9a83c18c31944a66bde992f...
I am Satoshi Nakamoto5 => eb362c3cf3479be0a97a20163589038e...
I am Satoshi Nakamoto6 => 4a2fd48e3be420d0d28e202360cfbaba...
I am Satoshi Nakamoto7 => 790b5a1349a5f2b909bf74d0d166b17a...
I am Satoshi Nakamoto8 => 702c45e5b15aa54b625d68dd947f1597...
I am Satoshi Nakamoto9 => 7007cf7dd40f5e933cd89fff5b791ff0...
I am Satoshi Nakamoto10 => c2f38c81992f4614206a21537bd634a...
I am Satoshi Nakamoto11 => 7045da6ed8a914690f087690e1e8d66...
I am Satoshi Nakamoto12 => 60f01db30c1a0d4cbce2b4b22e88b9b...
I am Satoshi Nakamoto13 => 0ebc56d59a34f5082aaef3d66b37a66...
I am Satoshi Nakamoto14 => 27ead1ca85da66981fd9da01a8c6816...
I am Satoshi Nakamoto15 => 394809fb809c5f83ce97ab554a2812c...
I am Satoshi Nakamoto16 => 8fa4992219df33f50834465d3047429...
I am Satoshi Nakamoto17 => dca9b8b4f8d8e1521fa4eaa46f4f0cd...
I am Satoshi Nakamoto18 => 9989a401b2a3a318b01e9ca9a22b0f3...
I am Satoshi Nakamoto19 => cda56022ecb5b67b2bc93a2d764e75f...
----
====

Each phrase produces a completely different hash result. They seem completely random, but you can reproduce the exact results in this example on any computer with Python and see the same exact hashes. 

それぞれのフレーズは完全に違ったハッシュを生成します。これらは完全にランダムであるように見えますが、Pythonがインストールされているどんなコンピュータでもこの例にある結果を厳密に再生成でき、全く同じハッシュを見ることができます。

The number used as a variable in such a scenario is called a _nonce_. The nonce is used to vary the output of a cryptographic function, in this case to vary the SHA256 fingerprint of the phrase. 

このシナリオの中で変数として使われている数字は _nonce_ と呼ばれています。このnonceは暗号学的関数の出力を変えるために使われ、この例の場合フレーズのSHA256フィンガープリントを変えるために使われています。

((("difficulty target","defined")))To make a challenge out of this algorithm, let's set an arbitrary target: find a phrase that produces a hexadecimal hash that starts with a zero. Fortunately, this isn't difficult! <<sha256_example_generator_output>> shows that the phrase "I am Satoshi Nakamoto13" produces the hash +0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5+, which fits our criteria. It took 13 attempts to find it. In terms of probabilities, if the output of the hash function is evenly distributed we would expect to find a result with a 0 as the hexadecimal prefix once every 16 hashes (one out of 16 hexadecimal digits 0 through F). In numerical terms, that means finding a hash value that is less than +0x1000000000000000000000000000000000000000000000000000000000000000+. We call this threshold the _target_ and the goal is to find a hash that is numerically _less than the target_. If we decrease the target, the task of finding a hash that is less than the target becomes more and more difficult. 

((("difficulty target","defined")))このアルゴリズムで課題を作るために任意のターゲットを設定しましょう。"0から始まる１６進数ハッシュを生成するフレーズを探しなさい"。幸運なことに、これは難しくありません！ <<sha256_example_generator_output>>が示すように、フレーズ "I am Satoshi Nakamoto13" はハッシュ +0ebc56d59a34f5082aaef3d66b37a661696c2b618e62432727216ba9531041a5+ を生成しており、これはさきほどのターゲットに合っているものです。これを見つけるために１３回の試行を行いました。確率論的に言うと、もしハッシュ関数の出力が均等に分布しているのだとすると、16ハッシュごとに１回１６進数のハッシュの最初が0になる結果が見つかるでしょう(0からFまでの１６個の１６進数のうちの１つ)。数値的に言うと、これは +0x1000000000000000000000000000000000000000000000000000000000000000+ よりも小さいハッシュ値を探すということを意味します。我々はこの閾値を _ターゲット_ と呼ぶことにし、これを使ってゴールは数値的に _targetよりも小さい_ ハッシュを見つけることになります。もしターゲットを小さくすれば、ターゲットより小さいハッシュを見つけることはさらに難しくなります。
 
To give a simple analogy, imagine a game where players throw a pair of dice repeatedly, trying to throw less than a specified target. In the first round, the target is 12. Unless you throw double-six, you win. In the next round the target is 11. Players must throw 10 or less to win, again an easy task. Let's say a few rounds later the target is down to 5. Now, more than half the dice throws will add up to more than 5 and therefore be invalid. It takes exponentially more dice throws to win, the lower the target gets. Eventually, when the target is 2 (the minimum possible), only one throw out of every 36, or 2% of them, will produce a winning result. 

簡単な類推をするためにプレイヤーが２つのサイコロを繰り返し投げ、特定のターゲットよりも和が小さくなるようにするゲームを想像してみましょう。最初のラウンドでは、ターゲットは12です。２つの６を出さなければ、あなたの勝ちです。次のラウンドではターゲットを11にしましょう。プレイヤーは10かそれより小さくしなければいけませんが、これも簡単です。数回のラウンドの後ターゲットを5に下げてみましょう。今、サイコロを投げたうち半分以上が5よりも大きくなってしまいました。ターゲットがより低くなればなるほど、勝つために投げるサイコロの回数は指数関数的に大きくなっていきます。結局、ターゲットが2(可能な限り小さい)では、36回サイコロを投げるうちたった１回、つまり全体の2%だけがゲームに勝つ結果を生成することになります。

In <<sha256_example_generator_output>>, the winning "nonce" is 13 and this result can be confirmed by anyone independently. Anyone can add the number 13 as a suffix to the phrase "I am Satoshi Nakamoto" and compute the hash, verifying that it is less than the target. The successful result is also proof of work, because it proves we did the work to find that nonce. While it only takes one hash computation to verify, it took us 13 hash computations to find a nonce that worked. If we had a lower target (higher difficulty) it would take many more hash computations to find a suitable nonce, but only one hash computation for anyone to verify. Furthermore, by knowing the target, anyone can estimate the difficulty using statistics and therefore know how much work was needed to find such a nonce.

<<sha256_example_generator_output>>では、勝利 "nonce" は13で、この結果は誰でも独立に確認することができます。誰でも数値13をさきほどのフレーズ "I am Satoshi Nakamoto" の最後に追加し、ハッシュを計算し、ターゲットより小さいことを検証することができます。この上出来な結果はproof of workでもあります。というのは、これがあのnonceを見つける仕事をしたことの証明だからです。検証するためにはたった１回のハッシュ計算でよい一方、うまくいくnonceを見つけるためには13回のハッシュ計算が必要になります。もしより低いターゲット(より高いdifficulty)を使ったとすると、適したnonceを探すためにさらにたくさんのハッシュ計算が必要になるのですが、検証をするには誰でも１回のハッシュ計算で済みます。さらに、ターゲットを知ることによって、統計を使って誰でもdifficultyの見積もりをすることができ、よってどれだけの仕事がそのようなnonceを見つけるために必要だったかを知ることができるのです。

Bitcoin's proof of work is very similar to the challenge shown in <<sha256_example_generator_output>>. The miner constructs a candidate block filled with transactions. Next, the miner calculates the hash of this block's header and sees if it is smaller than the current _target_. If the hash is not less than the target, the miner will modify the nonce (usually just incrementing it by one) and try again. At the current difficulty in the bitcoin network, miners have to try quadrillions of times before finding a nonce that results in a low enough block header hash.

Bitcoinのproof of workは<<sha256_example_generator_output>>に示した課題ととても似ています。まずマイナーはトランザクションで埋められた候補ブロックを構築します。次に、ブロックのヘッダのハッシュを計算し、現在の _ターゲット_ より小さいかどうかを確認します。もしそのハッシュがターゲットよりも小さくなければ、マイナーはnonceを修正し(通常は１つ増加させるだけです)、再びハッシュを計算します。現在のBitcoinネットワークでのdifficultyは、ブロックヘッダハッシュが十分小さくなるnonceを見つける前にマイナーは1000兆回ハッシュを計算する必要があります。

A very simplified proof-of-work algorithm is implemented in Python in <<pow_example1>>.((("proof of work")))

とても簡単化されたproof-of-workアルゴリズムは<<pow_example1>>にPythonで実装されています。((("proof of work")))

[[pow_example1]]
.Simplified proof-of-work implementation
.簡略化されたproof-of-work実装
====
[source, python]
----
include::code/proof-of-work-example.py[]
----
====

Running this code, you can set the desired difficulty (in bits, how many of the leading bits must be zero) and see how long it takes for your computer to find a solution. In <<pow_example_outputs>>, you can see how it works on an average laptop.

このコードを実行すると、欲しいdifficultyを設定でき(difficultyはbit単位。左から数えた桁が何桁0でなければいけないか)、あなたのコンピュータが解を探すためにどれくらい時間がかかるかを見ることができます。<<pow_example_outputs>>では、平均的なノートパソコンでどのように動作するかを見ることができます。

[[pow_example_outputs]]
.Running the proof of work example for various difficulties
.いろいろなdifficultyに対するproof of work例コードの実行
====
[source, bash]
----
$ python proof-of-work-example.py*
----

----
Difficulty: 1 (0 bits)

[...]

Difficulty: 8 (3 bits)
Starting search...
Success with nonce 9
Hash is 1c1c105e65b47142f028a8f93ddf3dabb9260491bc64474738133ce5256cb3c1
Elapsed Time: 0.0004 seconds
Hashing Power: 25065 hashes per second
Difficulty: 16 (4 bits)
Starting search...
Success with nonce 25
Hash is 0f7becfd3bcd1a82e06663c97176add89e7cae0268de46f94e7e11bc3863e148
Elapsed Time: 0.0005 seconds
Hashing Power: 52507 hashes per second
Difficulty: 32 (5 bits)
Starting search...
Success with nonce 36
Hash is 029ae6e5004302a120630adcbb808452346ab1cf0b94c5189ba8bac1d47e7903
Elapsed Time: 0.0006 seconds
Hashing Power: 58164 hashes per second

[...]

Difficulty: 4194304 (22 bits)
Starting search...
Success with nonce 1759164
Hash is 0000008bb8f0e731f0496b8e530da984e85fb3cd2bd81882fe8ba3610b6cefc3
Elapsed Time: 13.3201 seconds
Hashing Power: 132068 hashes per second
Difficulty: 8388608 (23 bits)
Starting search...
Success with nonce 14214729
Hash is 000001408cf12dbd20fcba6372a223e098d58786c6ff93488a9f74f5df4df0a3
Elapsed Time: 110.1507 seconds
Hashing Power: 129048 hashes per second
Difficulty: 16777216 (24 bits)
Starting search...
Success with nonce 24586379
Hash is 0000002c3d6b370fccd699708d1b7cb4a94388595171366b944d68b2acce8b95
Elapsed Time: 195.2991 seconds
Hashing Power: 125890 hashes per second

[...]

Difficulty: 67108864 (26 bits)
Starting search...
Success with nonce 84561291
Hash is 0000001f0ea21e676b6dde5ad429b9d131a9f2b000802ab2f169cbca22b1e21a
Elapsed Time: 665.0949 seconds
Hashing Power: 127141 hashes per second
----
====

As you can see, increasing the difficulty by 1 bit causes an exponential increase in the time it takes to find a solution. If you think of the entire 256-bit number space, each time you constrain one more bit to zero, you decrease the search space by half. In <<pow_example_outputs>>, it takes 84 million hash attempts to find a nonce that produces a hash with 26 leading bits as zero. Even at a speed of more than 120,000 hashes per second, it still requires 10 minutes on a consumer laptop to find this solution. 

見て分かるように、difficultyが1bit増えると解を見つけるためにかかる時間が指数関数的に大きくなります。もし256bitの数値空間全体を考えてみると、さらに1bitだけ0にしなければいけない制約が増えるとたびに解となる空間が半分になってしまうのです。<<pow_example_outputs>>では、左から26bitまでが0になっているようなハッシュを作り出すnonceを見つけるために、8400万回の試行が必要になります。仮に１秒間に12万回以上ハッシュ計算ができたとしても、この解を見つけるために普通のノートパソコンでは10分間もかかってしまいます。

At the time of writing, the network is attempting to find a block whose header hash is less than +000000000000004c296e6376db3a241271f43fd3f5de7ba18986e517a243baa7+. As you can see, there are a lot of zeros at the beginning of that hash, meaning that the acceptable range of hashes is much smaller, hence it's more difficult to find a valid hash. It will take on average more than 150 quadrillion hash calculations per second for the network to discover the next block. That seems like an impossible task, but fortunately the network is bringing 100 petahashes per second (PH/sec) of processing power to bear, which will be able to find a block in about 10 minutes on average.(((range="endofrange", startref="ix_ch08-asciidoc16")))(((range="endofrange", startref="ix_ch08-asciidoc15"))) 

執筆している時点で、Bitcoinネットワークは +000000000000004c296e6376db3a241271f43fd3f5de7ba18986e517a243baa7+ より小さいヘッダハッシュを持つブロックが試行されています。見て分かるように、ハッシュの最初に多くの0があります。これは、許容されるハッシュ範囲がとても小さくなっているということを意味し、よって有効なハッシュを見つけることがより難しくなっているということになります。次のブロックをBitcoinネットワークが発見するために平均的に秒間15京回(150 quadrillion hash)以上のハッシュ計算が必要になっています。これは不可能なことに見えますが、幸運なことにBitcoinネットワークは秒間100ペタハッシュ(PH/sec、1ペタは1000兆)の演算処理能力を提供しており、これにより平均的に約10分間ごとにブロックを見つけることができます。(((range="endofrange", startref="ix_ch08-asciidoc16")))(((range="endofrange", startref="ix_ch08-asciidoc15")))

[[difficulty_bits]]
==== Difficulty Representation
==== Difficulty表現

((("difficulty target")))((("mining","difficulty bits")))((("mining","difficulty targets")))In <<block277316>>, we saw that the block contains the difficulty target, in a notation called "difficulty bits" or just "bits," which in block 277,316 has the value of +0x1903a30c+. This notation expresses the difficulty target as a coefficient/exponent format, with the first two hexadecimal digits for the exponent and the next six hex digits as the coefficient. In this block, therefore, the exponent is +0x19+ and the coefficient is +0x03a30c+.

((("difficulty target")))((("mining","difficulty bits")))((("mining","difficulty targets")))<<block277316>>では、ブロックが"difficulty bits"または単に"bits"と呼ばれる記法で書かれたdifficulty targetを含んでいることを確認しました。ブロック277,316では+0x1903a30c+という値がdifficulty bitsに入っています。この記法はdifficulty targetを係数部/指数部形式で表すもので、最初の２桁の１６進数が指数部、次の６桁の１６進数が係数です。このブロックでは、指数部が +0x19+ 、係数が +0x03a30c+ となっています。

The formula to calculate the difficulty target from this representation is:

この記法からdifficulty targetを計算する数式は以下になります。

----
target = coefficient * 2^(8 * (exponent – 3))
----

Using that formula, and the difficulty bits value 0x1903a30c, we get:

この数式を使うとdifficulty bits 0x1903a30cは、

----
target = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ 

=> target = 0x03a30c * 2^(0x08 * 0x16)^

=> target = 0x03a30c * 2^0xB0^
----

which in decimal is:

１０進数で表現すると、

----
=> target = 238,348 * 2^176^

=> target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328
----

switching back to hexadecimal:

これを１６進数で表すと以下になります。

----
=> target = 0x0000000000000003A30C00000000000000000000000000000000000000000000
----

This means that a valid block for height 277,316 is one that has a block header hash that is less than the target. In binary that number would have more than the first 60 bits set to zero. With this level of difficulty, a single miner processing 1 trillion hashes per second (1 tera-hash per second or 1 TH/sec) would only find a solution once every 8,496 blocks or once every 59 days, on average. 

これは、ブロック277,316を有効にするにはこのtargetよりも小さいブロックヘッダハッシュを持たなければならないということを意味します。２進数で言うと、この数字は最初の60bit以上が0になっています。このレベルのdifficultyは、秒間10億個のハッシュ(秒間1テラハッシュ、または1TH/sec)を生成できるマイナーだと平均的に8,496ブロックに１回解が見つかるだけ、または59日に１回解が見つかるだけということになります。

[[difficulty_target]]
==== Difficulty Target and Retargeting
==== Difficulty TargetとRetargeting

((("difficulty target","retargeting", id="ix_ch08-asciidoc17", range="startofrange")))As we saw, the target determines the difficulty and therefore affects how long it takes to find a solution to the proof-of-work algorithm. This leads to the obvious questions: Why is the difficulty adjustable, who adjusts it, and how?

((("difficulty target","retargeting", id="ix_ch08-asciidoc17", range="startofrange")))これまでに見てきたように、targetはdifficultyを決定し、よってproof-of-workアルゴリズムへの解を見つけることにかかる時間がどれくらい長くなるかに影響します。ここから自然な疑問点が出てきます。"なぜdifficultyは調整可能なのか、誰が調整しているのか、どのように調整しているのか"

((("difficulty retargeting")))((("difficulty target","block generation rate and")))Bitcoin's blocks are generated every 10 minutes, on average. This is bitcoin's heartbeat and underpins the frequency of currency issuance and the speed of transaction settlement. It has to remain constant not just over the short term, but over a period of many decades. Over this time, it is expected that computer power will continue to increase at a rapid pace. Furthermore, the number of participants in mining and the computers they use will also constantly change. To keep the block generation time at 10 minutes, the difficulty of mining must be adjusted to account for these changes. In fact, difficulty is a dynamic parameter that will be periodically adjusted to meet a 10-minute block target. In simple terms, the difficulty target is set to whatever mining power will result in a 10-minute block interval. 

((("difficulty retargeting")))((("difficulty target","block generation rate and")))Bitcoinのブロックは平均的に10分毎に生成されています。これはBitcoinの鼓動であり、通貨発行頻度の土台であり、トランザクションが安定にいたる時間です。これは短すぎず、また数十年ほど長すぎず一定に保たれる必要があります。時間とともに、コンピュータの処理速度は急速に速くなっていくと予想され、またマイニングに参加する人とコンピュータの数も変わっていきます。ブロックの生成時間を10分に保つためには、difficultyはこれらの変化に合わせて調整されなければいけません。事実、difficultyは動的に変わるパラメータであり、10分毎のブロック生成を満たすためにたびたび調整されてきました。簡単に言うと、difficulty targetはどんなにマイニング速度が変わっても10分毎にブロック生成が起こるように設定されているのです。

How, then, is such an adjustment made in a completely decentralized network? Difficulty retargeting occurs automatically and on every full node independently. Every 2,016 blocks, all nodes retarget the proof-of-work difficulty. The equation for retargeting difficulty measures the time it took to find the last 2,016 blocks and compares that to the expected time of 20,160 minutes (two weeks based upon a desired 10-minute block time). The ratio between the actual timespan and desired timespan is calculated and a corresponding adjustment (up or down) is made to the difficulty. In simple terms: If the network is finding blocks faster than every 10 minutes, the difficulty increases. If block discovery is slower than expected, the difficulty decreases. 

完全な分散ネットワークでどのようにしてこの調整が行われているのでしょうか。difficultyのretargetingは自動的に全てのfull nodeで行われます。2,016ブロック毎に全てのBitcoinノードはproof-of-workのdifficultyをretargetします。retargetingを行う時は、最後の2,016ブロックが生成されたのにかかった時間を測定し、予想される時間20,160分(10分間でブロック生成が起きたとするとこれは約2週間に相当)と比較します。実際にかかった時間と求められる時間との比が計算され、適した調整(difficultyを上げるまたは下げる)が行われます。簡単に言って、もしBitcoinネットワークが10分毎よりも速くブロックを見つけていればdifficultyは上がります。もしブロックの発見が予想よりも遅ければ、difficultyは下がります。

The equation can be summarized as:

この関係式は以下のようにまとめられます。

----
New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)
----

<<retarget_difficulty_code>> shows the code used in the Bitcoin Core client.

<<retarget_difficulty_code>>はBitcoin Coreクライアントのなかで使われているコードを示しています。

[[retarget_difficulty_code]]
.Retargeting the proof-of-work difficulty—GetNextWorkRequired() in pow.cpp, line 43
.proof-of-workのdifficulty retargeting(Bitcoin Coreクライアントのpow.cpp 43行目にあるGetNextWorkRequired())
====
[source,cpp]
----

// Go back by what we want to be 14 days worth of blocks
const CBlockIndex* pindexFirst = pindexLast;
for (int i = 0; pindexFirst && i < Params().Interval()-1; i++)
    pindexFirst = pindexFirst->pprev;
assert(pindexFirst);

// Limit adjustment step
int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();
LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
if (nActualTimespan < Params().TargetTimespan()/4)
    nActualTimespan = Params().TargetTimespan()/4;
if (nActualTimespan > Params().TargetTimespan()*4)
    nActualTimespan = Params().TargetTimespan()*4;

// Retarget
uint256 bnNew;
uint256 bnOld;
bnNew.SetCompact(pindexLast->nBits);
bnOld = bnNew;
bnNew *= nActualTimespan;
bnNew /= Params().TargetTimespan();

if (bnNew > Params().ProofOfWorkLimit())
    bnNew = Params().ProofOfWorkLimit();

----
====

[NOTE]
====
While the difficulty calibration happens every 2,016 blocks, because of an off-by-one error in the original Bitcoin Core client it is based on the total time of the previous 2,015 blocks (not 2,016 as it should be), resulting in a retargeting bias towards higher difficulty by 0.05%.

difficultyの調整は2016ブロックに１回起きます。オリジナルのBitcoin Coreクライアントにあるoff-by-oneエラーのため、difficultyの調整は前の2015ブロックの総時間に基づいています(本来すべき2016ブロックの総時間ではなく)。この結果、difficultyは0.05%だけ高くなるようなretargetingバイアスが生じています。
====


The parameters Interval (2,016 blocks) and TargetTimespan (two weeks as 1,209,600 seconds) are defined in _chainparams.cpp_.

Interval(2,016ブロック)とTargetTimespan(2週間、1,209,600秒)は _chainparams.cpp_ に定義されています。

To avoid extreme volatility in the difficulty, the retargeting adjustment must be less than a factor of four (4) per cycle. If the required difficulty adjustment is greater than a factor of four, it will be adjusted by the maximum and not more. Any further adjustment will be accomplished in the next retargeting period because the imbalance will persist through the next 2,016 blocks. Therefore, large discrepancies between hashing power and difficulty might take several 2,016 block cycles to balance out. 

difficultyが極端に動きすぎないように、retargetingは調整ごとに４倍または1/4以内になるようになっています。つまり、もし必要なdifficultyの調整が4倍よりも大きいまたは1/4よりも小さい場合は、最大でも4倍、最小でも1/4になりそれを超えたものにはなりません。不均衡が次の2,016ブロックの間続いてしまうため、さらなる調整は次のretargetingのときに行われます。このため、ハッシュ生成速度とdifficultyの大きな食い違いは数回のretargetingを経て均衡するようになると思われます。

[TIP]
====
The difficulty of finding a bitcoin block is approximately '10 minutes of processing' for the entire network, based on the time it took to find the previous 2,016 blocks, adjusted every 2,016 blocks.
====

Note that the target difficulty is independent of the number of transactions or the value of transactions. This means that the amount of hashing power and therefore electricity expended to secure bitcoin is also entirely independent of the number of transactions. Bitcoin can scale up, achieve broader adoption, and remain secure without any increase in hashing power from today's level. The increase in hashing power represents market forces as new miners enter the market to compete for the reward. As long as enough hashing power is under the control of miners acting honestly in pursuit of the reward, it is enough to prevent "takeover" attacks and, therefore, it is enough to secure bitcoin. 

difficulty targetはトランザクションの数やトランザクションに含まれる資金には依存しないことを注意しておきます。これは、ハッシュ生成速度、つまりはBitcoinをセキュアに保つために費やされる電気代もまたトランザクションの数に全く依存しないということです。これにより、今日のハッシュ生成速度が増加しなかったとしても、Bitcoinはより広く採用されスケールアップすることができ、セキュアに保たれるということです。ハッシュ生成速度が大きくなるということは、マーケットに参入した新しいマイナーに厳しい報酬競争を強いることになります。十分なハッシュ生成速度が率直に報酬を狙うマイナーによってコントロールされている限り、"買収(takeover)"攻撃を防ぎBitcoinを安全に保つことができるのです。

((("difficulty target","electricity cost and")))((("electricity cost and target difficulty")))The target difficulty is closely related to the cost of electricity and the exchange rate of bitcoin vis-a-vis the currency used to pay for electricity. High-performance mining systems are about as efficient as possible with the current generation of silicon fabrication, converting electricity into hashing computation at the highest rate possible. The primary influence on the mining market is the price of one kilowatt-hour in bitcoin, because that determines the profitability of mining and therefore the incentives to enter or exit the mining market.(((range="endofrange", startref="ix_ch08-asciidoc17")))(((range="endofrange", startref="ix_ch08-asciidoc14")))(((range="endofrange", startref="ix_ch08-asciidoc13")))

((("difficulty target","electricity cost and")))((("electricity cost and target difficulty")))difficulty targetは電気代およびbitcoinと電気代を払うための通貨の交換レートに密接に関係しています。ハイパフォーマンスなマイニングシステムは最近のシリコン製造技術を用いて可能な限り効率化されており、電気をできる限り最高のレートでハッシュ生成計算に転換しています。マイニングマーケット上の主要な影響は1KW/hあたり何bitcoinかかるかです。なぜなら、これがマイニングの収益を決定しマイニングマーケットに参入するか撤退するかを決めるからです。(((range="endofrange", startref="ix_ch08-asciidoc17")))(((range="endofrange", startref="ix_ch08-asciidoc14")))(((range="endofrange", startref="ix_ch08-asciidoc13")))

=== Successfully Mining the Block
=== うまくいったブロックの採掘

((("consensus","mining blocks successfully")))As we saw earlier, Jing's node has constructed a candidate block and prepared it for mining. Jing has several hardware mining rigs with((("Application Specific Integrated Circuit (ASIC)","mining with"))) application-specific integrated circuits, where hundreds of thousands of integrated circuits run the SHA256 algorithm in parallel at incredible speeds. These specialized machines are connected to his mining node over USB. Next, the mining node running on Jing's desktop transmits the block header to his mining hardware, which starts testing trillions of nonces per second. 

((("consensus","mining blocks successfully")))前に見たように、ジンのBitcoinノードは候補ブロックを構築しマイニングの準備が整いました。ジンは((("Application Specific Integrated Circuit (ASIC)","mining with"))) ASIC(application-specific integrated circuits)で作られた幾つかのハードウェアのmining rigsを持っています。ASICは数十万個の集積回路で並行してSHA256アルゴリズムを計算するもので、信じられないほどのハッシュ生成速度を出します。これらの特別なマシンは彼のマイニングノードにUSBを通して接続されています。次に、ジンのデスクトップで動いているマイニングノードはブロックヘッダをマイニングハードウェアに送信し、ここから秒間10億回ものnonceの試行が始まります。

Almost 11 minutes after starting to mine block 277,316, one of the hardware mining machines finds a solution and sends it back to the mining node. When inserted into the block header, the nonce 4,215,469,401 produces a block hash of:

ブロック277,316の採掘を初めてから11分後くらいに１つのハードウェアマイニングマシンが解を見つけ、マイニングノードにそれを送り返しました。ブロックヘッダにそれを入れてみると、nonce 4,215,469,401が以下のブロックハッシュを生成しました。

----
0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569
----

which is less than the target:

これは以下のtargetよりも小さいものです。

----
0000000000000003A30C00000000000000000000000000000000000000000000
----

Immediately, Jing's mining node transmits the block to all its peers. They receive, validate, and then propagate the new block. As the block ripples out across the network, each node adds it to its own copy of the blockchain, extending it to a new height of 277,316 blocks. As mining nodes receive and validate the block, they abandon their efforts to find a block at the same height and immediately start computing the next block in the chain. 

すぐに、ジンのマイニングノードはブロックを全てのピアに送信しました。彼らはこのブロックを受け取り、検証し、この新しいブロックを次に伝搬します。このブロックがBitcoinネットワークを波紋のように伝搬していくときに、それぞれのBitcoinノードはこのブロックを自身のブロックチェーンのコピーに追加しブロック高を277,316に増やします。マイニングノードがこのブロックを受け取り検証したとき、マイニングノードは同じブロック高のブロックの発見を諦め、すぐに次のブロックの計算を始めます。

In the next section, we'll look at the process each node uses to validate a block and select the longest chain, creating the consensus that forms the decentralized blockchain.

次の節では、ブロックを検証し最も長いブロックチェーンを選び分散されたブロックチェーンで形成される合意形成を作るプロセスを見ていきます。

=== Validating a New Block
=== 新しいブロックの検証

((("blocks","validating new")))((("consensus","validating new blocks")))((("mining","validating new blocks")))The third step in bitcoin's consensus mechanism is independent validation of each new block by every node on the network. As the newly solved block moves across the network, each node performs a series of tests to validate it before propagating it to its peers. This ensures that only valid blocks are propagated on the network. The independent validation also ensures that miners who act honestly get their blocks incorporated in the blockchain, thus earning the reward. Those miners who act dishonestly have their blocks rejected and not only lose the reward, but also waste the effort expended to find a proof-of-work solution, thus incurring the cost of electricity without compensation. 

((("blocks","validating new")))((("consensus","validating new blocks")))((("mining","validating new blocks")))Bitcoinの合意形成メカニズムの３つ目のステップは、独立した全てのBitcoinノードによる新しいブロック検証です。新しく解決されたブロックがBitcoinネットワークを移動する時、それぞれのBitcoinノードはブロックをピアに送信する前に有効なブロックかどうかを確認するテストを実行します。これは、有効なブロックだけがBitcoinネットワークを伝搬するようにするためです。また、独立した検証は、信頼できるマイナーがそれらのブロックをブロックチェーンに合体させ報酬を稼ぐことを保証しています。信頼できないマイナーが作ったブロックがあった場合他のBitcoinノードから拒否されてしまうため報酬が得られないだけでなくproof-of-workで費やした努力を無駄にし何の埋め合わせもなく電気代を負うことになります。

When a node receives a new block, it will validate the block by checking it against a long list of criteria that must all be met; otherwise, the block is rejected. These criteria can be seen in the Bitcoin Core client in the functions((("CheckBlock function (Bitcoin Core client)")))((("CheckBlockHeader function (Bitcoin Core client)"))) +CheckBlock+ and +CheckBlockHeader+ and include:

Bitcoinノードが新しいブロックを受け取った時、全てのブロックが満たすべき長い条件リストに照らし合わせてチェックされ検証されます。もし条件を満たさなければブロックは拒否されます。これらの条件はBitcoin Coreクライアントの中の ((("CheckBlock function (Bitcoin Core client)")))((("CheckBlockHeader function (Bitcoin Core client)"))) +CheckBlock+ 関数や +CheckBlockHeader+ 関数で確認でき、以下の条件を含んでいます。

* The block data structure is syntactically valid
* The block header hash is less than the target difficulty (enforces the proof of work)
* The block timestamp is less than two hours in the future (allowing for time errors)
* The block size is within acceptable limits
* The first transaction (and only the first) is a coinbase generation transaction
* All transactions within the block are valid using the transaction checklist discussed in <<tx_verification>>

* ブロックのデータ構造が構文的に有効であること
* ブロックヘッダハッシュがdifficulty targetよりも小さいこと(proof of workを強制する)
* ブロックのタイムスタンプが２時間後よりも小さいこと(時刻エラーのある程度の許容)
* ブロックサイズが受け入れられる制限内であること
* 最初のトランザクション(そして、最初のトランザクションのみ)がcoinbase generationトランザクションであること
* ブロックに含まれる全てのトランザクションが<<tx_verification>>で説明したチェックリストを満たすこと

The independent validation of each new block by every node on the network ensures that the miners can't cheat. In previous sections we saw how the miners get to write a transaction that awards them the new bitcoins created within the block and claim the transaction fees. Why don't miners write themselves a transaction for a thousand bitcoin instead of the correct reward? Because every node validates blocks according to the same rules. An invalid coinbase transaction would make the entire block invalid, which would result in the block being rejected and, therefore, that transaction would never become part of the ledger. The miners have to construct a perfect block, based on the shared rules that all nodes follow, and mine it with a correct solution to the proof of work. To do so, they expend a lot of electricity in mining, and if they cheat, all the electricity and effort is wasted. This is why independent validation is a key component of decentralized consensus.

全てのBitcoinノードによって独立に行われる検証によって、マイナーがごまかして不正をできないようになっています。前の節で、どのようにマイナーが新しいbitcoinをマイナーに与えるトランザクションをブロック内に書き、トランザクション手数料を要求するのかを確認しました。なぜマイナーは正しい報酬の代わりに彼ら自身で数千bitcoinを自身に与えるトランザクションを書かないのでしょうか。これは、全てのBitcoinノードが同じルールに従ってブロックを検証しているからです。不正なcoinbaseトランザクションがあった場合ブロック全体が無効になってしまい、結局このブロックは拒否されブロックチェーンの一部にはならないことになってしまいます。マイナーは全てのBitcoinノードが従っている共有ルールに基づく完全なブロックを構築する必要があり、しかもproof of workの正しい解を伴った形で採掘しなければいけません。これを行うために、マイニングに多大な電気を使います。もし彼らが不正を行えば、全ての電気と努力は無駄になってしまいます。これが独立した検証が分散された合意形成のキーポイントである理由なのです。

=== Assembling and Selecting Chains of Blocks
=== ブロックのチェーン組み立てと選択

((("blockchains","assembling", id="ix_ch08-asciidoc18", range="startofrange")))((("blockchains","selecting", id="ix_ch08-asciidoc19", range="startofrange")))((("blocks","assembling chains of", id="ix_ch08-asciidoc20", range="startofrange")))((("blocks","selecting chains of", id="ix_ch08-asciidoc21", range="startofrange")))The final step in bitcoin's decentralized consensus mechanism is the assembly of blocks into chains and the selection of the chain with the most proof of work. Once a node has validated a new block, it will then attempt to assemble a chain by connecting the block to the existing blockchain. 

((("blockchains","assembling", id="ix_ch08-asciidoc18", range="startofrange")))((("blockchains","selecting", id="ix_ch08-asciidoc19", range="startofrange")))((("blocks","assembling chains of", id="ix_ch08-asciidoc20", range="startofrange")))((("blocks","selecting chains of", id="ix_ch08-asciidoc21", range="startofrange")))Bitcoinの分散された合意形成メカニズムの最後のステップは、ブロックをチェーンに組み込むことと、最も多くのproof of workを含むチェーンの選択です。一度Bitcoinノードが新しいブロックが有効であると確認すると、このブロックを持っているブロックチェーンに結びつけチェーンを形成しようとします。

((("nodes","sets of blocks maintained by")))Nodes maintain three sets of blocks: those connected to the main blockchain, those that form branches off the main blockchain((("secondary chains"))) (secondary chains), and finally, blocks that do not have a known parent in the known chains((("orphan blocks"))) (orphans). Invalid blocks are rejected as soon as any one of the validation criteria fails and are therefore not included in any chain. 

((("nodes","sets of blocks maintained by")))Bitcoinノードは３種類のブロックセットを持っています。１つはメインのブロックチェーンにひも付けられたブロック。１つはメインのブロックチェーンから枝分かれしたブロック((("secondary chains"))) (セカンダリーチェーン)。もう1つは知っているチェーンに親がないブロック((("orphan blocks"))) (orphans)です。無効なブロックは検証条件を満たさなかった時点ですぐに拒否されるためどのチェーンにも含まれません。

((("blockchains","main")))((("main blockchain")))The "main chain" at any time is whichever chain of blocks has the most cumulative difficulty associated with it. Under most circumstances this is also the chain with the most blocks in it, unless there are two equal-length chains and one has more proof of work. ((("sibling chains (to main chain)")))The main chain will also have branches with blocks that are "siblings" to the blocks on the main chain. These blocks are valid but not part of the main chain. They are kept for future reference, in case one of those chains is extended to exceed the main chain in difficulty. In the next section (<<forks>>), we will see how secondary chains occur as a result of an almost simultaneous mining of blocks at the same height. 

((("blockchains","main")))((("main blockchain")))"メインチェーン"はどんなときでも、チェーンにひもづいた累積difficultyを最も多く持っているチェーンになります。同じ長さのチェーンがあり片方の方がより多くのproof of workを持っている場合を除き、ほとんどの状況下でこれは最も多くのブロックを持っているチェーンでもあります。((("sibling chains (to main chain)")))メインチェーンは、メインチェーンのブロックに繋がった"sibling"ブロックのブランチを持つこともあります。これらのブロックは有効ですがメインチェーンの一部ではありません。これらがほじされているのは、将来これらのチェーンのうちの１つがメインチェーンをdifficultyで上回り拡張された場合に参照できるようにするためです。次の節(<<forks>>)では、ほとんど同時に同じブロック高を持つブロックが採掘された結果としてどのようにセカンダリーチェーンが生じるかを説明します。

When a new block is received, a node will try to slot it into the existing blockchain. The node will look at the block's "previous block hash" field, which is the reference to the new block's parent. Then, the node will attempt to find that parent in the existing blockchain. Most of the time, the parent will be the "tip" of the main chain, meaning this new block extends the main chain. For example, the new block 277,316 has a reference to the hash of its parent block 277,315. Most nodes that receive 277,316 will already have block 277,315 as the tip of their main chain and will therefore link the new block and extend that chain. 

新しいブロックを受け取った時、Bitcoinノードはすでにあるブロックチェーンにブロックを入れようとします。このBitcoinノードはブロックの"previous block hash"フィールドを確認します。previous block hashフィールドは新しいブロックの親を参照しています。このBitcoinノードは対応した親を探そうとします。ほとんどの場合、親はメインチェーンの"先頭"にあり、これが意味することはメインチェーンが新しいブロックで拡張されるということです。例えば、新しいブロック 277,316 が親ブロック 277,315 のブロックハッシュを参照しているような場合です。ブロック 277,316 を受け取ったほとんどのBitcoinノードはすでにメインチェーンの戦闘ブロックとしてブロック 277,315 を持っており、よって新しいブロックを連結しメインチェーンを拡張することになるのです。

Sometimes, as we will see in <<forks>>, the new block extends a chain that is not the main chain. In that case, the node will attach the new block to the secondary chain it extends and then compare the difficulty of the secondary chain to the main chain. If the secondary chain has more cumulative difficulty than the main chain, the node will _reconverge_ on the secondary chain, meaning it will select the secondary chain as its new main chain, making the old main chain a secondary chain. If the node is a miner, it will now construct a block extending this new, longer, chain.

<<forks>>で見るように、時々新しいブロックがメインチェーン以外のチェーンを拡張するときがあります。この場合、Bitcoinノードは新しいブロックをセカンダリーチェーンにくっつけ、セカンダリーチェーンとメインチェーンのdifficultyを比較します。もしセカンダリーチェーンの累積difficultyがメインチェーンの累積difficultyを上回っていれば、Bitcoinノードはセカンダリーチェーンに _中心を移し_ ます。このことは、セカンダリーチェーンを新しいメインチェーンとして選び、古いメインチェーンをセカンダリーチェーンにするということを意味しています。もしこのBitcoinノードがマイナーであれば、この新しくより長いチェーンを拡張していくブロックを構築することになります。

If a valid block is received and no parent is found in the existing chains, that block is considered an "orphan." Orphan blocks are saved in the orphan block pool where they will stay until their parent is received. Once the parent is received and linked into the existing chains, the orphan can be pulled out of the orphan pool and linked to the parent, making it part of a chain. Orphan blocks usually occur when two blocks that were mined within a short time of each other are received in reverse order (child before parent). 

もし有効なブロックを受け取っても存在するチェーンに親が見つからなかった場合、このブロックは"orphan"とみなされます。orphanブロックは、これらの親を受け取るまでorphanブロックプールに保持されます。この親を受け取り存在するチェーンに連結されると、orphanブロックはorphanプールからから取り出されてこの親に連結され、チェーンの一部となります。orphanブロックは、ほぼ同時に採掘された２つのブロックを逆順(親より前に子)で受け取ったときに通常生じるものです。

By selecting the greatest-difficulty chain, all nodes eventually achieve network-wide consensus. Temporary discrepancies between chains are resolved eventually as more proof of work is added, extending one of the possible chains. Mining nodes "vote" with their mining power by choosing which chain to extend by mining the next block. When they mine a new block and extend the chain, the new block itself represents their vote. 

最も大きいdifficultyを持つチェーンを選ぶことで、全てのBitcoinノードは結局ネットワーク全体の合意形成に到達し、一時的なチェーン同士の不一致はより多くのproof of workが追加されるにつれて結局は解決されます。マイニングノードはどのチェーンが拡張されていくかを選ぶことでマイニングパワーを(チェーンに)"投票"していることになります。このマイニングノードが新しいブロックを採掘しチェーンを拡張するとき、新しいブロックそのものがマイニングノードの投票を表すのです。

In the next section we will look at how discrepancies between competing chains (forks) are resolved by the independent selection of the longest difficulty chain.

次の節では、最も長いdifficultyチェーンを独立に選ぶことでどのようにしてチェーン同士(フォーク)の競争による不一致を解決しているかを見ていきます。

[[forks]]
==== Blockchain Forks
==== Blockchainフォーク

((("blockchains","forks", id="ix_ch08-asciidoc22", range="startofrange")))Because the blockchain is a decentralized data structure, different copies of it are not always consistent. Blocks might arrive at different nodes at different times, causing the nodes to have different perspectives of the blockchain. To resolve this, each node always selects and attempts to extend the chain of blocks that represents the most proof of work, also known as the longest chain or greatest cumulative difficulty chain. By summing the difficulty recorded in each block in a chain, a node can calculate the total amount of proof of work that has been expended to create that chain. As long as all nodes select the longest cumulative difficulty chain, the global bitcoin network eventually converges to a consistent state. Forks occur as temporary inconsistencies between versions of the blockchain, which are resolved by eventual reconvergence as more blocks are added to one of the forks.

((("blockchains","forks", id="ix_ch08-asciidoc22", range="startofrange")))ブロックチェーンは分散化されているため、異なったコピーは常に一致しているわけではありません。ブロックが異なったBitcoinノードに別々のタイミングで到着するかもしれず、ノードごとにブロックチェーンの状態は変わってしまうのです。これを解決するために、それぞれのBitcoinノードは常に最も多くのproof of workを持っているブロックのチェーンを選び拡張しようとしています。このブロックのチェーンは最長チェーンまたは最大累積difficultyチェーンとも呼ばれています。チェーンの各ブロックに記録されているdifficultyを足し合わせることで、Bitcoinノードはこのチェーンを作るために使われたproof of workの総量を計算できます。全てのBitcoinノードが最大累積difficultyチェーンを選んでいる限り、グローバルなBitcoinネットワークは結果的に矛盾のない状態に収束します。フォークはブロックチェーンの異なるバージョン間での一時的な不一致によって生じますが、多くのブロックがフォークのうちの一つに追加されることで結果的に不一致が解消されるようになります。

In the next few diagrams, we follow the progress of a "fork" event across the network. The diagram is a simplified representation of bitcoin as a global network. In reality, the bitcoin network's topology is not organized geographically. Rather, it forms a mesh network of interconnected nodes, which might be located very far from each other geographically. The representation of a geographic topology is a simplification used for the purposes of illustrating a fork. In the real bitcoin network, the "distance" between nodes is measured in "hops" from node to node, not on their physical location. For illustration purposes, different blocks are shown as different colors, spreading across the network and coloring the connections they traverse.

次のいくつかの図を使って、Bitcoinネットワークを通してどのように"フォーク"が生じるのかを見ていきます。これらの図はグローバルに広がるBitcoinの簡略した表現です。実際には、Bitcoinネットワークのトポロジーは地理的に組織されているわけではなく、むしろBitcoinノード間のメッシュネットワークとして構成されており、ネットワーク的に近くても地理的にはとても離れているかもしれません。地理的トポロジーの表現はフォークを図解する目的に対して用いられている簡略化なのです。実際のBitcoinネットワークではBitcoinノード間の"距離"をノードからノードへの"ホップ数"によって測っており、物理的な距離ではないです。図解の目的のため、異なったブロックは異なった色で表され、異なったブロックがBitcoinネットワークを通して広がり通過していったコネクションはブロックの色と同じ色に塗られています。

In the first diagram (<<fork1>>), the network has a unified perspective of the blockchain, with the blue block as the tip of the main chain. 

最初の図(<<fork1>>)では、Bitcoinネットワークが同じブロックチェーンを持っている状態を表し、青色で表されたブロックはメインチェーンの先端ブロックを表します。

[[fork1]]
.Visualization of a blockchain fork event—before the fork
.ブロックチェーンのフォークが生じる過程の可視化 - フォークが生じる前
image::images/msbt_0802.png["globalfork1"]

A "fork" occurs whenever there are two candidate blocks competing to form the longest blockchain. This occurs under normal conditions whenever two miners solve the proof-of-work algorithm within a short period of time from each other. As both miners discover a solution for their respective candidate blocks, they immediately broadcast their own "winning" block to their immediate neighbors who begin propagating the block across the network. Each node that receives a valid block will incorporate it into its blockchain, extending the blockchain by one block. If that node later sees another candidate block extending the same parent, it connects the second candidate on a secondary chain. As a result, some nodes will "see" one candidate block first, while other nodes will see the other candidate block and two competing versions of the blockchain will emerge. 

"フォーク"は競争している２つの候補ブロックがあればいつでも生じる可能性があり、通常2人のマイナーが互いにほぼ同時刻にproof-of-workの解を見つけると起こります。両方のマイナーがそれぞれの候補ブロックに対する解を見つけると、彼らは直ちに自身の"勝ち取った"ブロックを近接ノードにブロードキャストし、近接ノードはこのブロックを次々にBitcoinネットワークに伝搬させていきます。有効なブロックを受け取ったBitcoinノードはこのブロックをローカルのブロックチェーンに追加し、１ブロックだけブロックチェーンを拡張します。もしこのBitcoinノードが同じ親を持つ別の候補ブロックをのちに見つけた場合は、セカンダリーチェーンに後から来た候補ブロックをつなげます。結果として、いくつかのBitcoinノードは最初の候補ブロックを"見て"、他のBitcoinノードは別の候補ブロックを見ることになるため、互いにぶつかる２つのブロックチェーンが生じることになるのです。

In <<fork2>>, we see two miners who mine two different blocks almost simultaneously. Both of these blocks are children of the blue block, meant to extend the chain by building on top of the blue block. To help us track it, one is visualized as a red block originating from Canada, and the other is marked as a green block originating from Australia. 

<<fork2>>では、ほぼ同時に異なったブロックを採掘した２人のマイナーを表しています。これらのブロックは両方とも青色のブロックの子供で、青色のブロックの上に追加しチェーンを拡張します。ブロックを追跡しやすくするために、カナダで作られたブロックは赤色、オーストラリアで作られたブロックは緑色にしてあります。

Let's assume, for example, that a miner in Canada finds a proof-of-work solution for a block "red" that extends the blockchain, building on top of the parent block "blue." Almost simultaneously, an Australian miner who was also extending block "blue" finds a solution for block "green," his candidate block. Now, there are two possible blocks, one we call "red," originating in Canada, and one we call "green," originating in Australia. Both blocks are valid, both blocks contain a valid solution to the proof of work, and both blocks extend the same parent. Both blocks likely contain most of the same transactions, with only perhaps a few differences in the order of transactions. 

例として、カナダのマイナーが"赤色"のブロックに対するproof-of-workの解を見つけたとします。ほぼ同時に、オーストラリアのマイナーは"緑色"のブロックに対する解を見つけました。この時点で、２つの可能なブロックがあり、カナダで作られた方を"赤色"、オーストラリアで作られた方を"緑色"と呼ぶことにします。両方のブロックが有効であり、proof-of-workに対する有効な解を持っており、また同じ親ブロックを拡張するブロックとなっています。両方のブロックがおそらく大方同じトランザクションを持っており、違いとしてはトランザクションの順番くらいです。

[[fork2]]
.Visualization of a blockchain fork event: two blocks found simultaneously 
.ブロックチェーンのフォークが生じる過程の可視化 - ２つのブロックが同時に見つかった
image::images/msbt_0803.png["globalfork2"]

As the two blocks propagate, some nodes receive block "red" first and some receive block "green" first. As shown in <<fork3>>, the network splits into two different perspectives of the blockchain, one side topped with a red block, the other with a green block. 

２つのブロックが伝搬するときに、いくつかのBitcoinノードは"赤色"のブロックを最初に受け取り、いくつかのBitcoinノードは"緑色"のブロックを最初に受け取ります。<<fork3>>に示しているように、Bitcoinネットワークは２つのブロックチェーンに分かれてしまい、片側は赤色のブロックが先端にあり、もう１つは緑色のブロックが先端にあるようになっています。

[[fork3]]
.Visualization of a blockchain fork event: two blocks propagate, splitting the network
.ブロックチェーンのフォークが生じる過程の可視化 - ２つのブロックが伝搬しBitcoinネットワークを２つに分割している
image::images/msbt_0804.png["globalfork3"]

From that moment, the bitcoin network nodes closest (topologically, not geographically) to the Canadian node will hear about block "red" first and will create a new greatest-cumulative-difficulty blockchain with "red" as the last block in the chain (e.g., blue-red), ignoring the candidate block "green" that arrives a bit later. Meanwhile, nodes closer to the Australian node will take that block as the winner and extend the blockchain with "green" as the last block (e.g., blue-green), ignoring "red" when it arrives a few seconds later. Any miners that saw "red" first will immediately build candidate blocks that reference "red" as the parent and start trying to solve the proof of work for these candidate blocks. The miners that accepted "green" instead will start building on top of "green" and extending that chain. 

その瞬間から、カナダのBitcoinノードに(地理的ではなくトポロジー的に)最も近いBitcoinノードは最初に"赤色"のブロックを受け取り、ブロックチェーンの最新のブロックとして"赤色"のブロックを持った新しいブロックチェーン(最も大きい累積difficultyを保持)を生成します(例えば、青-赤と繋がるブロックチェーン)。そして、少し後に届いた"緑色"の候補ブロックは無視することになります。一方、オーストラリアのBitcoinノードに近いBitcoinノードはオーストラリアのBitcoinノードが発見したブロックを受け取り、最新のブロックとして"緑色"のブロックを付ける形でブロックチェーンを拡張します(例えば、青-緑と繋がるブロックチェーン)。そして、数秒あとに届いた"赤色"のブロックは無視することになります。"赤色"のブロックを最初に見たどんなマイナーもすぐに親として"赤色"のブロックを参照する候補ブロックを構築し、これらの候補ブロックに対するproof of workを解き始めます。一方、"緑色"のブロックを受け入れたマイナーは"緑色"のブロックを頂点とするブロックチェーンを構築しこのブロックチェーンを拡張し始めます。

Forks are almost always resolved within one block. As part of the network's hashing power is dedicated to building on top of "red" as the parent, another part of the hashing power is focused on building on top of "green." Even if the hashing power is almost evenly split, it is likely that one set of miners will find a solution and propagate it before the other set of miners have found any solutions. Let's say, for example, that the miners building on top of "green" find a new block "pink" that extends the chain (e.g., blue-green-pink). They immediately propagate this new block and the entire network sees it as a valid solution as shown in <<fork4>>. 

フォークはほとんど常に１ブロック以内で解決されます。"赤色"のブロックを親とする  一部のBitcoinネットワークのハッシングパワーが"赤色"を親とするブロックチェーンの構築に投じられ、また別のBitcoinネットワークのハッシングパワーは"緑色"を親とするブロックチェーンの構築に投じられます。たとえハッシングパワーがほぼ均等に分割されてしまったとしても、あるマイナーが解を見つけ他の解を見つけたマイナーよりも前にそれを伝搬することになります。例えば、"緑色"のブロックを頂点に持つブロックチェーンを構築しているマイナーが"ピンク色"の新しいブロックを見つけてブロックチェーンを拡張する(例えば、青-緑-ピンクと繋がるブロックチェーン)と考えてみましょう。彼らはすぐにこの新しいブロックを伝搬し、<<fork4>>にあるようにBitcoinネットワーク全体がこのブロックを有効な解として確認するようになります。


[[fork4]]
.Visualization of a blockchain fork event: a new block extends one fork
.ブロックチェーンのフォークが生じる過程の可視化 - 新しいブロックが１つのフォークを拡張
image::images/msbt_0805.png["globalfork4"]

All nodes that had chosen "green" as the winner in the previous round will simply extend the chain one more block. The nodes that chose "red" as the winner, however, will now see two chains: blue-green-pink and blue-red. The chain blue-green-pink is now longer (more cumulative difficulty) than the chain blue-red. As a result, those nodes will set the chain blue-green-pink as main chain and change the blue-red chain to being a secondary chain, as shown in <<fork5>>. This is a chain reconvergence, because those nodes are forced to revise their view of the blockchain to incorporate the new evidence of a longer chain. Any miners working on extending the chain blue-red will now stop that work because their candidate block is an "orphan," as its parent "red" is no longer on the longest chain. The transactions within "red" are queued up again for processing in the next block, because that block is no longer in the main chain. The entire network re-converges on a single blockchain blue-green-pink, with "pink" as the last block in the chain. All miners immediately start working on candidate blocks that reference "pink" as their parent to extend the blue-green-pink chain.

前のラウンドで"緑色"のブロックの勝者として選んだ全てのBitcoinノードは、単にさらに１個ブロックをブロックチェーンに拡張していくだけです。しかし、"赤色"のブロックを勝者として選んだBitcoinノードは２つのブロックチェーンを見ることになります。青-緑-ピンクのブロックチェーンと、青-赤のブロックチェーンです。今では青-緑-ピンクのブロックチェーンは青-赤のブロックチェーンよりも長くなっています(より多くの累積difficultyを持っている)。<<fork5>>にあるように、結果として、これらのBitcoinノードは青-緑-ピンクのブロックチェーンをメインチェーンとして選び、青-赤のブロックチェーンをセカンダリーチェーンに変更します。これがブロックチェーンの再収縮で、より長いブロックチェーンの新しい情報を吸収するためにこれらのBitcoinノードがブロックチェーンの見方を変更することを強制されることで起こります。青-赤のブロックチェーンを拡張しようとしているどんなマイナーもこの拡張をやめます。というのは、彼らの候補ブロックの親がもはや最長ブロックチェーン上にはなく、この候補ブロックが"孤児"になってしまったためです。"赤色"ブロックの中にあったトランザクションは次のブロックの中で処理されるために再度マイニング対象になります。"赤色"ブロックはもはやメインチェーンにはないのです。Bitcoinネットワーク全体が青-緑-ピンクの1つのブロックチェーンに再収縮すると、"ピンク色"のブロックがブロックチェーンの最新ブロックとなります。青-緑-ピンクのブロックチェーンを拡張するために、全てのマイナーがすぐに"ピンク色"のブロックを親として参照している候補ブロックで作業を開始するのです。

[[fork5]]
.Visualization of a blockchain fork event: the network reconverges on a new longest chain
.ブロックチェーンのフォークが生じる過程の可視化 - Bitcoinネットワークが新しい最長ブロックチェーンに再収縮する
image::images/msbt_0806.png["globalfork5"]

It is theoretically possible for a fork to extend to two blocks, if two blocks are found almost simultaneously by miners on opposite "sides" of a previous fork. However, the chance of that happening is very low. Whereas a one-block fork might occur every week, a two-block fork is exceedingly rare.

もし２つのブロックがほぼ同時にフォークの"両方の端"で見つかれば、理論的にはフォークが２ブロック分拡張することは可能です。しかし、これが生じる可能性はとても低いです。１ブロックのフォークは毎週起こりえますが、２ブロックのフォークは極めて稀です。

Bitcoin's block interval of 10 minutes is a design compromise between fast confirmation times (settlement of transactions) and the probability of a fork. A faster block time would make transactions clear faster but lead to more frequent blockchain forks, whereas a slower block time would decrease the number of forks but make settlement slower.(((range="endofrange", startref="ix_ch08-asciidoc22")))(((range="endofrange", startref="ix_ch08-asciidoc21")))(((range="endofrange", startref="ix_ch08-asciidoc20")))(((range="endofrange", startref="ix_ch08-asciidoc19")))(((range="endofrange", startref="ix_ch08-asciidoc18"))) 

10分間というBitcoinのブロック間隔は、確認までにかかる時間(トランザクションの確定)とフォークが生じる確率の間の妥協点なのです。ブロック間隔をより短くすればトランザクションをより早く確定できますが、ブロックチェーンのフォークがより頻繁に起こってしまうことになります。一方、ブロック間隔を長くすればフォークの数は減りますが、トランザクションの確定に時間がかかることになります。(((range="endofrange", startref="ix_ch08-asciidoc22")))(((range="endofrange", startref="ix_ch08-asciidoc21")))(((range="endofrange", startref="ix_ch08-asciidoc20")))(((range="endofrange", startref="ix_ch08-asciidoc19")))(((range="endofrange", startref="ix_ch08-asciidoc18")))

=== Mining and the Hashing Race
=== マイニングとハッシュ化競争

((("hashing race", id="ix_ch08-asciidoc23", range="startofrange")))((("mining","hashing race and", id="ix_ch08-asciidoc24", range="startofrange")))((("processing power and hash racing", id="ix_ch08-asciidoc25", range="startofrange")))Bitcoin mining is an extremely competitive industry. The hashing power has increased exponentially every year of bitcoin's existence. Some years the growth has reflected a complete change of technology, such as in 2010 and 2011 when many miners switched from using CPU mining to((("graphical processing units (GPUs)","processing power of"))) GPU mining and((("field programmable gate array (FPGA)"))) field programmable gate array (FPGA) mining. In 2013 the introduction of((("Application Specific Integrated Circuit (ASIC)"))) ASIC mining lead to another giant leap in mining power, by placing the SHA256 function directly on silicon chips specialized for the purpose of mining. The first such chips could deliver more mining power in a single box than the entire bitcoin network in 2010.

((("hashing race", id="ix_ch08-asciidoc23", range="startofrange")))((("mining","hashing race and", id="ix_ch08-asciidoc24", range="startofrange")))((("processing power and hash racing", id="ix_ch08-asciidoc25", range="startofrange")))Bitcoinマイニングは極度に競争が激しい業界です。ハッシングパワーはBitcoinが現れてから毎年指数関数的に増加してきています。ここ数年の成長はテクノロジーの進化を反映しており、例えば2010年、2011年は多くのマイナーがCPUマイニングから ((("graphical processing units (GPUs)","processing power of"))) GPUマイニングと ((("field programmable gate array (FPGA)"))) フィールドプログラマブルゲートアレイ(FGPA)マイニングに変えたためです。2013年は ((("Application Specific Integrated Circuit (ASIC)"))) ASICマイニングが始まり、もう一つのマイニングパワーの急激な上昇が起こりました。ASICマイニングは、SHA256関数を直接にシリコンチップ上に記述することでマイニングに特化させた方法です。そのような最初のチップは、2010年時点のBitcoinネットワーク全体よりもマイニングパワーを提供することができました。????

The following list shows the total hashing power of the bitcoin network, over the first five years of operation:

以下のリストは最初の５年間におけるBitcoinネットワークの総ハッシングパワーを表しています。

2009:: 0.5 MH/sec–8 MH/sec (16&#x00D7; growth)
2010:: 8 MH/sec–116 GH/sec (14,500&#x00D7; growth)
2011:: 16 GH/sec–9 TH/sec (562&#x00D7; growth)
2012:: 9 TH/sec–23 TH/sec (2.5&#x00D7; growth)
2013:: 23 TH/sec–10 PH/sec (450&#x00D7; growth)
2014:: 10 PH/sec–150 PH/sec in August (15&#x00D7; growth)

In the chart in <<network_hashing_power>>, we see the bitcoin network's hashing power increase over the past two years. As you can see, the competition between miners and the growth of bitcoin has resulted in an exponential increase in the hashing power (total hashes per second across the network).

<<network_hashing_power>>のチャートにある通り、Bitcoinネットワークのハッシングパワーは過去２年間で増加しています。見てわかるように、マイナーとBitcoinの成長の間の競争によってハッシングパワー(Bitcoinネットワーク全体の秒間総生成ハッシュ数)が指数関数的に増加してきています。

[[network_hashing_power]]
.Total hashing power, gigahashes per second, over two years
.総ハッシングパワー(GHash/秒、過去2年間)
image::images/msbt_0807.png["NetworkHashingRate"]

((("difficulty target","hashing power and")))As the amount of hashing power applied to mining bitcoin has exploded, the difficulty has risen to match it. The difficulty metric in the chart shown in <<bitcoin_difficulty>> is measured as a ratio of current difficulty over minimum difficulty (the difficulty of the first block).

((("difficulty target","hashing power and")))マイニングに注ぎ込まれるハッシングパワーの量が爆発的に増えてきたため、difficultyもそれに合わせて上昇してきました。<<bitcoin_difficulty>>に示されているチャートにあるdifficultyの数値は、現在のdifficultyを最小difficulty(最初のブロックのdifficulty)で割った率で計算されています。

[[bitcoin_difficulty]]
.Bitcoin's mining difficulty metric, over two years
.過去２年間のBitcoinのマイニングdifficulty推移
image::images/msbt_0808.png["BitcoinDifficulty"]

In the last two years, the ASIC mining chips have become increasingly denser, approaching the cutting edge of silicon fabrication with a feature size (resolution) of 22 nanometers (nm). Currently, ASIC manufacturers are aiming to overtake general-purpose CPU chip manufacturers, designing chips with a feature size of 16nm, because the profitability of mining is driving this industry even faster than general computing. There are no more giant leaps left in bitcoin mining, because the industry has reached the forefront of((("Moore's Law"))) Moore's Law, which stipulates that computing density will double approximately every 18 months. Still, the mining power of the network continues to advance at an exponential pace as the race for higher density chips is matched ((("data centers, mining with")))with a race for higher density data centers where thousands of these chips can be deployed. It's no longer about how much mining can be done with one chip, but how many chips can be squeezed into a building, while still dissipating the heat and providing adequate power.

最近の２年間は、ASICマイニングチップがより高密度になってきており、シリコン製作における22ナノメートル(nm)の加工寸法(分解能)限界値に近づいてきています。現在、ASICメーカーは汎用CPUチップメーカーを追い越そうとしており、16nm加工寸法チップを設計しています。マイニングの収益性が高いため汎用計算機よりも一層強くこの業界を引っ張っているのです。ただBitcoinマイニングに関してさらなる急激な上昇は残されていません。というのは、18ヶ月毎に半導体の集積密度が約２倍になるという ((("Moore's Law"))) ムーアの法則の先端にまで達してしまっているためです。より高密度なチップが ((("data centers, mining with"))) 数千チップを配置できるより高密度なデータセンターに求められているので、まだBitcoinネットワークのマイニングパワーは指数関数的なペースで進化し続けていっています。???? もはや１つのチップでどれだけのマイニングができるかではなく、熱をうまく散らして十分なパワーを提供しつついくつのチップをどれだけデータセンターに詰め込むことができるかになってきています。

[[extra_nonce]]
==== The Extra Nonce Solution
==== extra nonceによる方法

((("block headers","computing power and")))((("difficulty target","computing power and")))((("difficulty target","extra nonce solution and")))((("nonce","extra")))((("extra nonce solution to increasing difficulty targets")))((("hashing race","extra nonce solutions")))Since 2012, bitcoin mining has evolved to resolve a fundamental limitation in the structure of the block header. In the early days of bitcoin, a miner could find a block by iterating through the nonce until the resulting hash was below the target. As difficulty increased, miners often cycled through all 4 billion values of the nonce without finding a block. However, this was easily resolved by updating the block timestamp to account for the elapsed time. Because the timestamp is part of the header, the change would allow miners to iterate through the values of the nonce again with different results.  Once mining hardware exceeded 4 GH/sec, however, this approach became increasingly difficult because the nonce values were exhausted in less than a second. As ASIC mining equipment started pushing and then exceeding the TH/sec hash rate, the mining software needed more space for nonce values in order to find valid blocks. The timestamp could be stretched a bit, but moving it too far into the future would cause the block to become invalid. A new source of "change" was needed in the block header. The solution was to use the coinbase transaction as a source of extra nonce values. Because the coinbase script can store between 2 and 100 bytes of data, miners started using that space as extra nonce space, allowing them to explore a much larger range of block header values to find valid blocks. The coinbase transaction is included in the merkle tree, which means that any change in the coinbase script causes the merkle root to change. Eight bytes of extra nonce, plus the 4 bytes of "standard" nonce allow miners to explore a total 2^96^ (8 followed by 28 zeros) possibilities _per second_ without having to modify the timestamp. If, in the future, miners could run through all these possibilities, they could then modify the timestamp. There is also more space in the coinbase script for future expansion of the extra nonce space.

((("block headers","computing power and")))((("difficulty target","computing power and")))((("difficulty target","extra nonce solution and")))((("nonce","extra")))((("extra nonce solution to increasing difficulty targets")))((("hashing race","extra nonce solutions")))2012年からBitcoinマイニングはブロックヘッダ構造にある制限を解決しながら発展してきました。Bitcoinの初期、difficulty targetが低くnonceを使って解を得られるまではマイナーはnonceを繰り返し使うことでブロックを発見できました。difficultyが大きくなっていくにつれて、マイナーはブロックを発見することなくnonceの４億通り全てを使ってしまうことが頻繁に起きるようになっていました。しかし、これはマイニング経過時間を把握するためのブロックのタイムスタンプを更新することで簡単に解決されました。このタイムスタンプはヘッダの一部であるため、タイムスタンプが変わることでマイナーはnonceの値を繰り返し使い、異なるハッシュ値を得ることができるのです。しかし、一度マイニングハードウェアの処理速度が4GH/秒を超えると、この方法は難しくなってきました。というのは、nonceが１秒以内使い尽くされてしまうからです。ASICマイニングが始まるとハッシュレートはTH/秒を超え、マイニングソフトウェアは有効なブロックを見つけるためにより広いnonceスペースが必要になってきました。タイムスタンプを少し引き延ばすことはできましたが、タイムスタンプを将来に移動することはブロックを無効にしてしまうことになります。???? ブロックヘッダの中のどこかに"変更"が必要になってきました。これに対する解はcoinbaseトランザクションにextra nonceを入れるというものです。coinbaseスクリプトは2byteから100byteのデータを記録できるため、マイナーはこのスペースをextra nonceとして使い始め、より大きいブロックヘッダの範囲を探索してブロックを見つけることができるようになりました。coinbaseトランザクションはmerkle treeに含められているため、coinbaseスクリプトにあるどんな変更もmerkle rootを変化させることになります。8byte extra nonceと"標準"の4byte nonceを使って、マイナーはタイムスタンプを変えることなく _秒間_ 2^96^ 個(8のあとに28個の0が続く数)の探索ができるようになりました。もし将来マイナーがこれら全ての可能性を調べ尽くせるようになれば、タイムスタンプを修正してマイニングをするようになるでしょう。また、将来のextra nonceスペースの拡張のためcoinbaseスクリプトにはさらに大きいスペースがあります。

[[mining_pools]]
==== Mining Pools
==== マイニングプール

((("hashing race","mining pools", id="ix_ch08-asciidoc26", range="startofrange")))((("mining pools", id="ix_ch08-asciidoc27", range="startofrange")))In this highly competitive environment,((("solo miners"))) individual miners working alone (also known as solo miners) don't stand a chance. The likelihood of them finding a block to offset their electricity and hardware costs is so low that it represents a gamble, like playing the lottery. Even the fastest consumer ASIC mining system cannot keep up with commercial systems that stack tens of thousands of these chips in giant warehouses near hydro-electric power stations. Miners now collaborate to form mining pools, pooling their hashing power and sharing the reward among thousands of participants. By participating in a pool, miners get a smaller share of the overall reward, but typically get rewarded every day, reducing uncertainty.

((("hashing race","mining pools", id="ix_ch08-asciidoc26", range="startofrange")))((("mining pools", id="ix_ch08-asciidoc27", range="startofrange")))この激しい競争環境の中で、 ((("solo miners"))) 一人でやっている個人のマイナー(ソロマイナーと呼ばれています)は勝ち目がありません。ブロックを見つけて電気やハードウェアのコストを相殺しようとすることの見込みは低すぎて、宝くじを買うようなギャンブルになってしまいます。速い消費者向けASICマイニングでさえ、水力発電所の近くの巨大な倉庫に数万個のチップを積み重ねて作った商用システムには追いつきません。今ではマイナーはマイニングプールを作って協力するようになっており、マイニングプールでは個々のマイナーのハッシングパワーを貯め、報酬を数千人の参加者と分けるということをしています。マイニングプールに参加することで、マイナーは総報酬の小さな一部だけを得ることになりますが、毎日平均的に報酬を得ることができるようになり、不確実性を減らすことができます。

Let's look at a specific example. Assume a miner has purchased mining hardware with a combined hashing rate of 6,000 gigahashes per second (GH/s), or 6 TH/s. In August of 2014 this equipment costs approximately $10,000. The hardware consumes 3 kilowatts (kW) of electricity when running, 72 kW-hours a day, at a cost of $7 or $8 per day on average. At current bitcoin difficulty, the miner will be able to solo mine a block approximately once every 155 days, or every 5 months. If the miner does find a single block in that timeframe, the payout of 25 bitcoins, at approximately $600 per bitcoin, will result in a single payout of $15,000, which will cover the entire cost of the hardware and the electricity consumed over the time period, leaving a net profit of approximately $3,000. However, the chance of finding a block in a five-month period depends on the miner's luck. He might find two blocks in five months and make a very large profit. Or he might not find a block for 10 months and suffer a financial loss. Even worse, the difficulty of the bitcoin proof-of-work algorithm is likely to go up significantly over that period, at the current rate of growth of hashing power, meaning the miner has, at most, six months to break even before the hardware is effectively obsolete and must be replaced by more powerful mining hardware. If this miner participates in a mining pool, instead of waiting for a once-in-five-months $15,000 windfall, he will be able to earn approximately $500 to $750 per week. The regular payouts from a mining pool will help him amortize the cost of hardware and electricity over time without taking an enormous risk. The hardware will still be obsolete in six to nine months and the risk is still high, but the revenue is at least regular and reliable over that period.

具体的な例を見てみましょう。マイナーが秒間6000ギガハッシュ(GH/s) または 6TH/sの総ハッシングレートを持つマイニングハードウェアを購入したとします。2014年の８月時点で、この装置は約10000ドルします。このハードウェアは動作時に3キロワット(kW)の電力を消費し、1日に72kW時、金額にして1日平均7ドルか8ドルかかります。現在のBitcoin difficultyでは、マイナーは平均的に155日毎(5ヶ月)に一回ブロックを１人で採掘できます。もしマイナーがこの時間間隔で一つのブロックを見つけたとすると、25bitcoinの支払い(1bitcoinあたり約600ドル)は一回あたり15000ドルになり、ハードウェアやこの期間に消費した電気代のコスト全体を差し引くと約3000ドルの正味利益が残ります。しかし、５ヶ月間に１ブロックを見つけるかどうかはマイナーの運にかかっています。５ヶ月間に２ブロックを見つけて大きな利益を得るかもしれません。さもなければ、１０ヶ月間ブロックを見つけることができず経済的なロスを受けてしまうかもしれません。さらに悪いことに、Bitcoinのproof-of-workアルゴリズムのdifficultyはおそらく時間が経つにつれて現在のハッシングパワーの成長率に従って著しく上がっていくだろうと考えられます。このことは、ハードウェアが実質的に時代遅れになる６ヶ月より前に、さらにパワフルなマイニングハードウェアで置き替えなければならないということを意味します。もしこのマイナーが５ヶ月に１回の棚ぼた的な15000ドルを待っている代わりにマイニングプールに参加していれば、一週間に約500ドルから750ドルを稼ぐことができるでしょう。マイニングプールからの定期的な支払いを使うことで大きなリスクを負うことなくハードウェアや電気代のコストの償却ができます。ハードウェアは６ヶ月から９ヶ月後に時代遅れになるためリスクはまだ高いですが、少なくとも収入はこの期間の間確実に定期的に入ることになるのです。

Mining pools coordinate many hundreds or thousands of miners, over specialized pool-mining protocols. The individual miners configure their mining equipment to connect to a pool server, after creating an account with the pool. Their mining hardware remains connected to the pool server while mining, synchronizing their efforts with the other miners. Thus, the pool miners share the effort to mine a block and then share in the rewards. 

マイニングプールは特別なプールマイニングプロトコルを通して数十万人ものマイナーを束ねています。個々のマイナーはマイニングプールにアカウントを作成した後、マイニング機器をプールサーバに接続するように設定します。マイニングハードウェアはマイニングの最中このプールサーバに接続されたままになっており、他のマイナーとマイニング結果を同期しています。このため、マイニングプールマイナーはブロックを採掘した結果を共有し、これによって得られた報酬を分配します。

Successful blocks pay the reward to a pool bitcoin address, rather than individual miners. The pool server will periodically make payments to the miners' bitcoin addresses, once their share of the rewards has reached a certain threshold. Typically, the pool server charges a percentage fee of the rewards for providing the pool-mining service.

採掘に成功したブロックの報酬はプールサーバのBitcoinアドレスに支払われます。個々のマイナーではありません。報酬の分配総額がある閾値に達したら、プールサーバは繰り返しマイナーのBitcoinアドレスに支払いを行います。典型的に、プールマイニングサービスを提供するためプールサーバは報酬の一定パーセントを手数料として徴収しています。

Miners participating in a pool split the work of searching for a solution to a candidate block, earning "shares" for their mining contribution. The mining pool sets a lower difficulty target for earning a share, typically more than 1,000 times easier than the bitcoin network's difficulty. When someone in the pool successfully mines a block, the reward is earned by the pool and then shared with all miners in proportion to the number of shares they contributed to the effort. 

マイニングプールに参加しているマイナーたちは候補ブロックに対する解を探す仕事を分割し、マイニングに対する寄与によって"分配"を稼ぎます。マイニングプールは分配を稼ぐためにより低いdifficulty targetを設定します。典型的に、Bitcoinネットワークのdifficultyの1000分の1以下のdifficultyになっています。マイニングプールの誰かがブロックを採掘するとまずこの報酬はプールによって受け取られ、寄与した仕事量に比例した分の分配が全てのマイナーに配られます。

Pools are open to any miner, big or small, professional or amateur. A pool will therefore have some participants with a single small mining machine, and others with a garage full of high-end mining hardware. Some will be mining with a few tens of a kilowatt of electricity, others will be running a data center consuming a megawatt of power. How does a mining pool measure the individual contributions, so as to fairly distribute the rewards, without the possibility of cheating? The answer is to use bitcoin's proof-of-work algorithm to measure each pool miner's contribution, but set at a lower difficulty so that even the smallest pool miners win a share frequently enough to make it worthwhile to contribute to the pool. By setting a lower difficulty for earning shares, the pool measures the amount of work done by each miner. Each time a pool miner finds a block header hash that is less than the pool difficulty, she proves she has done the hashing work to find that result. More importantly, the work to find shares contributes, in a statistically measurable way, to the overall effort to find a hash lower than the bitcoin network's target. Thousands of miners trying to find low-value hashes will eventually find one low enough to satisfy the bitcoin network target. 

マイニングプールは全てのマイナーに対して公開されています。大きい、小さい、プロ、アマチュアは関係ありません。このため、マイニングプールには単一の小さなマイニングマシンを持った参加者もいれば、ハイエンドマイニングハードウェアをガレージにいっぱい入れてマイニングをしている参加者もいます。一部の参加者は数十KWの電気代を使ってマイニングをしており、また別の参加者は1メガワットを消費してデータセンターを運用している参加者もいます。どのようにしてマイニングプールは個々の寄与を測定し、いかさまができないようにしながら平等に報酬を配っているのでしょうか？答えは、プールマイナーの個々の寄与を測るためにBitcoinのproof-of-workアルゴリズムを使うことです。ただし、最も小さいプールマイナーでさえも頻繁に分配を受けられ、やりがいを感じられるようにより低いdifficultyに設定しておきます。分配金を稼ぐために低いdifficultyに設定することで、マイニングプールはそれぞれのマイナーによって完了した仕事の量を測定します。プールマイナーがマイニングプールが設定したdifficultyよりも低いdifficultyのブロックヘッダハッシュを見つけるたびに、プールマイナーはハッシュ化作業を行ったことを証明することになるのです。さらに重要なこととして、Bitcoinネットワーク全体のdifficulty targetよりも低いdifficultyのハッシュを見つける努力に対する貢献度を、proof of workを通して統計的に測定可能な方法で割り振ります。低いdifficultyのハッシュを見つけようとしている数千のマイナーが偶然Bitcoinネットワークのdifficulty targetを満たすハッシュを見つけることになるのです。

Let's return to the analogy of a dice game. If the dice players are throwing dice with a goal of throwing less than four (the overall network difficulty), a pool would set an easier target, counting how many times the pool players managed to throw less than eight. When pool players throw less than eight (the pool share target), they earn shares, but they don't win the game because they don't achieve the game target (less than four). The pool players will achieve the easier pool target much more often, earning them shares very regularly, even when they don't achieve the harder target of winning the game. Every now and then, one of the pool players will throw a combined dice throw of less than four and the pool wins. Then, the earnings can be distributed to the pool players based on the shares they earned. Even though the target of eight-or-less wasn't winning, it was a fair way to measure dice throws for the players, and it occasionally produces a less-than-four throw. 

前に書いたサイコロゲームとの類似性に戻ってみましょう。もし４よりも小さい値(Bitcoinネットワーク全体のdifficulty)をサイコロを投げて出そうとするなら、プールはより簡単なtargetを設定し、何回プールプレイヤーが８よりも小さい値をサイコロを投げて出したかをカウントします。プールプレイヤーが８よりも小さい値(マイニングプールでの共有difficulty)を出したとき、プールプレイヤーは分配量を得ますがゲームには勝っていません。なぜなら(４より小さい値を出すという)ゲームの水準に達していないからです。ゲームに勝てる水準のdifficulty targetに達しなかったとしても、プールプレイヤーはより簡単なdifficulty targetをより頻繁に満たすことで、定期的に分配量が彼らに割り振られるようにします。ときどきプールプレイヤーのうちの一人が二つのサイコロの目を足して４より小さい値にした場合、このプールが勝ちます。このとき、このときの報酬はプールプレイヤーが得た分配量に基づいてプールプレイヤーに分配されます。８かそれより小さい値を出すという水準がゲームに勝つようなものではなかったとしても、これはプールプレイヤーがサイコロを振ったということを測る公平な方法であり、時折４よりも小さい値を出すことがあるのです。

Similarly, a mining pool will set a pool difficulty that will ensure that an individual pool miner can find block header hashes that are less than the pool difficulty quite often, earning shares. Every now and then, one of these attempts will produce a block header hash that is less than the bitcoin network target, making it a valid block and the whole pool wins.(((range="endofrange", startref="ix_ch08-asciidoc27")))(((range="endofrange", startref="ix_ch08-asciidoc26"))) 

同様に、マイニングプールは個々のプールマイナーがプールのdifficultyよりも低いdifficultyのブロックヘッダハッシュをとても頻繁に発見することができるようにプールのdifficultyを設定します。ときどきこれらの試行のうちの一つがBitcoinネットワークでのdifficulty targetよりも低いブロックヘッダハッシュを作り出し、有効なブロックを作りプール全体が勝つことになります。(((range="endofrange", startref="ix_ch08-asciidoc27")))(((range="endofrange", startref="ix_ch08-asciidoc26")))

===== Managed pools
===== マネージドプール

((("managed pools")))((("mining pools","managed pools")))Most mining pools are "managed," meaning that there is a company or individual running a pool server. The owner of the pool server is called the((("pool operator of mining pools"))) _pool operator_, and he charges pool miners a percentage fee of the earnings. 

((("managed pools")))((("mining pools","managed pools")))ほとんどのマイニングプールは"管理された"もので、プールサーバを動かしている会社か個人がいます。このプールサーバの所有者は ((("pool operator of mining pools"))) _プールオペレータ_ と呼ばれており、プールマイナーの稼ぎのうちの一定パーセントを手数料としプールマイナーに課しています。

The pool server runs specialized software and a pool-mining protocol that coordinates the activities of the pool miners. The pool server is also connected to one or more full bitcoin nodes and has direct access to a full copy of the blockchain database. This allows the pool server to validate blocks and transactions on behalf of the pool miners, relieving them of the burden of running a full node. For pool miners, this is an important consideration, because a full node requires a dedicated computer with at least 15 to 20 GB of persistent storage (disk) and at least 2 GB of memory (RAM). Furthermore, the bitcoin software running on the full node needs to be monitored, maintained, and upgraded frequently. Any downtime caused by a lack of maintenance or lack of resources will hurt the miner's profitability. For many miners, the ability to mine without running a full node is another big benefit of joining a managed pool. 

プールサーバでは、特別なソフトウェアやプールマイナーの活動を調整するプールマイニングプロトコルを動作させています。プールサーバはまた、一つまたは複数のフルBitcoinノードとコネクションを張り、ブロックチェーンデータベースの完全なコピーに直接アクセスできるようになっています。これによって、プールサーバはプールマイナーのためにブロックやトランザクションの検証をすることができ、プールマイナーがフルノードを動かす負荷を軽減しています。プールマイナーにとって、これは重要なことです。なぜなら、フルノードには少なくとも15GBから20GBの永続的なストレージ(ディスク)と2GBのメモリ(RAM)を持っている専用コンピュータが必要になるからです。さらに、フルノードで動作しているBitcoinソフトウェアを監視し、メンテナンスし、頻繁にアップグレードをする必要があります。メンテナンスの欠如、またはリソースの欠如によって生じたどんなダウンタイムもマイナーの利益を減らしてしまいます。多くのマイナーにとって、フルノードを動作させることなく採掘ができるということは、マネージドプールに参加するもう一つの大きな利点なのです。

Pool miners connect to the pool server using a mining protocol such as((("Stratum (STM) mining protocol"))) Stratum (STM) or((("GetBlockTemplate (GBT) mining protocol"))) GetBlockTemplate (GBT). An older standard called((("GetWork (GWK) mining protocol"))) GetWork (GWK) has been mostly obsolete since late 2012, because it does not easily support mining at hash rates above 4 GH/s. Both the STM and GBT protocols create((("block templates"))) block _templates_ that contain a template of a candidate block header. The pool server constructs a candidate block by aggregating transactions, adding a coinbase transaction (with extra nonce space), calculating the merkle root, and linking to the previous block hash. The header of the candidate block is then sent to each of the pool miners as a template. Each pool miner then mines using the block template, at a lower difficulty than the bitcoin network difficulty, and sends any successful results back to the pool server to earn shares. 

プールマイナーは ((("Stratum (STM) mining protocol"))) Stratum (STM) や ((("GetBlockTemplate (GBT) mining protocol"))) GetBlockTemplate (GBT) のようなマイニングプロトコルを使ってプールサーバに接続しています。少し前の標準的なプロトコルであった ((("GetWork (GWK) mining protocol"))) GetWork (GWK) は2012年の終わりからほぼ時代遅れになっています。というのは、4GH/sよりも大きいハッシュレートでのマイニングをサポートしていないからです。STMもGBTも候補ブロックヘッダのテンプレートを含む ((("block templates"))) ブロック _テンプレート_ を作ります。プールサーバはトランザクションを集めることで候補ブロックを構築し、coinbaseトランザクション(extra nonceスペースを含む)を追加し、merkle rootを計算し、前のブロックハッシュに連結します。候補ブロックのヘッダはこのときテンプレートとしてプールマイナーそれぞれに送られます。それぞれのプールマイナーはブロックテンプレートを使ってBitcoinネットワークのdifficultyよりも低いdifficultyで採掘をし、どんな成功した結果もプールサーバに送り返し分配量を稼ぐことになります。

===== P2Pool
===== P2Pool

((("mining pools","P2Pool")))((("P2Pool")))Managed pools create the possibility of cheating by the pool operator, who might direct the pool effort to double-spend transactions or invalidate blocks (see <<consensus_attacks>>). Furthermore, centralized pool servers represent a single-point-of-failure. If the pool server is down or is slowed by a denial-of-service attack, the pool miners cannot mine. In 2011, to resolve these issues of centralization, a new pool mining method was proposed and implemented: P2Pool is a peer-to-peer mining pool, without a central operator. 

((("mining pools","P2Pool")))((("P2Pool")))マネージドプールではプールオペレータによってイカサマをされる可能性があります。プールオペレータはプールに対する労力を二重使用トランザクションやブロックの無効化(<<consensus_attacks>>参照)に仕向けるかもしれません。さらに、中央化されたプールサーバが単一障害点になることがあります。もしDOS攻撃でプールサーバがダウンしたり遅延したりした場合、プールマイナーは採掘ができません。2011年に、これらの中央化の問題点を解決するために、新しいプールマイニング方法が提案され実装されました。P2Poolはpeer-to-peerのマイニングプールで、中心的なオペレータがいません。
    
P2Pool works by decentralizing the functions of the pool server, implementing a parallel blockchain-like system called a((("share chains"))) _share chain_. A share chain is a blockchain running at a lower difficulty than the bitcoin blockchain. The share chain allows pool miners to collaborate in a decentralized pool, by mining shares on the share chain at a rate of one share block every 30 seconds. Each of the blocks on the share chain records a proportionate share reward for the pool miners who contribute work, carrying the shares forward from the previous share block. When one of the share blocks also achieves the difficulty target of the bitcoin network, it is propagated and included on the bitcoin blockchain, rewarding all the pool miners who contributed to all the shares that preceded the winning share block. Essentially, instead of a pool server keeping track of pool miner shares and rewards, the share chain allows all pool miners to keep track of all shares using a decentralized consensus mechanism like bitcoin's blockchain consensus mechanism. 

P2Poolはプールサーバの機能を分散化することで動作し、 ((("share chains"))) _シェアチェーン_ と呼ばれるブロックチェーンのような並列システムで実装されています。
シェアチェーンはBitcoinのブロックチェーンよりも低いdifficultyで動作しているブロックチェーンです。
シェアチェーンによってプールマイナーは分散化されたプール内で協力することができるようになり、30秒毎にシェアブロックの率でシェアチェーン上の割り当て分を採掘することでマイニングシェア
シェアチェーン上のそれぞれのブロックは仕事に寄与したプールマイナーに対して割り当てた報酬を記録
前のシェアブロックからシェアを運ぶ
シェアブロックのうち１つでもBitcoinネットワークのdifficulty targetに達するものがあれば、それが伝搬されBitcoinのブロックチェーン上に埋め込まれ、勝ったシェアブロックを
本質的に、プールマイナーのシェアと報酬を記録しているプールサーバの代わりに、シェアチェーンは????

P2Pool mining is more complex than pool mining because it requires that the pool miners run a dedicated computer with enough disk space, memory, and Internet bandwidth to support a full bitcoin node and the P2Pool node software. P2Pool miners connect their mining hardware to their local P2Pool node, which simulates the functions of a pool server by sending block templates to the mining hardware. On P2Pool, individual pool miners construct their own candidate blocks, aggregating transactions much like solo miners, but then mine collaboratively on the share chain. P2Pool is a hybrid approach that has the advantage of much more granular payouts than solo mining, but without giving too much control to a pool operator like managed pools. 

P2Poolマイニングはプールマイニングよりも複雑です。なぜなら、フルBitcoinノードとP2Poolノードソフトウェアをサポートするための十分なディスクスペース、メモリ、インターネット帯域を持った専用コンピュータをプールマイナーが動作させる必要があるためです。P2Poolマイナーは自身のマイニングハードウェアをローカルのP2Poolノードに接続し、このローカルP2Poolがマイニングハードウェアにブロックテンプレートを送るプールサーバの機能を真似ることになります。P2Pool上では、個々のプールマイナーが自身で候補ブロックを構築しソロマイナーのようにトランザクションを集めますが、このときシェアチェーン上で共同で採掘をします。P2Poolはソロマイニングより粒子が小さい支払いができるという有利な点がありつつ、マネージドプールのようなプールオペレータにとても大きなコントロールを与えることがないというハイブリッドなアプローチになっています。

Recently, participation in P2Pool has increased significantly as mining concentration in mining pools has approached levels that create concerns of a((("51% attacks"))) 51% attack (see <<consensus_attacks>>). Further development of the P2Pool protocol continues with the expectation of removing the need for running a full node and therefore making decentralized mining even easier to use.(((range="endofrange", startref="ix_ch08-asciidoc25")))(((range="endofrange", startref="ix_ch08-asciidoc24")))(((range="endofrange", startref="ix_ch08-asciidoc23"))) 

最近、マイニングプールへのマイニング集中が ((("51% attacks"))) 51%攻撃 (<<consensus_attacks>>参照)への懸念を引き起こすレベルにまでなってきており、P2Poolへの参加が著しく増えてきています。
さらにP2Poolプロトコルの開発を進めてフルノードを走らせる必要性がなくなることが期待が続きます。できれば、分散化されたマイニングがさらに使いやすく????

Even though P2Pool reduces the concentration of power by mining pool operators, it is conceivably vulnerable to 51% attacks against the share chain itself. A much broader adoption of P2Pool does not solve the 51% attack problem for bitcoin itself. Rather, P2Pool makes bitcoin more robust overall, as part of a diversified mining ecosystem. 

P2Poolがマイニングプールオペレータによるパワーの集中を削減することはありますが、おそらくシェアチェーンそのものに対する51%攻撃の脆弱性はありえます。P2Poolがとても広く採用されてもBitcoinそのものに対する51%攻撃の解決はしないのです。むしろ、マイニングエコシステムを多様化させる一部分としてP2PoolはBitcoinを全体的により堅牢にすることになります。

[[consensus_attacks]]
=== Consensus Attacks
=== コンセンサス攻撃

((("consensus","attacks", id="ix_ch08-asciidoc28", range="startofrange")))((("security","consensus attacks", id="ix_ch08-asciidoc29", range="startofrange")))Bitcoin's consensus mechanism is, at least theoretically, vulnerable to attack by miners (or pools) that attempt to use their hashing power to dishonest or destructive ends. As we saw, the consensus mechanism depends on having a majority of the miners acting honestly out of self-interest. However, if a miner or group of miners can achieve a significant share of the mining power, they can attack the consensus mechanism so as to disrupt the security and availability of the bitcoin network. 

((("consensus","attacks", id="ix_ch08-asciidoc28", range="startofrange")))((("security","consensus attacks", id="ix_ch08-asciidoc29", range="startofrange")))Bitcoinのコンセンサスメカニズムは、少なくとも理論的には、ハッシングパワーを使って不正なまたは破壊的な方向に持って行こうとするマイナー(またはマイニングプール)による攻撃に対して脆弱です。今まで見たように、コンセンサスメカニズムは自己の興味に対して正直に行動するマイナーが大多数いるということに依存しています。しかし、もしマイナーやマイナーの集団がマイニングパワーの十分なシェアを取り得たとすると、彼らはBitcoinネットワークのセキュリティや有用性を破壊するようにコンセンサスメカニズムを攻撃できるのです。

It is important to note that consensus attacks can only affect future consensus, or at best the most recent past (tens of blocks). Bitcoin's ledger becomes more and more immutable as time passes. While in theory, a fork can be achieved at any depth, in practice, the computing power needed to force a very deep fork is immense, making old blocks practically immutable. Consensus attacks also do not affect the security of the private keys and signing algorithm (ECDSA). A consensus attack cannot steal bitcoins, spend bitcoins without signatures, redirect bitcoins, or otherwise change past transactions or ownership records. Consensus attacks can only affect the most recent blocks and cause denial-of-service disruptions on the creation of future blocks. 

コンセンサス攻撃は将来の合意形成に影響を与えることができるだけで、過去に対してはせいぜい少し過去(１０ブロック前)に影響を与えられるくらいです。このことはとても重要なことなのです。Bitcoinの元帳は時間が過ぎれば過ぎるほど、どんどん不変になっていきます。理論上フォークしたブロックチェーンはどんな深さにでも達することができますが、実際にはとても深いフォークを作るには古いブロックを変更できないようにしておく必要があるため莫大な計算量が必要です。コンセンサス攻撃はまた秘密鍵や署名アルゴリズム(ECDSA)のセキュリティに全く影響を与えません。コンセンサス攻撃はbitcoinを盗むことも、署名なしにbitcoinを使うことも、bitcoinの支払先を書き換えることも、過去のトランザクションや記録の所有者を変えることもできません。コンセンサス攻撃は単に直近のブロックに影響を与え、将来のブロック生成に対してDOS攻撃による破壊を引き起こすだけなのです。

((("51% attacks")))((("consensus attacks","51% attacks")))One attack scenario against the consensus mechanism is called the "51% attack." In this scenario a group of miners, controlling a majority (51%) of the total network's hashing power, collude to attack bitcoin. With the ability to mine the majority of the blocks, the attacking miners can cause deliberate "forks" in the blockchain and double-spend transactions or execute denial-of-service attacks against specific transactions or addresses.((("double-spend attack")))((("fork attack"))) A fork/double-spend attack is one where the attacker causes previously confirmed blocks to be invalidated by forking below them and re-converging on an alternate chain. With sufficient power, an attacker can invalidate six or more blocks in a row, causing transactions that were considered immutable (six confirmations) to be invalidated. Note that a double-spend can only be done on the attacker's own transactions, for which the attacker can produce a valid signature. Double-spending one's own transactions is profitable if by invalidating a transaction the attacker can get a nonreversible exchange payment or product without paying for it. 

((("51% attacks")))((("consensus attacks","51% attacks")))コンセンサスメカニズムに対する一つの攻撃シナリオは"51%攻撃"と呼ばれています。このシナリオでは、全Bitcoinネットワークのハッシングパワーの大多数(51%)をコントロールしているマイナーのグループが共謀してBitcoinへの攻撃をするというものです。ブロックの大部分を採掘する能力を持つことで、攻撃マイナーはブロックチェーンに故意の"フォーク"を作り出し、トランザクションを二重に使用したり、DOS攻撃を特定のトランザクションまたはアドレスに対して実行したりできます。((("double-spend attack")))((("fork attack"))) フォーク/二重使用攻撃では、攻撃者が事前にある確認済みブロックよりも下をフォークすることでこの確認済みブロックを無効化し、攻撃者が作った代わりのチェーンにブロックチェーンを再収縮させます。十分なハッシングパワーを持っていれば、攻撃者は６つまたはそれ以上のブロックを無効化でき、変更不可能だと考えられている(6回の確認が行われた)トランザクションを無効化できます。二重使用は攻撃者自身のトランザクションのみに対して行われるため、攻撃者は有効な署名をしたトランザクションを作り出すことができます。???? もしトランザクションを無効化することで支払いなしに攻撃者が不可逆な為替支払いや商品を取得できるなら、攻撃者自身のトランザクションの二重使用は有益なものになるのです。

Let's examine a practical example of a 51% attack. In the first chapter, we looked at a transaction between Alice and Bob for a cup of coffee. Bob, the cafe owner, is willing to accept payment for cups of coffee without waiting for confirmation (mining in a block), because the risk of a double-spend on a cup of coffee is low in comparison to the convenience of rapid customer service. This is similar to the practice of coffee shops that accept credit card payments without a signature for amounts below $25, because the risk of a credit-card chargeback is low while the cost of delaying the transaction to obtain a signature is comparatively larger. In contrast, selling a more expensive item for bitcoin runs the risk of a double-spend attack, where the buyer broadcasts a competing transaction that spends the same inputs (UTXO) and cancels the payment to the merchant. A double-spend attack can happen in two ways: either before a transaction is confirmed, or if the attacker takes advantage of a blockchain fork to undo several blocks. A 51% attack allows attackers to double-spend their own transactions in the new chain, thus undoing the corresponding transaction in the old chain. 

51%攻撃を具体的な例で説明してみましょう。第1章で、一杯のコーヒー代の支払いに使われたアリスとボブの間のトランザクションをみました。カフェのオーナーであるボブは確認(ブロックの採掘)を待つことなくコーヒー代を喜んで受け入れています。なぜなら、コーヒー代の二重使用のリスクは、素早い顧客サービスを提供することの利便性と比べると低いからです。これは25ドル以下の支払いに対して署名なくクレジットカードの支払いを受け付けるコーヒーショップと同様で、署名のために生じる取引の遅延コストの方がクレジットカードの請求取り消しのリスクより比較的大きいからです。反対に、bitcoinでもっと高額な商品を売る場合は二重使用攻撃の大きなリスクがあります。購入者は競合するトランザクション(販売者への支払いに使ったトランザクションインプット(UTXO)を使って、販売者への支払いをキャンセルするトランザクション)をブロードキャストします。二重使用攻撃は二つの場合に生じ得ます。一つは、トランザクションが確認される前、もう一つはもし攻撃者がいくつかのブロックを元に戻せるような優位性を持っている場合です。51%攻撃によって、攻撃者は自身で新しく作ったブロックチェーン上で自身のトランザクションを二重使用をすることができるようになり、よって古いブロックチェーン上にある対応した販売者への支払いトランザクションを元に戻し、販売者への支払いをなかったことにできるのです。

In our example, malicious attacker Mallory goes to Carol's gallery and purchases a beautiful triptych painting depicting Satoshi Nakamoto as Prometheus. Carol sells "The Great Fire" paintings for $250,000 in bitcoin, to Mallory. Instead of waiting for six or more confirmations on the transaction, Carol wraps and hands the paintings to Mallory after only one confirmation. Mallory works with an accomplice, Paul, who operates a large mining pool, and the accomplice launches a 51% attack as soon as Mallory's transaction is included in a block. Paul directs the mining pool to re-mine the same block height as the block containing Mallory's transaction, replacing Mallory's payment to Carol with a transaction that double-spends the same input as Mallory's payment. The double-spend transaction consumes the same UTXO and pays it back to Mallory's wallet, instead of paying it to Carol, essentially allowing Mallory to keep the bitcoin. Paul then directs the mining pool to mine an additional block, so as to make the chain containing the double-spend transaction longer than the original chain (causing a fork below the block containing Mallory's transaction). When the blockchain fork resolves in favor of the new (longer) chain, the double-spent transaction replaces the original payment to Carol. Carol is now missing the three paintings and also has no bitcoin payment. Throughout all this activity, Paul's mining pool participants might remain blissfully unaware of the double-spend attempt, because they mine with automated miners and cannot monitor every transaction or block.

例として、悪意ある攻撃者マロリーがキャロルの画廊に行き、プロメテウスとしてSatoshi Nakamotoを描いた美しい三連祭壇画を購入することを考えてみましょう。キャロルは"The Great Fire"の絵画を250,000ドルでマロリーにbitcoinで売ります。???? トランザクションの６回またはそれ以上の確認を待たずに、キャロルはたった１回の確認後に絵画をラッピングしてマロリーに手渡しました。マロリーは共犯者ポールとともに共謀しており、ポールは巨大なマイニングプールを運用しています。この共犯者ポールはマロリーのトランザクションがブロックに取り込まれるとすぐに51%攻撃を実行しました。ポールはマイニングプールを操ってマロリーのトランザクションを含んでいるブロックと同じブロック高を再採掘し、マロリーからキャロルへの支払いトランザクションを、マロリーが支払いに使ったインプットと同じインプットを二重使用するトランザクションで置き換えます。この二重使用トランザクションは同じUTXOを消費し、キャロルへの支払いの代わりにマロリーのウォレットに支払い戻すようにし、本質的にマロリーはbitcoinを使わずに保ったままな状態にできるのです。このときポールはマイニングプールを操りもう一つのブロックをマイニングし、元々のブロックチェーンよりも長い二重使用トランザクションを含んだブロックチェーンを作るようにします(マロリーからキャロルへの支払いトランザクションが含まれたブロックより下のブロックが同じようなフォークを作り出します)。新しい(元々のブロックチェーンより長い)ブロックチェーンが選ばれることでブロックチェーンのフォークが解消されると、二重使用トランザクションはキャロルへの元々の支払いトランザクションを置き換えることになります。キャロルは三つの絵画を失い、しかもbitcoinが支払われていないのです。この全ての行動に関して、ポールのマイニングプールに参加している参加者は幸せなことに二重使用トランザクションが行われたことに気づかないままでいるかもしれません。というのは、彼らは自動化されたマイナーでマイニングを行っており、全てのトランザクションまたはブロックを追跡することはできないからです。

To protect against this kind of attack, a merchant selling large-value items must wait at least six confirmations before giving the product to the buyer. Alternatively, the merchant should use an escrow((("multi-signature account"))) multi-signature account, again waiting for several confirmations after the escrow account is funded. The more confirmations elapse, the harder it becomes to invalidate a transaction with a 51% attack. For high-value items, payment by bitcoin will still be convenient and efficient even if the buyer has to wait 24 hours for delivery, which would ensure 144 confirmations. 

このタイプの攻撃を防ぐには、大きな額の商品を売る販売者は購入者に商品を渡す前に少なくとも６回の確認を待たなければいけません。もしくは、販売者はエスクロー((("multi-signature account"))) マルチシグネチャーアカウントを使うべきで、この場合でも同じようにエスクローアカウントに資金が入った後に数回の確認を待たなければいけません。確認が多くされればされるほど、51%攻撃に伴うトランザクションの無効化はより難しくなります。高額な商品に対してはたとえ購入者に商品が届くまで24時間待たなければいけない(144回の確認を保証)としても、bitcoinによる支払いはまだ利便性があり効果的なのです。

((("consensus attacks","denial of service attack")))((("denial of service attack")))In addition to a double-spend attack, the other scenario for a consensus attack is to deny service to specific bitcoin participants (specific bitcoin addresses). An attacker with a majority of the mining power can simply ignore specific transactions. If they are included in a block mined by another miner, the attacker can deliberately fork and re-mine that block, again excluding the specific transactions. This type of attack can result in a sustained denial of service against a specific address or set of addresses for as long as the attacker controls the majority of the mining power. 

((("consensus attacks","denial of service attack")))((("denial of service attack")))二重使用以外のコンセンサス攻撃のシナリオは、特定のBitcoin参加者(特定のBitcoinアドレス)に対するサービスを拒否するようにしてしまうことです。マイニングパワーの大多数を占める攻撃者は単に特定のトランザクションを無視することができます。もしこれらのトランザクションが他のマイナーによって採掘されたブロックを含められた場合、攻撃者はわざとフォークをしてこのブロックを再採掘することができ、再び特定のトランザクションを除外することができるのです。攻撃者がマイニングパワーの大多数をコントロールできる限り、このタイプの攻撃によって特定のBitcoinアドレスまたはBitcoinアドレスの集合に対して持続的DOS攻撃を引き起こすことができます。

Despite its name, the 51% attack scenario doesn't actually require 51% of the hashing power. In fact, such an attack can be attempted with a smaller percentage of the hashing power. The 51% threshold is simply the level at which such an attack is almost guaranteed to succeed. A consensus attack is essentially a tug-of-war for the next block and the "stronger" group is more likely to win. With less hashing power, the probability of success is reduced, because other miners control the generation of some blocks with their "honest" mining power. One way to look at it is that the more hashing power an attacker has, the longer the fork he can deliberately create, the more blocks in the recent past he can invalidate, or the more blocks in the future he can control. Security research groups have used statistical modeling to claim that various types of consensus attacks are possible with as little as 30% of the hashing power. 

この名前にも関わらず、51%攻撃シナリオは実際にハッシングパワーの51%が必要というわけではありません。事実、このような攻撃はハッシングパワーの51%より小さい割合でも起こすことができます。51%という閾値は、単にこのくらいの割合にならないとそのような攻撃がほとんど成功しないという意味です。コンセンサス攻撃は本質的に次のブロックに対する主導権争いであり、"より強い"グループがより勝ちやすいのです。ハッシングパワーがより少なければ成功確率はさがります。というのは、他のマイナーの"信頼できる"ハッシングパワーによって同じブロックの生成がコントロールされるからです。もう一つの側面として、より多くのハッシングパワーを攻撃者が持っていれば持っているほど、攻撃者はわざとより長いフォークを作ることができ、攻撃者が無効化できる直近のブロック数、または攻撃者がコントロールできる将来のブロック数も多くなります。セキュリティ研究グループは、統計学的モデリングを使って30%程度のハッシングパワーの占有率でいろいろなタイプのコンセンサス攻撃が可能になるということを主張しています。

The massive increase of total hashing power has arguably made bitcoin impervious to attacks by a single miner. There is no possible way for a solo miner to control more than a small percentage of the total mining power. However, the centralization of control caused by mining pools has introduced the risk of for-profit attacks by a mining pool operator. The pool operator in a managed pool controls the construction of candidate blocks and also controls which transactions are included. This gives the pool operator the power to exclude transactions or introduce double-spend transactions. If such abuse of power is done in a limited and subtle way, a pool operator could conceivably profit from a consensus attack without being noticed.

総ハッシングパワーの大幅な増加によって、Bitcoinに対する単一マイナーによる攻撃はおそらく実行しにくくなっています。ソロマイナーが総マイニングパワーの大多数をコントロールすることは不可能なのです。しかし、マイニングプールによるハッシングパワーの中央コントロールによって、マイニングプールオペレータによる営利目的攻撃を引き起こすリスクが生じてきています。マネージドプールのマイニングプールオペレータは候補ブロックの構築をコントロールし、またどのトランザクションをブロックに含めるかをもコントロールします。これによって、トランザクションを除外するまたは二重使用トランザクションを含められるパワーをマイニングプールオペレータに与えることになるのです。もしパワーのこのような悪用が制限された形または微妙な形で実行されれば、おそらく気づかれることなくマイニングプールオペレータはコンセンサス攻撃から利益を上げることができるでしょう。

Not all attackers will be motivated by profit, however. One potential attack scenario is where an attacker intends to disrupt the bitcoin network without the possibility of profiting from such disruption. A malicious attack aimed at crippling bitcoin would require enormous investment and covert planning, but could conceivably be launched by a well-funded, most likely state-sponsored, attacker. Alternatively, a well-funded attacker could attack bitcoin's consensus by simultaneously amassing mining hardware, compromising pool operators and attacking other pools with denial-of-service. All of these scenarios are theoretically possible, but increasingly impractical as the bitcoin network's overall hashing power continues to grow exponentially. 

しかし、全ての攻撃者が利益に動機づけられているわけではありません。一つのありえる攻撃シナリオとして、攻撃者がBitcoinネットワークを破壊するつもりで攻撃を行うこともあります。このような破壊から利益を上げられる可能性がなかったとしても。Bitcoinに大きな損害を与えることを目指している悪意ある攻撃には莫大な投資や密かな計画が必要です。しかし、おそらく州が支援しているような資金が十分にある攻撃者によって開始されるはずです。???? あるいは、資金が十分にある攻撃者であれば、マイニングハードウェアを大量に集め、マイニングプールオペレータに歩み寄って他のマイニングプールに対してDOS攻撃を仕掛けることでBitcoinのコンセンサスメカニズムを攻撃するはずです。???? これらのシナリオは全て理論的には可能ですが、Bitcoinネットワークの全体的なハッシングパワーが指数関数的に成長し続けているためだんだんと非実用的になっています。

Undoubtedly, a serious consensus attack would erode confidence in bitcoin in the short term, possibly causing a significant price decline. However, the bitcoin network and software are constantly evolving, so consensus attacks would be met with immediate countermeasures by the bitcoin community, making bitcoin hardier, stealthier, and more robust than ever.(((range="endofrange", startref="ix_ch08-asciidoc29")))(((range="endofrange", startref="ix_ch08-asciidoc28")))(((range="endofrange", startref="ix_ch08-asciidoc1")))(((range="endofrange", startref="ix_ch08-asciidoc0")))

確かに、深刻なコンセンサス攻撃は短期間にBitcoinに対する信頼を腐食し、もしかすると深刻な価格衰退を招くかもしれません。しかし、Bitcoinネットワークとソフトウェアは一定速度で発展しており、コンセンサス攻撃に対してすぐにBitcoinコミュニティーによって対応策が取られ、Bitcoinは今までより、より強力に、より匿名性が高く、より頑強になっていくことでしょう。(((range="endofrange", startref="ix_ch08-asciidoc29")))(((range="endofrange", startref="ix_ch08-asciidoc28")))(((range="endofrange", startref="ix_ch08-asciidoc1")))(((range="endofrange", startref="ix_ch08-asciidoc0")))



[[ch5]]
[[transactions]]
== Transactions
== トランザクション

[[ch5_intro]]
=== Introduction
=== イントロダクション

((("transactions", id="ix_ch05-asciidoc0", range="startofrange")))Transactions are the most important part of the bitcoin system. Everything else in bitcoin is designed to ensure that transactions can be created, propagated on the network, validated, and finally added to the global ledger of transactions (the blockchain). Transactions are data structures that encode the transfer of value between participants in the bitcoin system. Each transaction is a public entry in bitcoin's blockchain, the global double-entry bookkeeping ledger. 

((("transactions", id="ix_ch05-asciidoc0", range="startofrange")))トランザクションはBitcoinシステムの中で最も重要な部分です。Bitcoinのそれ以外のものは、トランザクションが作成され、Bitcoinネットワークを伝搬し、検証そして最後にグローバルなトランザクション元帳(ブロックチェーン)に追加されるという流れを支えるように作られています。トランザクションはBitcoinシステム参加者間での価値の転送をデジタル化したデータの集合体です。それぞれのトランザクションはBitcoinのブロックチェーン(グローバルな複式簿記元帳)の中にある誰でも見ることができる取引です。

In this chapter we will examine all the various forms of transactions, what they contain, how to create them, how they are verified, and how they become part of the permanent record of all transactions. 

この章では、いろいろな形式のトランザクションや、トランザクションは何を含んでいるのか、トランザクションはどのように作られるのか、またどのように検証されるのか、どのように永続的な記録の一部になるのか、ということを説明していきます。

[[tx_lifecycle]]
=== Transaction Lifecycle
=== トランザクションのライフサイクル

((("transactions","lifecycle of", id="ix_ch05-asciidoc1", range="startofrange")))A transaction's lifecycle starts with the transaction's creation, also known as((("origination of transactions"))) _origination_. The transaction is then signed with one or more signatures indicating the authorization to spend the funds referenced by the transaction. The transaction is then broadcast on the bitcoin network, where each network node (participant) validates and propagates the transaction until it reaches (almost) every node in the network. Finally, the transaction is verified by a mining node and included in a block of transactions that is recorded on the blockchain. 

((("transactions","lifecycle of", id="ix_ch05-asciidoc1", range="startofrange")))トランザクションのライフサイクルはまず s((("origination of transactions"))) _origination_ と呼ばれるトランザクションの生成から始まります。このときトランザクションは１つまたは複数の署名で署名されます。これら署名はトランザクションによって参照されている資金を使う許可を意味します。署名後にトランザクションはBitcoinネットワークにブロードキャストされます。それぞれのネットワークノード(Bitcoinネットワークへの参加者)はトランザクションを確認し、(ほぼ)全てのノードに行き渡るまでトランザクションがどんどんBitcoinネットワーク内を伝搬していきます。最後に、トランザクションはマイニングノードによって検証され、ブロックチェーンの中のブロックに記録されます。

Once recorded on the blockchain and confirmed by sufficient subsequent blocks (confirmations), the transaction is a permanent part of the bitcoin ledger and is accepted as valid by all participants. The funds allocated to a new owner by the transaction can then be spent in a new transaction, extending the chain of ownership and beginning the lifecycle of a transaction again. 

一度ブロックチェーンに記録され十分なブロックによって確認される(confirmation)と、トランザクションはBitcoin元帳の永続的な一部となり、全ての参加者によって有効なものとして受け入れられます。トランザクションによって新しい所有者に割り当てられた資金は新しいトランザクションの中で使用することができ、所有者の連鎖を拡げて再びトランザクションのライフサイクルが始まることになります。

[[tx_origination]]
==== Creating Transactions
==== トランザクションの生成

((("transactions","creating")))In some ways it helps to think of a transaction in the same way as a paper check. Like a check, a transaction is an instrument that expresses the intent to transfer money and is not visible to the financial system until it is submitted for execution. Like a check, the originator of the transaction does not have to be the one signing the transaction. 

((("transactions","creating")))小切手と同じやり方を使ってトランザクションを考えてみると考えやすいです。小切手と同じように、トランザクションはお金を転送するという意思を表す道具で、実際に使われるまで目に見える形にはなりません。また小切手と同じように、トランザクションの発行人はトランザクションに署名している人である必要はありません。

Transactions can be created online or offline by anyone, even if the person creating the transaction is not an authorized signer on the account. For example, an accounts payable clerk might process payable checks for signature by the CEO. Similarly, an accounts payable clerk can create bitcoin transactions and then have the CEO apply digital signatures to make them valid. Whereas a check references a specific account as the source of the funds, a bitcoin transaction references a specific previous transaction as its source, rather than an account. 

仮にトランザクションを作った人が口座の正規署名者でなかったとしてもトランザクションは誰かによってオンラインまたはオフラインで作ることができます。例えば、口座へのアクセス権を持った事務員はCEOによる署名が入った小切手を作ることができ、同様に口座へのアクセス権を持った事務員はBitcoinトランザクションを作ることができ、トランザクションを有効にするデジタル署名をトランザクションに適用することができます。小切手は資金がある特定の口座を参照している一方、Bitcoinトランザクションは口座ではなく１つ前のトランザクションを参照することになります。

Once a transaction has been created, it is signed by the owner (or owners) of the source funds. If it is properly formed and signed, the signed transaction is now valid and contains all the information needed to execute the transfer of funds. Finally, the valid transaction has to reach the bitcoin network so that it can be propagated until it reaches a miner for inclusion in the pubic ledger (the blockchain).

トランザクションが一度作られると、資金の所有者(または所有者たち)によって署名されます。もし正規の形式を保持しつつ署名されていれば、署名されたトランザクションは有効になり資金の転送を実行するために必要な全ての情報を含んでいることになります。最終的に、有効なトランザクションはBitcoinネットワークを伝搬していき、マイナーによって公的な元帳(ブロックチェーン)に格納されます。

[[tx_bcast]]
==== Broadcasting Transactions to the Bitcoin Network
==== Bitcoinネットワークへのトランザクションのブロードキャスト

((("bitcoin network","broadcasting transactions to")))((("transactions","broadcasting to network")))First, a transaction needs to be delivered to the bitcoin network so that it can be propagated and included in the blockchain. In essence, a bitcoin transaction is just 300 to 400 bytes of data and has to reach any one of tens of thousands of bitcoin nodes. The senders do not need to trust the nodes they use to broadcast the transaction, as long as they use more than one to ensure that it propagates. The nodes don't need to trust the sender or establish the sender's "identity." Because the transaction is signed and contains no confidential information, private keys, or credentials, it can be publicly broadcast using any underlying network transport that is convenient. Unlike credit card transactions, for example, which contain sensitive information and can only be transmitted on encrypted networks, a bitcoin transaction can be sent over any network. As long as the transaction can reach a bitcoin node that will propagate it into the bitcoin network, it doesn't matter how it is transported to the first node. 

((("bitcoin network","broadcasting transactions to")))((("transactions","broadcasting to network")))最初に、トランザクションはブロックチェーンに記録されるためにBitcoinネットワークに放出される必要があります。Bitcoinトランザクションは300から400バイトのデータを持ち、数万ものBitcoinノードのいずれか１つに辿り着かなければいけません。２つ以上のBitcoinノードにブロードキャストするため、送信者はBitcoinノードを信用する必要はありません。ノードは送信者を信用する必要はなく、また送信者が誰なのかを特定する必要もありません。トランザクションは署名されており、また一切の機密情報(秘密鍵や証明書)も含まれていないため、公にブロードキャストするためにいかなる転送手段を使っても構いません。例えば、センシティブな情報が含まれているため暗号化されたネットワークでしかデータの転送ができないクレジットカードのトランザクションと違って、Bitcoinのトランザクションはいかなるネットワークを通してでも送ることができます。トランザクションがBitcoinノードにたどり着くことができるのであれば、最初の転送方法はどうでもよいのです。

((("insecure networks, transmitting bitcoin over")))Bitcoin transactions can therefore be transmitted to the bitcoin network over insecure networks such as WiFi, Bluetooth, NFC, Chirp, barcodes, or by copying and pasting into a web form. In extreme cases, a bitcoin transaction could be transmitted over packet radio, satellite relay, or shortwave using burst transmission, spread spectrum, or frequency hopping to evade detection and jamming. A bitcoin transaction could even be encoded as smileys (emoticons) and posted in a public forum or sent as a text message or Skype chat message. Bitcoin has turned money into a data structure, making it virtually impossible to stop anyone from creating and executing a bitcoin transaction. 

((("insecure networks, transmitting bitcoin over")))このため、BitcoinトランザクションはWiFiやBlutooth、NFC、Chirp、バーコード、Bitcoinアドレスのウェブフォームへのコピペのような安全でないネットワークを通してでも転送することができます。安全でない極端な場合として、パケット通信や衛星中継、バースト転送を用いた短波通信、周波数ホッピングなどのスペクトラム拡散などがあります。Bitcoinトランザクションは、絵文字としてでさえ表現でき、公的なフォーラムへの投稿、またテキストメッセージ、Skypeチャットメッセージとして送ることもできます。Bitcoinはお金をデータの形に変え、これにより誰もトランザクションを作成や実行を阻止できないようにしたのです。

[[tx_propagation]]
==== Propagating Transactions on the Bitcoin Network
==== Bitcoinネットワーク上でのトランザクションの伝搬

((("bitcoin network","propagating transactions on")))((("transactions","propagating")))Once a bitcoin transaction is sent to any node connected to the bitcoin network, the transaction will be validated by that node. If valid, that node will propagate it to the other nodes to which it is connected, and a success message will be returned synchronously to the originator. If the transaction is invalid, the node will reject it and synchronously return a rejection message to the originator. 

((("bitcoin network","propagating transactions on")))((("transactions","propagating")))一度BitcoinトランザクションがBitcoinネットワークに接続されたノードに送られると、このトランザクションは送られたノードで有効なものか検証されます。有効なものだと確認されると、そのノードは接続している他のノードにこのトランザクションを伝搬します。同時に、成功メッセージが発行ノードに返却されます。もしこのトランザクションが無効なものであればノードはこのトランザクションを棄却し、同時に棄却メッセージを発行ノードに返却します。

The bitcoin network is a peer-to-peer network, meaning that each bitcoin node is connected to a few other bitcoin nodes that it discovers during startup through the peer-to-peer protocol. The entire network forms a loosely connected mesh without a fixed topology or any structure, making all nodes equal peers. Messages, including transactions and blocks, are propagated from each node to all the peers to which it is connected, a process called "flooding." A new validated transaction injected into any node on the network will be sent to all of the nodes connected to it (neighbors), each of which will send the transaction to all its neighbors, and so on. In this way, within a few seconds a valid transaction will propagate in an exponentially expanding ripple across the network until all nodes in the network have received it. 

Bitcoinネットワークはpeer-to-peerネットワークであり、それぞれのBitcoinノードは数個のノードに接続されています。この数個のノードはpeer-to-peerプロトコルに従ってノードを起動したときに発見したノードです。全Bitcoinネットワークは緩やかに接続されたメッシュであり、固定されたトポロジーや構造を持つことなく全てのノードは平等に扱われます。トランザクションやブロックを含んだメッセージはそれぞれのノードから接続されている他のピアに伝搬します。このプロセスは"flooding"と呼ばれています。有効だと確認された新しいトランザクションは接続された全てのノード(隣接ノード)に送られ、それぞれの隣接ノードはまた全ての隣接ノードにこのトランザクションを送ります。このような方法で、全ての接続されたノードがこのトランザクションを受け取るまで波紋のようにBitcoinネットワーク内を伝わっていき数秒以内に全体に広がっていきます。

The bitcoin network is designed to propagate transactions and blocks to all nodes in an efficient and resilient manner that is resistant to attacks. To prevent spamming, denial-of-service attacks, or other nuisance attacks against the bitcoin system, every node independently validates every transaction before propagating it further. A malformed transaction will not get beyond one node. The rules by which transactions are validated are explained in more detail in <<tx_verification>>.(((range="endofrange", startref="ix_ch05-asciidoc1"))) 

Bitcoinネットワークは、攻撃に強く、また効率的なルールに従って全てのノードにトランザクションとブロックを伝搬できるように設計されています。Bitcoinシステムにとって厄介なDOS攻撃のような強制的なデータの送りつけを防ぐために、全てのノードはトランザクションを次のノードに送る前に全てのトランザクションが有効なものか確認しています。このため、おかしなトランザクションが次のノードに送られることはありません。この方法について<<tx_verification>>で詳細に説明します。(((range="endofrange", startref="ix_ch05-asciidoc1")))

[[tx_structure]]
=== Transaction Structure
=== トランザクションの構造

((("transactions","structure of")))A transaction is a((("data structure"))) _data structure_ that encodes a transfer of value from a source of funds, called an((("inputs, defined"))) _input_, to a destination, called an((("outputs, defined"))) _output_. Transaction inputs and outputs are not related to accounts or identities. Instead, you should think of them as bitcoin amounts—chunks of bitcoin—being locked with a specific secret that only the owner, or person who knows the secret, can unlock. A transaction contains a number of fields, as shown in <<tx_data_structure>>.

((("transactions","structure of")))トランザクションは、資金源( _インプット_ と呼ばれる)から送り先( _アウトプット_ と呼ばれる)への価値の転送を記号化した ((("data structure"))) _データ構造_ です。トランザクションのインプットやアウトプットは、アカウントやIDなど、個人を特定できる情報と結びついているわけではありません。代わりに、これらを所有者だけがもっている秘密鍵でロックされているbitcoinの固まりとして考えるべきです。トランザクションは<<tx_data_structure>>に示すようないくつかのフィールドを含んでいます。

[[tx_data_structure]]
.The structure of a transaction
.トランザクションの構造
[options="header"]
|=======
|Size| Field | Description
| 4 bytes | Version | Specifies which rules this transaction follows
| 1–9 bytes (VarInt) | Input Counter | How many inputs are included
| Variable | Inputs | One or more transaction inputs
| 1–9 bytes (VarInt) | Output Counter | How many outputs are included
| Variable | Outputs | One or more transaction outputs
| 4 bytes | Locktime | A Unix timestamp or block number
| 4 bytes | Version | このトランザクションがどのルールに従っているかを指定
| 1–9 bytes (VarInt) | Input Counter | いくつのインプットが含まれているか
| Variable | Inputs | １つまたは複数のトランザクションインプット
| 1–9 bytes (VarInt) | Output Counter | いくつのアウトプットが含まれているか
| Variable | Outputs | １つまたは複数のトランザクションアウトプット
| 4 bytes | Locktime | Unixタイムスタンプ、またはブロック高
|=======

.Transaction Locktime
****

((("locktime")))((("transactions","locktime")))Locktime, also known as nLockTime from the variable name used in the reference client, defines the earliest time that a transaction is valid and can be relayed on the network or added to the blockchain. It is set to zero in most transactions to indicate immediate propagation and execution. If locktime is nonzero and below 500 million, it is interpreted as a block height, meaning the transaction is not valid and is not relayed or included in the blockchain prior to the specified block height. If it is above 500 million, it is interpreted as a Unix Epoch timestamp (seconds since Jan-1-1970) and the transaction is not valid prior to the specified time. Transactions with locktime specifying a future block or time must be held by the originating system and transmitted to the bitcoin network only after they become valid. The use of locktime is equivalent to postdating a paper check.

((("locktime")))((("transactions","locktime")))locktimeはトランザクションが検証されたり、Bitcoinネットワーク内でリレーされたり、またブロックチェーンに追加されたりした最も早い時刻です。これは、参照実装であるBitcoin Coreの中でnLockTimeとしても知られていたものです。ほとんどのトランザクションではすぐに伝搬されたことを表すためにlocktimeが0に設定されます。もしlocktimeが0でないかまたは５億より下になっているときはlocktimeをブロック高として解釈し、このブロック高より前のブロックではこのトランザクションがブロックチェーンに取り込まれていないということを意味します。もし５億よりも大きいときはlocktimeをUNIX Epochタイムスタンプ(1970/1/1からの秒数)として解釈し、この時刻よりも前にこのトランザクションが有効ではなかったということを意味します。locktimeが将来のブロックまたは時刻になっている場合は発行システムによってトランザクションが保持されていなければならず、トランザクションが有効になってからのみBitcoinネットワークに送信されなければいけません。locktimeは先日付小切手の日付のようなものです。
****

[[tx_inputs_outputs]]
=== Transaction Outputs and Inputs
=== トランザクションアウトプットとインプット

((("transactions","unspent transaction output (UTXO)")))((("unspent transaction output (UTXO)")))The fundamental building block of a bitcoin transaction is an _unspent transaction output_, or UTXO. UTXO are indivisible chunks of bitcoin currency locked to a specific owner, recorded on the blockchain, and recognized as currency units by the entire network. The bitcoin network tracks all available (unspent) UTXO currently numbering in the millions. Whenever a user receives bitcoin, that amount is recorded within the blockchain as a UTXO. Thus, a user's bitcoin might be scattered as UTXO amongst hundreds of transactions and hundreds of blocks. In effect, there is no such thing as a stored balance of a bitcoin address or account; there are only scattered UTXO, locked to specific owners. The concept of a user's bitcoin balance is a derived construct created by the wallet application. The wallet calculates the user's balance by scanning the blockchain and aggregating all UTXO belonging to that user.

((("transactions","unspent transaction output (UTXO)")))((("unspent transaction output (UTXO)")))Bitcoinトランザクションの基本的な構成要素は、 _未使用トランザクションアウトプット_ または UTXO(unspent transaction output)です。UTXOは、特定の所有者にロックされた分割不可能なbitcoinの固まりで、ブロックチェーンに記録されており、Bitcoinネットワーク全体によって通貨の単位として捉えられているものです。Bitcoinネットワークは全ての利用可能(未使用)なUTXOを追跡しており、現在数百万に達するほどの量があります。ユーザがbitcoinを受け取るときはいつでも、UTXOとしてブロックチェーンに記録されます。このため、ユーザのbitcoinは数百個のトランザクションまたは数百個のブロックの中にUTXOとして散り散りな状態になってしまっているかもしれません。事実上、Bitcoinアドレスまたは口座の残高として記録されている訳ではないのです。あるのはただ散り散りになり特定の所有者に利用が制限されたUTXOだけです。ユーザのbitcoin残高という概念は、ウォレットによって作り上げられたものにすぎません。ウォレットはブロックチェーンをスキャンしてユーザに属している全てのUTXOを掻き集め残高を計算しているのです。

[TIP]
====
((("accounts")))((("balances")))There are no accounts or balances in bitcoin; there are only _unspent transaction outputs_ (UTXO) scattered in the blockchain. 

((("accounts")))((("balances")))Bitcoinに口座も残高もありません。あるのは単にブロックチェーンの中に散らばった _未使用トランザクションアウトプット_ (UTXO)だけです。
====

A UTXO can have an arbitrary value denominated as a multiple of((("satoshis"))) satoshis.  Just like dollars can be divided down to two decimal places as cents, bitcoins can be divided down to eight decimal places as satoshis. Although UTXO can be any arbitrary value, once created it is indivisible just like a coin that cannot be cut in half. If a UTXO is larger than the desired value of a transaction, it must still be consumed in its entirety and change must be generated in the transaction. ((("change, making")))In other words, if you have a 20 bitcoin UTXO and want to pay 1 bitcoin, your transaction must consume the entire 20 bitcoin UTXO and produce two outputs: one paying 1 bitcoin to your desired recipient and another paying 19 bitcoin in change back to your wallet. As a result, most bitcoin transactions will generate change. 

UTXOは ((("satoshis"))) satoshi を単位とした任意の値を持つことができます。ドルがセントというさらに下の２桁の十進数を持つように、bitcoinはsatoshiという８桁の十進数を持ちます。UTXOは任意の値ですが、一度作られるとコインのように２つに切ることができません。((("change, making"))) 別の言い方をすると、もし20bitcoinのUTXOを持っていて1bitcoinだけ使いたいとすると、トランザクションは20bitcoinのUTXOを消費しなければならないため２つのアウトプットを作らなければいけません。１つは支払った1bitcoin、もう１つはあなたのウォレットに戻ってくるおつりの19bitcoinです。結果として、ほぼ多くのBitcoinトランザクションはおつりを生成します。

Imagine a shopper buying a $1.50 beverage, reaching into her wallet and trying to find a combination of coins and bank notes to cover the $1.50 cost. The shopper will choose exact change if available (a dollar bill and two quarters), or a combination of smaller denominations (six quarters), or if necessary, a larger unit such as a five dollar bank note. If she hands too much money, say $5, to the shop owner, she will expect $3.50 change, which she will return to her wallet and have available for future transactions.

$1.50の飲み物を買う人を想像してみましょう。彼女の財布から$1.50になるコインと紙幣の組み合わせを探しだします。もし財布にあるならおつりのいらないちょうどの金額(1ドル札と2つの25セントコイン、または6つの25セントコイン)、無理であれば５ドル札のような大きな単位の紙幣を選びます。もし多くのお金を持っているとすると、$5をショップオーナーに支払い$3.50のおつりを期待します。彼女はこの$3.50を財布に戻し、将来の買い物のときに使うことができます。

Similarly, a bitcoin transaction must be created from a user's UTXO in whatever denominations that user has available. Users cannot cut a UTXO in half any more than they can cut a dollar bill in half and use it as currency. The user's wallet application will typically select from the user's available UTXO various units to compose an amount greater than or equal to the desired transaction amount. 

同様に、Bitcoinトランザクションはユーザが使用可能なUTXOから作られます。ユーザはUTXOを半分に割ることはできません。ウォレットは通常ユーザの利用可能なUTXOを選び、トランザクションに必要な金額以上になるように組み合わせます。

As with real life, the bitcoin application can use several strategies to satisfy the purchase amount: combining several smaller units, finding exact change, or using a single unit larger than the transaction value and making change. All of this complex assembly of spendable UTXO is done by the user's wallet automatically and is invisible to users. It is only relevant if you are programmatically constructing raw transactions from UTXO. 

実用上は、Bitcoinアプリケーションは購入額を満たすためにいくつかのやり方を使うことができます。いくつかのより小さい単位の額を組み合わせる、おつりがないようなきっちりした金額を選ぶ、またはトランザクションに必要な金額より大きい額を使っておつりを作るなどです。このやり方はウォレットのほうで自動的に実行され、ユーザには見えないようになっています。関係してくるとしたら、生トランザクションをUTXOからプログラムを通して手で構成する場合だけです。

The UTXO consumed by a transaction are called transaction inputs, and the UTXO created by a transaction are called transaction outputs. This way, chunks of bitcoin value move forward from owner to owner in a chain of transactions consuming and creating UTXO. Transactions consume UTXO by unlocking it with the signature of the current owner and create UTXO by locking it to the bitcoin address of the new owner. 

トランザクションによって消費されたUTXOはトランザクションインプットと呼ばれ、トランザクションによって作られたUTXOをトランザクションアウトプットと呼びます。UTXOを消費したまたは作成したトランザクションの中で、bitcoinの固まりはある所有者からある所有者に移っていきます。トランザクションは現在の所有者の署名を使って解錠されることでUTXOを消費します。

The exception to the output and input chain is a special type of transaction called the _coinbase_ transaction, which is the first transaction in each block. This transaction is placed there by the "winning" miner and creates brand-new bitcoin payable to that miner as a reward for mining. This is how bitcoin's money supply is created during the mining process, as we will see in <<ch8>>.

インプットとアウトプットの連鎖の例外は、 _coinbase_ トランザクションと呼ばれる特殊なトランザクションです。これは、それぞれのブロックの一番最初のトランザクションです。このトランザクションは採掘に"勝った"マイナーによってブロックの一番最初に置かれ、マイニングに対する報酬としてマイナーにbitcoinが支払われるトランザクションとなります。<<ch8>>で説明するように、このようにしてマイニングプロセスを通してBitcoinのお金が供給されていきます。

[TIP]
====
What comes first? Inputs or outputs, the chicken or the egg? Strictly speaking, outputs come first because coinbase transactions, which generate new bitcoin, have no inputs and create outputs from nothing. 

最初に何が来るでしょうか？インプットそれともアウトプット、鶏それとも卵？厳密に言って、アウトプットが最初に来ます。なぜなら、新しいbitcoinを生成するcoinbaseトランザクションはインプットを持っておらず、何もないところからアウトプットを作るからです。
====

[[tx_outs]]
==== Transaction Outputs
==== トランザクションアウトプット

((("bitcoin ledger, outputs in", id="ix_ch05-asciidoc2", range="startofrange")))((("transactions","outputs", id="ix_ch05-asciidoc3", range="startofrange")))((("unspent transaction output (UTXO)", id="ix_ch05-asciidoc4", range="startofrange")))Every bitcoin transaction creates outputs, which are recorded on the bitcoin ledger. Almost all of these outputs, with one exception (see <<op_return>>) create spendable chunks of bitcoin called _unspent transaction outputs_ or UTXO, which are then recognized by the whole network and available for the owner to spend in a future transaction. Sending someone bitcoin is creating an unspent transaction output (UTXO) registered to their address and available for them to spend.

((("bitcoin ledger, outputs in", id="ix_ch05-asciidoc2", range="startofrange")))((("transactions","outputs", id="ix_ch05-asciidoc3", range="startofrange")))((("unspent transaction output (UTXO)", id="ix_ch05-asciidoc4", range="startofrange")))全てのBitcoinトランザクションはアウトプットを作ります。このアウトプットはBitcoin元帳上に記録され、ほとんど全てのアウトプット(１つの例外を除いて。<<op_return>>参照)は、 _未使用トランザクションアウトプット_ またはUTXOと呼ばれる使用可能なbitcoinの固まりを作ります。UTXOはBitcoinネットワーク全体によって認識されており、所有者が将来の取引でこれを使うことができます。誰かにbitcoinを送ることは、送り先のBitcoinアドレスと紐づけられた未使用トランザクションアウトプット(UTXO)を作り出すことです。このUTXOは受信者が使うことが可能なトランザクションアウトプットです。

UTXO are tracked by every full-node bitcoin client as a data set called the((("UTXO pool")))((("UTXO set"))) _UTXO set_ or _UTXO pool_, held in a database. New transactions consume (spend) one or more of these outputs from the UTXO set. 

UTXOは全てのfull-node Bitcoinクライアントによって追跡され、((("UTXO pool")))((("UTXO set"))) _UTXOセット_ または _UTXOプール_ と呼ばれるメモリに持っているデータベースで管理されています。そして、新しいトランザクションはUTXOセットにある１つまたは複数のアウトプットを消費(使用)することになります。

Transaction outputs consist of two parts: 

トランザクションアウトプットは以下２つの部分で成り立っています。

* An amount of bitcoin, denominated in _satoshis_, the smallest bitcoin unit
* A((("encumbrance")))((("locking scripts"))) _locking script_, also known as an "encumbrance" that "locks" this amount by specifying the conditions that must be met to spend the output

* bitcoinの最小単位である _satoshi_ 単位で表されたbitcoin金額
* アウトプットと使用するにあたって満たさなければいけない条件である"解除条件"として知られている ((("encumbrance")))((("locking scripts"))) _locking script_

The transaction scripting language, used in the locking script mentioned previously, is discussed in detail in <<tx_script>>. <<tx_out_structure>> shows the structure of a transaction output.

locing scriptの中で使われているトランザクションスクリプト言語の詳細については<<tx_script>>で説明します。<<tx_out_structure>>はトランザクションアウトプットの構造を示しています。

[[tx_out_structure]]
.The structure of a transaction output
.トランザクションアウトプットの構造
[options="header"]
|=======
|Size| Field | Description
| 8 bytes | Amount | Bitcoin value in satoshis (10^-8^ bitcoin)
| 1-9 bytes (VarInt) | Locking-Script Size | Locking-Script length in bytes, to follow
| Variable | Locking-Script | A script defining the conditions needed to spend the output
| 8 bytes | Amount | satoshi単位(10^-8^ bitcoin)のbitcoin額
| 1-9 bytes (VarInt) | Locking-Script Size | 次に続くlocking scriptのバイト長
| Variable | Locking-Script | アウトプットを使用するために必要な条件を定義したscript
|=======

In <<get_utxo>>, we use the blockchain.info API to find the unspent outputs (UTXO) of a specific address.

<<get_utxo>>でblockchain.info APIを使って特定のBitcoinアドレスの未使用アウトプット(UTXO)を調べています。

[[get_utxo]]
.A script that calls the blockchain.info API to find the UTXO related to an address
.あるBitcoinアドレスに関連したUTXOを見つけ出す blockchain.info APIを呼び出すスクリプト
====
[source, python]
----
include::code/get-utxo.py[]
----
====

Running the script, we see a list of transaction IDs, a colon, the index number of the specific unspent transaction output (UTXO), and the value of that UTXO in satoshis. The locking script is not shown in the output in <<get_utxo_run>>.

このスクリプトを実行すると、"トランザクションID":"特定の未使用トランザクションアウトプット(UTXO)のインデックス" - "UTXOの satoshi 単位での金額" という形のリストが表示されます。<<get_utxo_run>>のアウトプットにlocking scriptは表示されていません。

[[get_utxo_run]]
.Running the get-utxo.py script
.get-utxo.py スクリプトの実行
====
[source,bash]
----
$ python get-utxo.py 
ebadfaa92f1fd29e2fe296eda702c48bd11ffd52313e986e99ddad9084062167:1 - 8000000 Satoshis
6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf:0 - 16050000 Satoshis
74d788804e2aae10891d72753d1520da1206e6f4f20481cc1555b7f2cb44aca0:0 - 5000000 Satoshis
b2affea89ff82557c60d635a2a3137b8f88f12ecec85082f7d0a1f82ee203ac4:0 - 10000000 Satoshis
...
----
====

===== Spending conditions (encumbrances)
===== 使用条件(解除条件)

((("encumbrance")))((("locking scripts")))Transaction outputs associate a specific amount (in satoshis) to a specific _encumbrance_ or locking script that defines the condition that must be met to spend that amount. In most cases, the locking script will lock the output to a specific bitcoin address, thereby transferring ownership of that amount to the new owner. When Alice paid Bob's Cafe for a cup of coffee, her transaction created a 0.015 bitcoin output _encumbered_ or locked to the cafe's bitcoin address. That 0.015 bitcoin output was recorded on the blockchain and became part of the Unspent Transaction Output set, meaning it showed in Bob's wallet as part of the available balance. When Bob chooses to spend that amount, his transaction will release the encumbrance, unlocking the output by providing an unlocking script containing a signature from Bob's private key.(((range="endofrange", startref="ix_ch05-asciidoc4")))(((range="endofrange", startref="ix_ch05-asciidoc3")))(((range="endofrange", startref="ix_ch05-asciidoc2"))) 

((("encumbrance")))((("locking scripts")))トランザクションアウトプットはbitcoin(satoshi単位で表された)を、特定の _解除条件_ またはbitcoinを使うにあたって満たさなければいけない条件を定義したlocking scriptと関連づけています。多くの場合、locking scriptは特定のBitcoinアドレスにアウトプットをロックし、これにより所有権が新しい所有者に移ります。アリスがボブのカフェにコーヒー代を支払ったとき、彼女のトランザクションにはカフェのBitcoinアドレスにロックされた0.015bitcoinアウトプットが含まれていました。この0.015bitcoinアウトプットはブロックチェーンに記録され、カフェのBitcoinアドレスに紐づいた未使用トランザクションアウトプットセットの一部になったのです。ボブがこの0.015bitcoinアウトプットを支払いに使うことにしたときに、彼のトランザクションはボブの秘密鍵による署名を含むunlocking scriptを提示することでこの0.015bitcoinアウトプットのロックを外すのです。(((range="endofrange", startref="ix_ch05-asciidoc4")))(((range="endofrange", startref="ix_ch05-asciidoc3")))(((range="endofrange", startref="ix_ch05-asciidoc2")))

[[tx_inputs]]
==== Transaction Inputs
==== トランザクションインプット

((("transactions","inputs", id="ix_ch05-asciidoc5", range="startofrange")))In simple terms, transaction inputs are pointers to UTXO. They point to a specific UTXO by reference to the transaction hash and sequence number where the UTXO is recorded in the blockchain. To spend UTXO, a transaction input also includes unlocking scripts that satisfy the spending conditions set by the UTXO. The unlocking script is usually a signature proving ownership of the bitcoin address that is in the locking script. 

((("transactions","inputs", id="ix_ch05-asciidoc5", range="startofrange")))簡単に言って、トランザクションインプットはUTXOへのポインタです。トランザクションインプットは、トランザクションハッシュとUTXOが記録されているブロックチェーン内の場所を示すシーケンス番号を使って特定のUTXOを指定します。UTXOを使うために、トランザクションインプットはunlocking scriptというUTXOのロックを解除するscriptも持っています。unlocking scriptは通常locking scriptの中にあるBitcoinアドレスの所有権を証明している署名です。

When users make a payment, their wallet constructs a transaction by selecting from the available UTXO. For example, to make a 0.015 bitcoin payment, the wallet app may select a 0.01 UTXO and a 0.005 UTXO, using them both to add up to the desired payment amount. 

ユーザが支払いをするとき、ウォレットは使用可能なUTXOを選びトランザクションを構成します。例えば、0.015bitcoinの支払いをするのであれば、ウォレットは0.01bitcoinのUTXOと0.005bitcoinのUTXOを選び支払いに必要な金額になるようにするかもしれません。

In <<select_utxo>>, we show the use of a "greedy" algorithm to select from available UTXO in order to make a specific payment amount. In the example, the available UTXO are provided as a constant array, but in reality, the available UTXO would be retrieved with an RPC call to Bitcoin Core, or to a third-party API as shown in <<get_utxo>>. 

<<select_utxo>>では"貪欲(greedy)"アルゴリズムを使うことである金額を満たすように使用可能なUTXOを選ぶ例を示しています。この例では、使用可能なUTXOをあらかじめ決められた配列で与えています。しかし、現実では、使用可能なUTXOはBitcoin CoreのRPC APIを使って集めてくるか、または<<get_utxo>>にあるようなサードパーティAPIを使って集めてきます。

[[select_utxo]]
.A script for calculating how much total bitcoin will be issued
.支払いに総額いくらのbitcoinが必要となるかを計算するためのスクリプト
====
[source, python]
----
include::code/select-utxo.py[]
----
====

If we run the _select-utxo.py_ script without a parameter, it will attempt to construct a set of UTXO (and change) for a payment of 55,000,000 satoshis (0.55 bitcoin). If you provide a target payment amount as a parameter, the script will select UTXO to make that target payment amount. In <<select_utxo_run>>, we run the script trying to make a payment of 0.5 bitcoin or 50,000,000 satoshis.

もし _select-utxo.py_ スクリプトをパラメータなしで実行すると、55,000,000satoshi(0.55bitcoin)の支払いに対してUTXOの組み合わせ(とおつりも)を構成しようとします。パラメータとして支払額を指定すると、スクリプトは指定した支払額を満たすようにUTXOを選びます。<<select_utxo_run>>では、0.5bitcoinまたは50,000,000satoshiの支払い額を指定してスクリプトを実行しています。

[[select_utxo_run]]
.Running the select-utxo.py script
.select-utxo.py スクリプトの実行
====
----
$ python select-utxo.py 50000000
For transaction amount 50000000 Satoshis (0.500000 bitcoin) use: 
([<7dbc497969c7475e45d952c4a872e213fb15d45e5cd3473c386a71a1b0c136a1:0 with 25000000 Satoshis>, <7f42eda67921ee92eae5f79bd37c68c9cb859b899ce70dba68c48338857b7818:0 with 16100000 Satoshis>, <6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf:0 with 16050000 Satoshis>], 'Change: 7150000 Satoshis')
----
====

Once the UTXO is selected, the wallet then produces unlocking scripts containing signatures for each of the UTXO, thereby making them spendable by satisfying their locking script conditions. The wallet adds these UTXO references and unlocking scripts as inputs to the transaction. <<tx_in_structure>> shows the structure of a transaction input. 

一度UTXOが選ばれると、ウォレットはそれぞれのUTXOに対して署名を含んでいるunlocking scriptを作ります。このunlocking scriptによってlocking scriptの条件を満たすためUTXOが使用可能になります。ウォレットはこれらのUTXOへの参照とunlocking scriptをインプットとしてトランザクションに追加します。<<tx_in_structure>>はトランザクションインプットの構造を示しています。

[[tx_in_structure]]
.The structure of a transaction input
.トランザクションインプットの構造
[options="header"]
|=======
|Size| Field | Description
| 32 bytes | Transaction Hash | Pointer to the transaction containing the UTXO to be spent
| 4 bytes | Output Index | The index number of the UTXO to be spent; first one is 0
| 1-9 bytes (VarInt) | Unlocking-Script Size | Unlocking-Script length in bytes, to follow
| Variable | Unlocking-Script | A script that fulfills the conditions of the UTXO locking script.
| 4 bytes | Sequence Number | Currently disabled Tx-replacement feature, set to 0xFFFFFFFF
| 32 bytes | Transaction Hash | 使われるUTXOを含むトランザクションハッシュ
| 4 bytes | Output Index | 使われるUTXOのトランザクション内インデックス、一番最初のアウトプットの場合は0
| 1-9 bytes (VarInt) | Unlocking-Script Size | unlocking-scriptのバイト長
| Variable | Unlocking-Script | UTXOのlocking scriptを満たすscript
| 4 bytes | Sequence Number | 現在トランザクション置き換えは使用不可になっている、 0xFFFFFFFF に設定
|=======

[NOTE]
====
The sequence number is used to override a transaction prior to the expiration of the transaction locktime, which is a feature that is currently disabled in bitcoin. Most transactions set this value to the maximum integer value (0xFFFFFFFF) and it is ignored by the bitcoin network. If the transaction has a nonzero locktime, at least one of its inputs must have a sequence number below 0xFFFFFFFF in order to enable locktime.(((range="endofrange", startref="ix_ch05-asciidoc5")))

sequence numberは、トランザクションのlocktimeが無効になる前にトランザクションを書き換えるために使われますが、現在この機能は使用不可になっています。ほとんどのトランザクションではこの値を整数最大値(0xFFFFFFFF)に設定し、この場合Bitcoinネットワークで無視されます。もしトランザクションが0ではないlocktimeを持っているとすると、少なくともこのトランザクションのインプットのうちの１つがlocktimeを有効にするために0xFFFFFFFFよりも小さいsequence numberを持たなければいけないのです。(((range="endofrange", startref="ix_ch05-asciidoc5")))
====

[[tx_fees]]
==== Transaction Fees
==== トランザクション手数料

((("fees, transaction", id="ix_ch05-asciidoc6", range="startofrange")))Most transactions include transaction fees, which compensate the bitcoin miners for securing the network. Mining and the fees and rewards collected by miners are discussed in more detail in <<ch8>>. This section examines how transaction fees are included in a typical transaction. Most wallets calculate and include transaction fees automatically. However, if you are constructing transactions programmatically, or using a command-line interface, you must manually account for and include these fees. 

((("fees, transaction", id="ix_ch05-asciidoc6", range="startofrange")))ほとんどのトランザクションはトランザクション手数料を含んでいて、この手数料はBitcoinマイナーに与えられます。マイニングと手数料、マイナーによって集められた報酬についての詳細は<<ch8>>で説明することにします。この節では、どのようにしてトランザクション手数料がトランザクションに含められるかを説明します。ほとんどのウォレットはトランザクション手数料を自動的に計算しトランザクションに含めます。しかし、もしトランザクションをプログラムを通して構築する、またはコマンドラインを使って構築する場合は、手動でこれらの手数料をトランザクションに含めなければいけません。
    
Transaction fees serve as an incentive to include (mine) a transaction into the next block and also as a disincentive against "spam" transactions or any kind of abuse of the system, by imposing a small cost on every transaction. Transaction fees are collected by the miner who mines the block that records the transaction on the blockchain. 

トランザクション手数料はトランザクションを次にブロックに含める(採掘する)ことのインセンティブとして働き、また少額でも手数料をトランザクションに入れなければいけないため"スパム"トランザクションやBitcoinシステムを悪用することに対する逆のインセンティブとして働きます。トランザクション手数料はブロックチェーン上にトランザクションを記録しているブロックを採掘したマイナーによって集められます。

((("fees, transaction","calculating")))Transaction fees are calculated based on the size of the transaction in kilobytes, not the value of the transaction in bitcoin. Overall, transaction fees are set based on market forces within the bitcoin network. Miners prioritize transactions based on many different criteria, including fees, and might even process transactions for free under certain circumstances. Transaction fees affect the processing priority, meaning that a transaction with sufficient fees is likely to be included in the next-most–mined block, whereas a transaction with insufficient or no fees might be delayed, processed on a best-effort basis after a few blocks, or not processed at all. Transaction fees are not mandatory, and transactions without fees might be processed eventually; however, including transaction fees encourages priority processing. 

((("fees, transaction","calculating")))トランザクション手数料はトランザクションのデータサイズ(KB)に基づいて計算され、いくらの支払いをしたかによって手数料は決まりません。トランザクション手数料はBitcoinネットワーク内での市場原理に基づいて決められます。マイナーごとにどのトランザクションを優先的に選ぶかの判断条件は違っており、この判断条件には手数料の大きさも含まれます。手数料が含まれていないトランザクションも状況によってはマイナーに選ばれるかもしれません。しかし、トランザクション手数料はマイナーによって処理される優先順位に影響し、十分な手数料をもっているトランザクションが次の頻繁にマイニングされているブロックに含まれる可能性が高くなり、一方十分な手数料を持っていないかまたは手数料がないトランザクションはブロックに取り込まれることが遅れてしまうか、もしく数ブロック後に取り込まれる、またはそもそも処理されないということになるかもしれません。トランザクション手数料は必須ではなく、ときどき手数料がないトランザクションもマイナーに処理されますが、トランザクション手数料を含めることは処理の優先順位をあげることに繋がるのです。

Over time, the way transaction fees are calculated and the effect they have on transaction prioritization has been evolving. At first, transaction fees were fixed and constant across the network. Gradually, the fee structure has been relaxed so that it may be influenced by market forces, based on network capacity and transaction volume. The current minimum transaction fee is fixed at 0.0001 bitcoin or a tenth of a milli-bitcoin per kilobyte, recently decreased from one milli-bitcoin. Most transactions are less than one kilobyte; however, those with multiple inputs or outputs can be larger. In future revisions of the bitcoin protocol, it is expected that wallet applications will use statistical analysis to calculate the most appropriate fee to attach to a transaction based on the average fees of recent transactions. 

時間とともに、トランザクション手数料の計算方法やトランザクションの優先順位付け方法が発展してきました。最初、トランザクション手数料は固定されており、Bitcoinネットワーク全体で一定でした。次第に手数料は緩和され、Bitcoinネットワークのキャパシティやトランザクション量に基づく市場の力関係にトランザクション手数料が影響されるようになってきました。現在の最小トランザクション手数料はトランザクションのデータサイズ1KBあたり0.0001bitcoin、10ミリbitcoinに固定されており、最近1ミリbitcoinに減らされました。多くのトランザクションは1KBより小さいですが、いくつかのインプットまたはアウトプットを持っているとより大きな手数料になります。Bitocinプロトコルの将来の改定で、ウォレットが最近のトランザクションの手数料平均値に基づき統計的に最適な手数料を決定できるようになると予想されています。

The current algorithm used by miners to prioritize transactions for inclusion in a block based on their fees is examined in detail in <<ch8>>.(((range="endofrange", startref="ix_ch05-asciidoc6")))

マイナーがトランザクションの優先順位付けをする際に使っている現在のアルゴリズムについては<<ch8>>で詳細に説明します。(((range="endofrange", startref="ix_ch05-asciidoc6")))
    
==== Adding Fees to Transactions
==== 手数料のトランザクションへの追加

((("fees, transaction","adding", id="ix_ch05-asciidoc7", range="startofrange")))((("transactions","fees", id="ix_ch05-asciidoc8", range="startofrange")))The data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs is the fee that is collected by the miners. 

((("fees, transaction","adding", id="ix_ch05-asciidoc7", range="startofrange")))((("transactions","fees", id="ix_ch05-asciidoc8", range="startofrange")))トランザクションのデータ構造には手数料に対するフィールドはありません。代わりに、手数料はインプットの総和とアウトプットの総和との差として暗に含められる形になっています。全てのインプットの総和から全てのアウトプットの総和を引いて残った余分な額がマイナーによって集められる手数料です。

[[tx_fee_equation]]
.Transaction fees are implied, as the excess of inputs minus outputs:
.トランザクション手数料はインプットとアウトプットの差として暗に含められています。
----
Fees = Sum(Inputs) – Sum(Outputs)
----

This is a somewhat confusing element of transactions and an important point to understand, because if you are constructing your own transactions you must ensure you do not inadvertently include a very large fee by underspending the inputs. That means that you must account for all inputs, if necessary by creating change, or you will end up giving the miners a very big tip!

これは、幾分トランザクションを理解する上で混乱してしまうところですが重要なポイントです。というのは、もし自身でトランザクションを構築するとしたときに、うっかり大きな額の手数料を含めないようにしないといけないためです。もし必要ならおつりを作成することによって全てのインプットを把握しておかなければいけません。さもなければ、マイナーにとても大きなチップをあげることになってしまうのです！

For example, if you consume a 20-bitcoin UTXO to make a 1-bitcoin payment, you must include a 19-bitcoin change output back to your wallet. Otherwise, the 19-bitcoin "leftover" will be counted as a transaction fee and will be collected by the miner who mines your transaction in a block. Although you will receive priority processing and make a miner very happy, this is probably not what you intended. 

例えば、20bitcoinのUTXOを消費して1bitcoinの支払いをしようとするなら、19bitcoinのおつりがアウトプットに含まれていなければいけません。そうしないと、19bitcoinの"残り物"はトランザクション手数料としてカウントされてしまい、あなたのトランザクションを含むブロックを採掘したマイナーによって19bitcoinが集められてしまうのです。

[WARNING]
====
If you forget to add a change output in a manually constructed transaction, you will be paying the change as a transaction fee. "Keep the change!" might not be what you intended.

手動でトランザクションを構築したときにもしおつりのアウトプットを追加し忘れてしまうと、おつり分をトランザクション手数料として払ってしまうことになります。"おつりを守りなさい！"というのは、通常の支払いの感覚からすると不思議に感じるかもしれません。
====

Let's see how this works in practice, by looking at Alice's coffee purchase again. Alice wants to spend 0.015 bitcoin to pay for coffee. To ensure this transaction is processed promptly, she will want to include a transaction fee, say 0.001. That will mean that the total cost of the transaction will be 0.016. Her wallet must therefore source a set of UTXO that adds up to 0.016 bitcoin or more and, if necessary, create change. Let's say her wallet has a 0.2-bitcoin UTXO available. It will therefore need to consume this UTXO, create one output to Bob's Cafe for 0.015, and a second output with 0.184 bitcoin in change back to her own wallet, leaving 0.001 bitcoin unallocated, as an implicit fee for the transaction. 

再度アリスのコーヒー代支払いの例を使って実用上どのように動作するかを見ていきましょう。アリスは0.015bitcoinをコーヒー代として支払おうとしています。分かりやすくするために彼女は0.001bitcoinをトランザクション手数料として含めようとしているとしてみましょう。これはトランザクションの総コストが0.016bitcoinになることを意味しています。よって、彼女のウォレットは0.016bitcoinかまたはそれより多い額になるようにUTXOを集め、必要ならおつりを作らなければいけません。彼女のウォレットが0.2bitcoinのUTXOが使用可能だとしてみると、このUTXOを消費することになります。アウトプットとしては、ボブのカフェ店への支払いとして0.015bitcoinのアウトプットを作り、そして２つ目のアウトプットとして自分自身のウォレットに返ってくる0.184bitcoinのおつりのアウトプットを作ります。0.001bitcoinが残っていますが、これが暗にトランザクションに含められているトランザクション手数料になります。

Now let's look at a different scenario. Eugenia, our children's charity director in the Philippines, has completed a fundraiser to purchase school books for the children. She received several thousand small donations from people all around the world, totaling 50 bitcoin, so her wallet is full of very small payments (UTXO). Now she wants to purchase hundreds of school books from a local publisher, paying in bitcoin. 

違ったシナリオを考えてみましょう。フィリピンの子供チャリティーディレクターのEugeniaは子供のために学校の教科書を購入するための支援金集めが完了し、全世界の人々からいただいた数千個の小さな寄付を受け取りました。総額にして50bitcoinです。このため、彼女のウォレットは小さな支払い(UTXO)でいっぱいになってしまいました。彼女は数百冊の学校の教科書を地元の出版社から購入したいと考えていて、支払いをbitcoinでするつもりでいます。

As Eugenia's wallet application tries to construct a single larger payment transaction, it must source from the available UTXO set, which is composed of many smaller amounts. That means that the resulting transaction will source from more than a hundred small-value UTXO as inputs and only one output, paying the book publisher. A transaction with that many inputs will be larger than one kilobyte, perhaps 2 to 3 kilobytes in size. As a result, it will require a higher fee than the minimal network fee of 0.0001 bitcoin. 

Eugeniaのウォレットは１個の大きなトランザクションを作ろうとしたため、多くの小さな額のUTXOで占められている使用可能なUTXOセットからUTXOを集めてこなければいけません。結果として作られるトランザクションはインプットとして数百個の小さな額のUTXOと出版社に支払われるたった１個のアウトプットで構成されることになります。多くのインプットを伴ったトランザクションのデータサイズは1KBよりも大きく、おそらく2、3KBです。結果的に、最小手数料0.0001bitcoinよりも高いトランザクション手数料が必要になります。

Eugenia's wallet application will calculate the appropriate fee by measuring the size of the transaction and multiplying that by the per-kilobyte fee. Many wallets will overpay fees for larger transactions to ensure the transaction is processed promptly. The higher fee is not because Eugenia is spending more money, but because her transaction is more complex and larger in size—the fee is independent of the transaction's bitcoin value.(((range="endofrange", startref="ix_ch05-asciidoc8")))(((range="endofrange", startref="ix_ch05-asciidoc7"))) 

Eugeniaのウォレットはトランザクションのデータサイズと1KBあたりの手数料を掛け合わせて適切な手数料を計算することになります。多くのウォレットは大きなトランザクションに対して手数料を多めに払っています。これは、トランザクションを迅速に処理してもらうためです。高い手数料を払うのはEugeniaが多くのお金を使っているからではなく、トランザクションがより複雑でよりデータサイズが大きいからです。トランザクション手数料の額はトランザクションのbitcoin額とは無関係なのです。(((range="endofrange", startref="ix_ch05-asciidoc8")))(((range="endofrange", startref="ix_ch05-asciidoc7")))

[[tx_chains]]
=== Transaction Chaining and Orphan Transactions
=== トランザクション連鎖とOrphanトランザクション

((("chaining transactions")))((("orphan transactions")))((("transactions","chaining")))((("transactions","orphan")))As we have seen, transactions form a chain, whereby one transaction spends the outputs of the previous transaction (known as the parent) and creates outputs for a subsequent transaction (known as the child). Sometimes an entire chain of transactions depending on each other—say a parent, child, and grandchild transaction—are created at the same time, to fulfill a complex transactional workflow that requires valid children to be signed before the parent is signed. For example, this is a technique used in((("CoinJoin"))) CoinJoin transactions where multiple parties join transactions together to protect their privacy. 

((("chaining transactions")))((("orphan transactions")))((("transactions","chaining")))((("transactions","orphan")))今まで見てきたように、トランザクションは連鎖を形成します。この連鎖というのは、１つのトランザクションは前のトランザクションアウトプット(親と呼ばれる)を使い、また次のトランザクションのためにアウトプット(子と呼ばれる)を作る、という連鎖です。ときどきトランザクションの連鎖全体(親トランザクション、子トランザクション、孫トランザクション)が一度に作られることがあります。これは、親トランザクションが署名される前に署名された子トランザクションが必要な場合です。例えば、これは ((("CoinJoin"))) CoinJoin トランザクションの場合のテクニックに使われます。CoinJoinトランザクションは、複数の人のトランザクションを別のトランザクションに加えて混ぜることでプライバシーを守るために使われます。

When a chain of transactions is transmitted across the network, they don't always arrive in the same order. Sometimes, the child might arrive before the parent. In that case, the nodes that see a child first can see that it references a parent transaction that is not yet known. Rather than reject the child, they put it in a temporary pool to await the arrival of its parent and propagate it to every other node. The pool of transactions without parents is known as the((("orphan transaction pool"))) _orphan transaction pool_. Once the parent arrives, any orphans that reference the UTXO created by the parent are released from the pool, revalidated recursively, and then the entire chain of transactions can be included in the transaction pool, ready to be mined in a block. Transaction chains can be arbitrarily long, with any number of generations transmitted simultaneously. The mechanism of holding orphans in the orphan pool ensures that otherwise valid transactions will not be rejected just because their parent has been delayed and that eventually the chain they belong to is reconstructed in the correct order, regardless of the order of arrival. 

トランザクションの連鎖はBitcoinネットワークを通して放出されたとき、順番通りにノードに届くわけではなく、もしかすると親よりも先に子が届いてしまうかもしれません。この場合、子を最初に見つけたノードは、この子が参照している親トランザクションのことはまだ知りません。子供を拒否するよりもむしろ、一時的なプールに子を置いておき、親が届くことを待ちます。親がいないトランザクションのプールを ((("orphan transaction pool"))) _orphanトランザクションプール_ と呼びます。一度親が届くと、親のUTXOを参照しているorphanは全てプールから取り出され、再帰的に再確認されます。このとき、トランザクションの連鎖全体がorphanトランザクションプールからトランザクションプールに取り込まれ、ブロックに取り込まれる準備が整います。トランザクションの連鎖は多くの世代が伴なったとしてもどれだけでも長くでき、同時に送信できます。orphanプールにorphanトランザクションを保持しておく方法を使うことで、親の到着が遅れたとしても子を放棄することなく、かつ正しい順番でトランザクションの連鎖を構築できるのです。

There is a limit to the number of orphan transactions stored in memory, to prevent a denial-of-service attack against bitcoin nodes. The limit is defined as((("MAX_ORPHAN_TRANSACTIONS constant"))) +MAX_ORPHAN_TRANSACTIONS+ in the source code of the bitcoin reference client. If the number of orphan transactions in the pool exceeds +MAX_ORPHAN_TRANSACTIONS+, one or more randomly selected orphan transactions are evicted from the pool, until the pool size is back within limits. 

メモリに保持できるorphanトランザクションの数には制限があります。これは、BitcoinノードからのDOS攻撃を防ぐためです。制限数は、 ((("MAX_ORPHAN_TRANSACTIONS constant"))) +MAX_ORPHAN_TRANSACTIONS+ というBitcoin参照クライアントのソースコード内にあるパラメータで定義されています。もしプールにあるorphanトランザクションの数が +MAX_ORPHAN_TRANSACTIONS+ を越えると、ランダムに選ばれたいくつかのorphanトランザクションがプールから追い出され、プールにあるorphanトランザクション数が制限以内になるように調整されます。

[[tx_script]]
=== Transaction Scripts and Script Language
=== トランザクションスクリプトとスクリプト言語

((("scripts", id="ix_ch05-asciidoc9", range="startofrange")))((("transactions","script language for", id="ix_ch05-asciidoc10", range="startofrange")))((("transactions","validation", id="ix_ch05-asciidoc11", range="startofrange")))((("validation (transaction)", id="ix_ch05-asciidoc12", range="startofrange")))Bitcoin clients validate transactions by executing a script, written in a Forth-like scripting language. Both the locking script (encumbrance) placed on a UTXO and the unlocking script that usually contains a signature are written in this scripting language. When a transaction is validated, the unlocking script in each input is executed alongside the corresponding locking script to see if it satisfies the spending condition. 

((("scripts", id="ix_ch05-asciidoc9", range="startofrange")))((("transactions","script language for", id="ix_ch05-asciidoc10", range="startofrange")))((("transactions","validation", id="ix_ch05-asciidoc11", range="startofrange")))((("validation (transaction)", id="ix_ch05-asciidoc12", range="startofrange")))Bitcoinクライアントはscriptを実行することでトランザクションの有効性をチェックします。UTXOにあるlocking script(解除条件)と通常署名を含んでいるunlocking scriptはこのscript言語で書かれています。トランザクションが有効かチェックされるときは、資金の使用条件を満たしているかどうかをみるためにそれぞれのインプットにあるunlocking scriptが対応したlocking scriptとともに実行されます。

Today, most transactions processed through the bitcoin network have the form "Alice pays Bob" and are based on the same script called a Pay-to-Public-Key-Hash script. However, the use of scripts to lock outputs and unlock inputs means that through use of the programming language, transactions can contain an infinite number of conditions. Bitcoin transactions are not limited to the "Alice pays Bob" form and pattern.  

今日、Bitcoinネットワークを通して処理される多くのトランザクションは"アリスがボブに支払う"というような形式になっており、Pay-to-Public-Key-Hash scriptと呼ばれるscriptに基づいています。しかし、アウトプットをロックしインプットを解錠するscriptを使うことは、プログラミング言語を通してトランザクションに無限個の条件を含められることを意味します。"アリスがボブに支払う"という形式に対してBitcoinトランザクションは何の制約も受けていないのです。

This is only the tip of the iceberg of possibilities that can be expressed with this scripting language. In this section, we will demonstrate the components of the bitcoin transaction scripting language and show how it can be used to express complex conditions for spending and how those conditions can be satisfied by unlocking scripts. 

これは単にこのスクリプト言語によって表現できる可能性の氷山の一角を見せているに過ぎません。この節では、Bitcoinトランザクションのスクリプト言語の要素を説明し、どのように資金の使用に対する完全な条件を表現するのか、どのようにunlocking scriptは条件を満たすことができるのかを説明していきます。

[TIP]
====
Bitcoin transaction validation is not based on a static pattern, but instead is achieved through the execution of a scripting language. This language allows for a nearly infinite variety of conditions to be expressed. This is how bitcoin gets the power of "programmable money."

Bitcoinトランザクションの有効性チェックは静的なパターンに基づいているわけではなく、script言語の実行を通して行われています。この言語はほとんど無限個の条件を表現することができます。このようにしてBitcoinは"プログラム可能な通貨"を実現しているのです。
====

==== Script Construction (Lock + Unlock)
==== スクリプトの構築(Lock + Unlock)

((("scripts","construction of")))((("validation (transaction)","script construction for")))Bitcoin's transaction validation engine relies on two types of scripts to validate transactions: a locking script and an unlocking script. 

((("scripts","construction of")))((("validation (transaction)","script construction for")))Bitcoinのトランザクション有効性チェックエンジンは二種類のスクリプトによって成り立っています。１つはlocking script、もう１つはunlocking scriptです。

((("locking scripts","transaction validation and")))((("validation (transaction)","locking scripts")))A locking script is an encumbrance placed on an output, and it specifies the conditions that must be met to spend the output in the future. Historically, the locking script was called a _scriptPubKey_, because it usually contained a public key or bitcoin address. In this book we refer to it as a "locking script" to acknowledge the much broader range of possibilities of this scripting technology. In most bitcoin applications, what we refer to as a locking script will appear in the source code as +scriptPubKey+. 

((("locking scripts","transaction validation and")))((("validation (transaction)","locking scripts")))locking scriptはアウトプットに置かれている解除条件で、将来アウトプットを使用する際に満たさなければいけない条件を指定しています。歴史的に、locking scriptは _scriptPubKey_ と呼ばれていました。というのは、locking scriptに通常公開鍵またはBitcoinアドレスが含まれているからです。この本では、スクリプトテクノロジーの可能性をより多く得るためにそれを"locking script"と呼ぶことにします。多くのBitcoinアプリケーションでは、locking scriptと呼んだものが +scriptPubKey+ としてソースコードに出てきます。

((("unlocking scripts","transaction validation and")))An unlocking script is a script that "solves," or satisfies, the conditions placed on an output by a locking script and allows the output to be spent. Unlocking scripts are part of every transaction input, and most of the time they contain a digital signature produced by the user's wallet from his or her private key. Historically, the unlocking script is called _scriptSig_, because it usually contained a digital signature. In most bitcoin applications, the source code refers to the unlocking script as +scriptSig+. In this book, we refer to it as an "unlocking script" to acknowledge the much broader range of locking script requirements, because not all unlocking scripts must contain signatures.

((("unlocking scripts","transaction validation and")))unlocking scriptは、locking scriptによってアウトプットに置かれた条件を"解く"または満たすスクリプトで、アウトプットを使用できるようにします。unlocking scriptは全てのトランザクションインプットの一部であり、ほとんどの場合秘密鍵からウォレットが作り出したデジタル署名を含んでいます。歴史的に、unlocking scriptが通常デジタル署名を含んでいるためunlocking scriptは _scriptSig_ と呼ばれています。多くのBitcoinアプリケーションのソースコードの中では、unlocking scriptを +scriptSig+ と呼んでいます。この本では、これを"unlocking script"と呼ぶことにしています。というのは、全てのunlocking scriptが署名を含んでいなければいけないわけではなく、locking scriptの解除をするために必要なものは署名以外にもあるということに気づいてもらうためです。

Every bitcoin client will validate transactions by executing the locking and unlocking scripts together. For each input in the transaction, the validation software will first retrieve the UTXO referenced by the input. That UTXO contains a locking script defining the conditions required to spend it. The validation software will then take the unlocking script contained in the input that is attempting to spend this UTXO and execute the two scripts. 

全てのBitcoinクライアントはlocking scriptとunlocking scriptを一緒に実行することでトランザクションが有効であることをチェックします。トランザクションにあるそれぞれのインプットに対して、有効性チェックソフトウェアは最初にインプットによって参照されているUTXOを取得しようとします。このUTXOは、UTXOを使うときに必要な条件が定義してあるlocking scriptを含んでいます。有効性チェックソフトウェアはこのときこのUTXOの資金を使おうとしているインプットに含まれているunlocking scriptを取り出し、locking scriptとunlocking scriptを実行します。

In the original bitcoin client, the unlocking and locking scripts were concatenated and executed in sequence. For security reasons, this was changed in 2010, because of a vulnerability that allowed a malformed unlocking script to push data onto the stack and corrupt the locking script. In the current implementation, the scripts are executed separately with the stack transferred between the two executions, as described next.

オリジナルのBitcoinクライアントでは、unlocking scriptとlocking scriptは結合されており順番に実行されていました。セキュリティの観点からこれは2010年に変更されました。悪意あるunlocking scriptがスタックにデータをプッシュし、locking scriptを意味がないものにしてしまうという弱点が生じてしまうためです。現在の実装では、次に説明するようにスクリプトはunlocking scriptとlocking scriptの間で転送されるスタックと別々に実行されるようになっています。

First, the unlocking script is executed, using the stack execution engine. If the unlocking script executed without errors (e.g., it has no "dangling" operators left over), the main stack (not the alternate stack) is copied and the locking script is executed. If the result of executing the locking script with the stack data copied from the unlocking script is "TRUE," the unlocking script has succeeded in resolving the conditions imposed by the locking script and, therefore, the input is a valid authorization to spend the UTXO. If any result other than "TRUE" remains after execution of the combined script, the input is invalid because it has failed to satisfy the spending conditions placed on the UTXO. Note that the UTXO is permanently recorded in the blockchain, and therefore is invariable and is unaffected by failed attempts to spend it by reference in a new transaction. Only a valid transaction that correctly satisfies the conditions of the UTXO results in the UTXO being marked as "spent" and removed from the set of available (unspent) UTXO.

最初に、スタック実行エンジンを使ってunlocking scriptが実行されます。もしunlocking scriptがエラーなく(例えば、"まだ実行されていない"オペレータが何も残っていないなど)実行されると、メインスタック(代替スタックではなく)がコピーされlocking scriptが実行されます。もしunlocking scriptからコピーされたスタックデータとともに実行されたlocking scriptの結果が"真"なら、unlocking scriptはlocking scriptによって課されていた条件を解くことに成功したということです。よって、インプットはUTXOを使用する有効な権限を持っているということになります。もし"真"以外が実行結果に残ってしまっているのであれば、インプットは有効ではありません。UTXOに置いてある使用条件を満たすことができなかったからです。重要なこととして、UTXOはブロックチェーンに永遠に記録され続けるため成功しなかった場合UTXOであるという状態は変化せず、何度新しいトランザクションがUTXOを不正に使用しようとしてもUTXOは全く影響を受けません。UTXOの条件を正しく満たす有効なトランザクションだけがUTXOに"使用済み"という印をつけ、使用可能な(未使用)UTXOのセットから削除させることができるのです。

<<scriptSig_and_scriptPubKey>> is an example of the unlocking and locking scripts for the most common type of bitcoin transaction (a payment to a public key hash), showing the combined script resulting from the concatenation of the unlocking and locking scripts prior to script validation. 

<<scriptSig_and_scriptPubKey>>はunlocking scriptとlocking scriptのよくある例(公開鍵ハッシュへの支払い)です。これは、スクリプトの有効性チェックの前のunlocking scriptとlocking scriptが連結されたスクリプトを示しています。

[[scriptSig_and_scriptPubKey]]
.Combining scriptSig and scriptPubKey to evaluate a transaction script
.トランザクションscriptを評価するためのscriptSigとscriptPubKeyの結合
image::images/msbt_0501.png["scriptSig_and_scriptPubKey"]


[[tx_script_language]]
==== Scripting Language
==== スクリプト言語

((("Script language", id="ix_ch05-asciidoc13", range="startofrange")))((("scripts","language for", id="ix_ch05-asciidoc14", range="startofrange")))The bitcoin transaction script language, called _Script_, is a Forth-like reverse-polish notation stack-based execution language. If that sounds like gibberish, you probably haven't studied 1960's programming languages. Script is a very simple language that was designed to be limited in scope and executable on a range of hardware, perhaps as simple as an embedded device, such as a handheld calculator. It requires minimal processing and cannot do many of the fancy things modern programming languages can do. In the case of programmable money, that is a deliberate security feature. 

((("Script language", id="ix_ch05-asciidoc13", range="startofrange")))((("scripts","language for", id="ix_ch05-asciidoc14", range="startofrange"))) _Script_ と呼ばれているBitcoinトランザクションスクリプト言語は、Forth言語のような逆ポーランド記法の言語です。もしちんぷんかんぷんに聞こえるとしたら、あなたはおそらく1960年代のプログラミング言語を勉強したことがないのでしょう。スクリプトはとてもシンプルな言語で、限られたハードウェアで動くように設計された言語です。おそらく電卓のような組み込みデバイスくらい簡単なハードウェアです。これは最小の処理のみを必要とし、最近のプログラミング言語でできるようなことの多くはできません。

Bitcoin's scripting language is called a stack-based language because it uses a data structure called a((("stack, defined"))) _stack_. A stack is a very simple data structure, which can be visualized as a stack of cards. A stack allows two operations: push and pop. Push adds an item on top of the stack. Pop removes the top item from the stack. 

Bitcoinのスクリプト言語はスタックベース言語と呼ばれています。というのは、 _スタック_ と呼ばれるデータ構造を使っているからです。スタックとはとても簡単なデータ構造で、イメージ的にはカードを重ねたもののようなものです。スタックは２つの操作を許しています。pushとpopです。pushはアイテムをスタックの一番上に加えます。popは一番上にあるアイテムをスタックから除きます。

The scripting language executes the script by processing each item from left to right. Numbers (data constants) are pushed onto the stack. Operators push or pop one or more parameters from the stack, act on them, and might push a result onto the stack. For example, +OP_ADD+ will pop two items from the stack, add them, and push the resulting sum onto the stack. 

スクリプト言語はそれぞれのアイテムを左から右に処理することでスクリプトを実行していきます。数値(定数)がスタックにpushされます。オペレーターは１つまたは複数の値をスタックに対してpush、popし、またはそれらに対して何らかの操作をします。場合によっては操作した結果をスタックにpushするかもしれません。例えば、 +OP_ADD+ はスタックから２つのアイテムをpopして、２つのアイテムを加え合わせ結果をスタックにpushします。

Conditional operators evaluate a condition, producing a boolean result of TRUE or FALSE. For example, +OP_EQUAL+ pops two items from the stack and pushes TRUE (TRUE is represented by the number 1) if they are equal or FALSE (represented by zero) if they are not equal. Bitcoin transaction scripts usually contain a conditional operator, so that they can produce the TRUE result that signifies a valid transaction. 

条件オペレーターは条件を評価して、TRUEかFALSEというブール型の結果を作り出します。例えば、 +OP_EQUAL+ はスタックから２つのアイテムをpopして、もしそれらが等しいならTRUE(TRUEは数値の1によって表現されます)をpushし、等しくなければFALSE(数値の0で表します)をpushします。Bitcoinトランザクションスクリプトは通常有効なトランザクションを示すTRUEの結果を生成するために条件オペレーターを含んでいます。

In <<simplemath_script>>, the script +2 3 OP_ADD 5 OP_EQUAL+ demonstrates the arithmetic addition operator +OP_ADD+, adding two numbers and putting the result on the stack, followed by the conditional operator +OP_EQUAL+, which checks that the resulting sum is equal to +5+. For brevity, the +OP_+ prefix is omitted in the step-by-step example. 

<<simplemath_script>>図では +2 3 OP_ADD 5 OP_EQUAL+ というスクリプトで、加法オペレーター +OP_ADD+ を実行し２つの数値を加え結果をスタックに置き、次に +OP_ADD+ の結果と +5+ が等しいかをチェックする条件オペレーター +OP_EQUAL+ を実行しています。簡潔に言えば、 +OP_+ という接頭詞は <<simplemath_script>> で省略されています。


The following is a slightly more complex script, which calculates ++2 + 7 – 3 + 1++. Notice that when the script contains several operators in a row, the stack allows the results of one operator to be acted upon by the next operator:

以下はちょっとだけ複雑なスクリプトで、 ++2 + 7 – 3 + 1++ を計算しています。スクリプトがいくつかのオペレーターを含んでいるとき、スタックの性質上１つのオペレーターの結果を次のオペレーターだけが使うことができます。

----
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
----
Try validating the preceding script yourself using pencil and paper. When the script execution ends, you should be left with the value TRUE on the stack.

鉛筆と紙を使ってこのスクリプトが有効かあなた自身でやってみましょう。スクリプトの実行が終わった段階で、スタックにTRUEが残っているはずです。

Although most locking scripts refer to a bitcoin address or public key, thereby requiring proof of ownership to spend the funds, the script does not have to be that complex. Any combination of locking and unlocking scripts that results in a TRUE value is valid. The simple arithmetic we used as an example of the scripting language is also a valid locking script that can be used to lock a transaction output.

ほとんどのlocking scriptは資金の使用にあたっての所有権の証明のためBitcoinアドレスや公開鍵を参照していますが、locking scriptは複雑である必要はありません。結果としてTRUEが出力されるlocking scriptとunlocking scriptのどんな組み合わせも有効とみなされます。スクリプト言語の例として使った簡単な算数も、トランザクションアウトプットをロックするために使うことができるきちんとしたlocking scriptです。

Use part of the arithmetic example script as the locking script:

locking scriptとしてさきほどの算数のスクリプト例の一部を使ってみましょう。

----
3 OP_ADD 5 OP_EQUAL
----

which can be satisfied by a transaction containing an input with the unlocking script:

これは以下のunlocking scriptを持つインプットがトランザクションにあれば満たすことができます。
----
2
----

The validation software combines the locking and unlocking scripts and the resulting script is:

有効性を確認するソフトウェアはlocking scriptとunlocking scriptをくっつけて以下のスクリプトを作ります。
----
2 3 OP_ADD 5 OP_EQUAL
----

As we saw in the step-by-step example in <<simplemath_script>>, when this script is executed, the result is +OP_TRUE+, making the transaction valid. Not only is this a valid transaction output locking script, but the resulting UTXO could be spent by anyone with the arithmetic skills to know that the number 2 satisfies the script. (((range="endofrange", startref="ix_ch05-asciidoc14")))(((range="endofrange", startref="ix_ch05-asciidoc13")))

<<simplemath_script>>図で見たように、このスクリプトが実行されるとこの結果は +OP_TRUE+ になりトランザクションは有効であると分かります。この場合、有効なトランザクションアウトプットのlocking scriptだけでなく、算数の計算ができる人であれば誰でも2がこのスクリプトを満たすことがわかるので誰でもUTXOを使うことができることになります。

[[simplemath_script]]
.Bitcoin's script validation doing simple math
.Bitcoinのscript検証を使って簡単な算数をやってみる。
image::images/msbt_0502.png["TxScriptSimpleMathExample"]


[TIP]
====
Transactions are valid if the top result on the stack is TRUE (noted as ++&#x7b;0x01&#x7d;++), any other non-zero value or if the stack is empty after script execution. Transactions are invalid if the top value on the stack is FALSE (a zero-length empty value, noted as ++&#x7b;&#x7d;++) or if script execution is halted explicitly by an operator, such as OP_VERIFY, OP_RETURN, or a conditional terminator such as OP_ENDIF. See <<tx_script_ops>> for details.

もしスタックの一番上に真( ++&#x7b;0x01&#x7d;++ のように表現されます)、または真ではないが０以外の値があればトランザクションは有効と検証されたことになります。または、script実行後にスタックに空値ではなく何も残っていなかった場合もトランザクションは有効と検証されたことになります。トランザクションが無効になってしまう場合は、スタックの一番上に偽(a zero-length empty value,  ++&#x7b;&#x7d;++ のように表現される長さ０の空値)がある場合や、OP_VERIFYやOP_RETURNまたはOP_ENDIFのような条件付き終了オペレータなどによって明示的にscript実行が終了させられる場合です。詳細については <<tx_script_ops>> を参照してください。
====


==== Turing Incompleteness
==== チューリング不完全

((("Script language","flow-control/loops in")))((("Script language","statelessness of")))((("Turing Complete")))The bitcoin transaction script language contains many operators, but is deliberately limited in one important way—there are no loops or complex flow control capabilities other than conditional flow control. This ensures that the language is not _Turing Complete_, meaning that scripts have limited complexity and predictable execution times. Script is not a general-purpose language. These limitations ensure that the language cannot be used to create an infinite loop or other form of "logic bomb" that could be embedded in a transaction in a way that causes a((("denial-of-service attack","Script language and"))) denial-of-service attack against the bitcoin network. Remember, every transaction is validated by every full node on the bitcoin network. A limited language prevents the transaction validation mechanism from being used as a vulnerability. 

((("Script language","flow-control/loops in")))((("Script language","statelessness of")))((("Turing Complete")))Bitcoinトランザクションスクリプト言語は多くのオペレーターを持っています。しかし、意図的にループやif文などの分岐処理がないように制限されています。これは言語が _チューリング完全_ ではないということを言っており、このようになっているのはスクリプトの簡潔さや実行時間を予測できるようにすることがあります。スクリプト言語は汎用言語ではないのです。これらの制限によって、無限ループを作ることやBitcoinネットワークを使ったDOS攻撃を起こすようなトランザクションに内在する"論理爆弾(logic bomb)"などを作ることができなくなっています。思い出してみてください、全てのトランザクションはBitcoinネットワーク上の全てのfull nodeによって有効性を確認されているので、トランザクションの有効性確認処理に問題があれば簡単に脆弱性が作れてしまいます。言語が制限されているためにトランザクションの有効性確認メカニズムが脆弱性を生むことを防いでいるのです。

==== Stateless Verification
==== ステートレスな検証

((("stateless verification of transactions")))((("transactions","statelessness of")))The bitcoin transaction script language is stateless, in that there is no state prior to execution of the script, or state saved after execution of the script. Therefore, all the information needed to execute a script is contained within the script. A script will predictably execute the same way on any system. If your system verifies a script, you can be sure that every other system in the bitcoin network will also verify the script, meaning that a valid transaction is valid for everyone and everyone knows this. This predictability of outcomes is an essential benefit of the bitcoin system.(((range="endofrange", startref="ix_ch05-asciidoc12")))(((range="endofrange", startref="ix_ch05-asciidoc11")))(((range="endofrange", startref="ix_ch05-asciidoc10")))(((range="endofrange", startref="ix_ch05-asciidoc9")))

((("stateless verification of transactions")))((("transactions","statelessness of")))Bitcoinトランザクションスクリプト言語はステートレスです。これは、スクリプトの実行前の状態を何も保持しない、またはスクリプトの実行後の状態を一切保存しないということです。このため、スクリプトを実行するために必要な全ての情報はスクリプトの中に含まれていることになり、スクリプトはどんなシステム上でも同じプロセスで実行できることが予測できるということになります。もしあなたのシステムがスクリプトを検証できるなら、確実にBitcoinネットワーク内の他全てのシステムもまたスクリプトを検証でき、有効なトランザクションは全ての人に対して有効なのです。この結果の予測可能性はBitcoinシステムの本質的な利点です。(((range="endofrange", startref="ix_ch05-asciidoc12")))(((range="endofrange", startref="ix_ch05-asciidoc11")))(((range="endofrange", startref="ix_ch05-asciidoc10")))(((range="endofrange", startref="ix_ch05-asciidoc9")))

[[std_tx]]
=== Standard Transactions
=== 標準的なトランザクション

In the first few years of bitcoin's development, the developers introduced some limitations in the types of scripts that could be processed by the reference client. These limitations are encoded in a function called +isStandard()+, which defines five types of "standard" transactions. These limitations are temporary and might be lifted by the time you read this. Until then, the five standard types of transaction scripts are the only ones that will be accepted by the reference client and most miners who run the reference client. Although it is possible to create a nonstandard transaction containing a script that is not one of the standard types, you must find a miner who does not follow these limitations to mine that transaction into a block. 

Bitcoinの発展の最初の数年は、開発者たちがBitcoin参照クライアントによって処理されるスクリプトの種類にいくつかの制限を加えていました。これらの制限は +isStandard()+ と呼ばれる関数の中にあり、５つの"標準的なトランザクション"の種類が定義されています。これらの制限は一時的なもので、あなたがこれを読むときまでに解除されているかもしれません。これらの制限が解除されるまでは、５つの標準的なトランザクションスクリプトだけがBitcoin Coreクライアントやこれを動作させている多くのマイナーに受け入れられています。非標準的なトランザクションを作ることは可能ですが、このトランザクションをブロックに入れてくれるマイナーを見つけなければいけません。

Check the source code of the Bitcoin Core client (the reference implementation) to see what is currently allowed as a valid transaction script. 

どんなスクリプトが有効なトランザクションスクリプトとして現在許可されているかを見るためにBitcoin Coreクライアント(リファレンス実装)のソースコードをチェックしてみましょう。

The five standard types of transaction scripts are pay-to-public-key-hash (P2PKH), public-key, multi-signature (limited to 15 keys), pay-to-script-hash (P2SH), and data output (OP_RETURN), which are described in more detail in the following sections.

トランザクションスクリプトの５つの標準的な種類は、pay-to-public-key-hash (P2PKH), public-key, multi-signature (最大15個のキーまで), pay-to-script-hash (P2SH), data output (OP_RETURN) です。これらの詳細な説明は次の節で行います。

[[p2pkh]]
==== Pay-to-Public-Key-Hash (P2PKH)
==== Pay-to-Public-Key-Hash (P2PKH)

((("pay-to-public-key-hash (P2PKH)", id="ix_ch05-asciidoc15", range="startofrange")))((("transactions","pay-to-public-key-hash", id="ix_ch05-asciidoc16", range="startofrange")))The vast majority of transactions processed on the bitcoin network are P2PKH transactions. These contain a locking script that encumbers the output with a public key hash, more commonly known as a bitcoin address. Transactions that pay a bitcoin address contain P2PKH scripts. An output locked by a P2PKH script can be unlocked (spent) by presenting a public key and a digital signature created by the corresponding private key. 

((("pay-to-public-key-hash (P2PKH)", id="ix_ch05-asciidoc15", range="startofrange")))((("transactions","pay-to-public-key-hash", id="ix_ch05-asciidoc16", range="startofrange")))Bitcoinネットワーク上で処理されているトランザクションの多くはP2PKHトランザクションです。これはBitcoinアドレスとして知られている公開鍵ハッシュを伴ったトランザクションアウトプットを拘束しているlocking scriptを含んでいます。Bitcoinアドレスへの支払いをするトランザクションはP2PKHスクリプトを含んでおり、このP2PKHスクリプトでロックされているアウトプットは公開鍵とこの公開鍵に対応したデジタル署名を提示することで解除(資金の使用)ができます。

For example, let's look at Alice's payment to Bob's Cafe again. Alice made a payment of 0.015 bitcoin to the cafe's bitcoin address. That transaction output would have a locking script of the form:

例えば、アリスがボブのカフェに支払う場面を再度見てみましょう。アリスはこのカフェのBitcoinアドレスに0.015bitcoinの支払いをします。このトランザクションアウトプットは以下のようなlocking scriptが含まれています。

----
OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUAL OP_CHECKSIG
----

The +Cafe Public Key Hash+ is equivalent to the bitcoin address of the cafe, without the Base58Check encoding. Most applications would show the _public key hash_ in hexadecimal encoding and not the familiar bitcoin address Base58Check format that begins with a "1". 

+Cafe Public Key Hash+ はこのカフェのBitcoinアドレス(Base58Checkエンコーディングが施されていないもの)と同じものです。多くのアプリケーションでは _公開鍵ハッシュ_ を１６進数で表したものを使っており、なじみのある"1"から始まるBase58Check形式のBitcoinアドレスではありません。

The preceding locking script can be satisfied with an unlocking script of the form:

このlocking scriptは以下のunlocking scriptで条件を満たすことができます。

----
<Cafe Signature> <Cafe Public Key>
----

The two scripts together would form the following combined validation script:

この２つのスクリプトを合わせることで、以下の検証スクリプトの形になります。

----
<Cafe Signature> <Cafe Public Key> OP_DUP OP_HASH160 
<Cafe Public Key Hash> OP_EQUAL OP_CHECKSIG
----

When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In other words, the result will be TRUE if the unlocking script has a valid signature from the cafe's private key that corresponds to the public key hash set as an encumbrance. 

これを実行するとき、unlocking scriptがlocking scriptの条件を満たしかつその場合に限り、この結合されたスクリプトはTRUEと評価されます。他の言い方をすると、もしunlocking scriptがボブのカフェの秘密鍵から作られた有効な署名を持っていれば結果はTRUEになります。

Figures pass:[<xref linkend="P2PubKHash1" xrefstyle="select: labelnumber"/>] and pass:[<xref linkend="P2PubKHash2" xrefstyle="select: labelnumber"/>] show (in two parts) a step-by-step execution of the combined script, which will prove this is a valid transaction.(((range="endofrange", startref="ix_ch05-asciidoc16")))(((range="endofrange", startref="ix_ch05-asciidoc15")))

図 pass:[<xref linkend="P2PubKHash1" xrefstyle="select: labelnumber"/>] と図 pass:[<xref linkend="P2PubKHash2" xrefstyle="select: labelnumber"/>] は結合されたスクリプトの逐次実行を(２つの部分で)表しており、この結合されたスクリプトが有効なトランザクションであることを証明することになります。

[[P2PubKHash1]]
.Evaluating a script for a P2PKH transaction (Part 1 of 2)
.P2PKHトランザクションにおけるscriptの評価(1/2)
image::images/msbt_0503.png["Tx_Script_P2PubKeyHash_1"]


[[p2pk]]    
==== Pay-to-Public-Key
==== Pay-to-Public-Key

((("pay-to-public-key")))Pay-to-public-key is a simpler form of a bitcoin payment than pay-to-public-key-hash. With this script form, the public key itself is stored in the locking script, rather than a public-key-hash as with P2PKH earlier, which is much shorter. Pay-to-public-key-hash was invented by Satoshi to make bitcoin addresses shorter, for ease of use. Pay-to-public-key is now most often seen in coinbase transactions, generated by older mining software that has not been updated to use P2PKH. 

((("pay-to-public-key")))pay-to-public-keyはpay-to-public-key-hashよりもよりシンプルなBitcoin支払いの形式です。このスクリプト形式は、前に出てきたP2PKHでのとても短い公開鍵ハッシュではなく、公開鍵そのものをlocking scriptに配置しています。pay-to-public-key-hashはBitcoinアドレスをより短くし使いやすくするためにSatoshi Nakamotoによって発明されたものです。現在pay-to-public-keyはcoinbaseトランザクションでよく見られるもので、P2PKHが使用できるように更新されていない古いマイニングソフトウェアで使われています。

A pay-to-public-key locking script looks like this:

pay-to-public-key locing scriptは以下のようなものです。

----
<Public Key A> OP_CHECKSIG
----

The corresponding unlocking script that must be presented to unlock this type of output is a simple signature, like this:

アウトプットを解除するために提示されなければならないunlocking scriptは以下のようなシンプルな署名です。

----
<Signature from Private Key A>
----

The combined script, which is validated by the transaction validation software, is:

トランザクションの有効性検証に使われる結合されたスクリプトは以下です。

----
<Signature from Private Key A> <Public Key A> OP_CHECKSIG
----

This script is a simple invocation of the +CHECKSIG+ operator, which validates the signature as belonging to the correct key and returns TRUE on the stack.

このスクリプトは +CHECKSIG+ オペレーターを使ったシンプルなスクリプトで、正しい秘密鍵に紐づく署名を検証しています。

[[P2PubKHash2]]
.Evaluating a script for a P2PKH transaction (Part 2 of 2)
.P2PKHトランザクションにおけるscriptの評価(2/2)
image::images/msbt_0504.png["Tx_Script_P2PubKeyHash_2"]

[[multisig]]
==== Multi-Signature
==== マルチシグネチャー

((("multi-signature scripts")))((("transactions","multi-signature scripts")))Multi-signature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to release the encumbrance. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation. For example, a 2-of-3 multi-signature is one where three public keys are listed as potential signers and at least two of those must be used to create signatures for a valid transaction to spend the funds. ((("multi-signature scripts","limits on")))At this time, standard multi-signature scripts are limited to at most 15 listed public keys, meaning you can do anything from a 1-of-1 to a 15-of-15 multi-signature or any combination within that range. The limitation to 15 listed keys might be lifted by the time this book is published, so check the((("isStandard() function"))) +isStandard()+ function to see what is currently accepted by the network. 

((("multi-signature scripts")))((("transactions","multi-signature scripts")))マルチシグネチャースクリプトはN個の公開鍵と、解除条件を解放する少なくともM個の署名が入っている条件を設定しています。これはM-of-Nスキーマとしても知られており、Nはキーの総数、Mは検証に必要な署名数です。例えば2-of-3マルチシグネチャーでは、あらかじめ登録しておいた署名者の３つの公開鍵があり、これらのうち２つを使って有効なトランザクションに対する署名を作らなければいけません。((("multi-signature scripts","limits on")))このとき、標準的なマルチシグネチャースクリプトは多くても１５個の公開鍵だけが使用できるように制限されており、これは1-of-1から15-of-15までのマルチシグネチャー、またはそれぞれの組み合わせを使用できるということを示しています。この制限はこの本が出版されるまでに引き上げられるかもしれません。Bitcoinネットワークによって現在何が許可されているかを見るために ((("isStandard() function"))) +isStandard()+ 関数をチェックしてみてください。

The general form of a locking script setting an M-of-N multi-signature condition is:

M-of-Nマルチシグネチャー条件を設定しているlocking scriptの一般形式は以下です。

----
M <Public Key 1> <Public Key 2> ... <Public Key N> N OP_CHECKMULTISIG
----

where N is the total number of listed public keys and M is the threshold of required signatures to spend the output.

ただし、Nは登録されている公開鍵の総数、Mはアウトプットを使うにあたって必要な署名数です。
 
A locking script setting a 2-of-3 multi-signature condition looks like this:

2-of-3マルチシグネチャー条件を設定しているlocking scriptは以下のようなものです。

----
2 <Public Key A> <Public Key B> <Public Key C> 3 OP_CHECKMULTISIG
----

The preceding locking script can be satisfied with an unlocking script containing pairs of signatures and public keys:

このlocking scriptは署名と公開鍵のペアを含む以下のunlocking scriptで条件を満たすことができます。

----
OP_0 <Signature B> <Signature C>
----
or any combination of two signatures from the private keys corresponding to the three listed public keys. 

または、署名A・署名Cなどの登録されている３つの公開鍵に対応する秘密鍵から作られる２つの署名のどんな組み合わせも使うことができます。

[NOTE]
==== 
((("CHECKMULTISIG implementation")))The prefix +OP_0+ is required because of a bug in the original implementation of +CHECKMULTISIG+ where one item too many is popped off the stack. It is ignored by +CHECKMULTISIG+ and is simply a placeholder.

((("CHECKMULTISIG implementation")))最初に置かれている +OP_0+ は +CHECKMULTISIG+ のオリジナルの実装にバグがありそれを補完するために必要となっています。このバグというのは、 +CHECKMULTISIG+ を実行した時に処理に関係のないスタック上のアイテムを余分に１つpopしてしまうというバグです。 +CHECKMULTISIG+ 処理は事実 +OP_0+ を無視して実行され、 +OP_0+ は単なる空箱のようなものになっています。
====

The two scripts together would form the combined validation script:

この２つのスクリプトは以下の結合された検証スクリプトを形作ります。

----
OP_0 <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 OP_CHECKMULTISIG
----

When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In this case, the condition is whether the unlocking script has a valid signature from the two private keys that correspond to two of the three public keys set as an encumbrance. 

これを実行するとき、unlocking scriptがlocking scriptの条件を満たしかつその場合に限り、この結合されたスクリプトはTRUEと評価されます。この場合、unlocking scriptが解除条件に設定してある３つの公開鍵のうち２つに対応した秘密鍵から作られる有効な署名を持っているかどうかが条件になります。

[[op_return]]
==== Data Output (OP_RETURN)
==== データアウトプット(OP_RETURN)

((("ledger, storing unrelated information in")))((("OP_RETURN operator")))((("transactions","storing unrelated information in")))Bitcoin's distributed and timestamped ledger, the blockchain, has potential uses far beyond payments. Many developers have tried to use the transaction scripting language to take advantage of the security and resilience of the system for applications such as((("digital notary services")))((("smart contracts")))((("stock certificates"))) digital notary services, stock certificates, and smart contracts. Early attempts to use bitcoin's script language for these purposes involved creating transaction outputs that recorded data on the blockchain; for example, to record a digital fingerprint of a file in such a way that anyone could establish proof-of-existence of that file on a specific date by reference to that transaction.

((("ledger, storing unrelated information in")))((("OP_RETURN operator")))((("transactions","storing unrelated information in")))Bitcoinの時刻が刻印された分散化元帳であるブロックチェーンは支払い以上のポテンシャルを持っています。多くの開発者たちは ((("digital notary services")))((("smart contracts")))((("stock certificates"))) デジタル公証人サービス、株券、スマートコントラクトのようなアプリケーションのためにトランザクションスクリプト言語を使うことでより進んだシステムの安全性や可用性を確保しようとしてきました。当初Bitcoinのスクリプト言語をこれらの目的に使っていく場合、ブロックチェーン上に記録されたデータであるトランザクションアウトプットを利用することが考えられました。これで行う例としては、ファイルの存在証明があります。このトランザクションが参照している特定の日付を利用して、あるファイルの存在証明(proof-of-existence)を誰でもできるようにすることでファイルのデジタルフィンガープリントを記録します。



((("blockchains","storing unrelated information in")))The use of bitcoin's blockchain to store data unrelated to bitcoin payments is a controversial subject. Many developers consider such use abusive and want to discourage it. Others view it as a demonstration of the powerful capabilities of blockchain technology and want to encourage such experimentation. Those who object to the inclusion of non-payment data argue that it causes "blockchain bloat," burdening those running full bitcoin nodes with carrying the cost of disk storage for data that the blockchain was not intended to carry. Moreover, such transactions create UTXO that cannot be spent, using the destination bitcoin address as a free-form 20-byte field. Because the address is used for data, it doesn't correspond to a private key and the resulting UTXO can _never_ be spent; it's a fake payment. These transactions that can never be spent are therefore never removed from the UTXO set and cause the size of the UTXO database to forever increase, or "bloat."

((("blockchains","storing unrelated information in")))bitcoinの支払いと無関係なデータをブロックチェーン上に記録することは物議を引き起こしました。多くの開発者たちはこのようなブロックチェーンの使い方を汚いものと考え、思いとどまらせようと考えました。またある人たちはこれがブロックチェーンテクノロジーの強力な拡張性を示すものと感じ、このような実験を押し進めようとしました。支払いと関係のないデータを含めることに反対な人たちはこれにより"ブロックチェーンの肥大化"を引き起こすと考えており、ブロックチェーンが本来運ぶ必要のなかったデータのためにディスクストレージのコストが増大しfull nodeを動作させているサーバのコストが増えてしまうと考えました。さらに、このようなトランザクションは使用されないUTXOを作り出し、送り先Bitcoinアドレスの領域20byteを自由に使える領域として使ってしまいます。このBitcoinアドレスはデータのために使われるので、これは秘密鍵に対応しておらず _決して使われない_ UTXOを結果として生み出してしまうのです。これはあたかも偽物の支払いのようになってしまいます。決して使われないこれらのトランザクションはUTXOセットから決して削除されず、永遠にUTXOデータベースのサイズを大きくし続け、"肥大化"させてしまいます。

In version 0.9 of the Bitcoin Core client, a compromise was reached with the introduction of the +OP_RETURN+ operator. +OP_RETURN+ allows developers to add 80 bytes of nonpayment data to a transaction output. However, unlike the use of "fake" UTXO, the +OP_RETURN+ operator creates an explicitly _provably unspendable_ output, which does not need to be stored in the UTXO set. +OP_RETURN+ outputs are recorded on the blockchain, so they consume disk space and contribute to the increase in the blockchain's size, but they are not stored in the UTXO set and therefore do not bloat the UTXO memory pool and burden full nodes with the cost of more expensive RAM. 

Bitcoin Coreクライアントのバージョン0.9では、妥協策として +OP_RETURN+ オペレーターが導入されました。 +OP_RETURN+ は開発者たちが支払いに関係のない80byteのデータをトランザクションアウトプットに追加できるようにしています。"偽物の"UTXOと違って、 +OP_RETURN+ オペレーターはUTXOセットに保持される必要がない _明示的使用不可_ アウトプットを作り出します。 +OP_RETURN+ アウトプットはブロックチェーン上に記録されるためディスク容量を消費しブロックチェーンのデータサイズ増大を促してしまいますが、UTXOセットに保存されないためUTXOメモリプールと高価なRAMのコストの肥大化にはならないようになっています。

+OP_RETURN+ scripts look like this:

+OP_RETURN+ スクリプトは以下のようなものです。

----
OP_RETURN <data>
----

The data portion is limited to 80 bytes and most often represents a hash, such as the output from the SHA256 algorithm (32 bytes). Many applications put a prefix in front of the data to help identify the application. For example, the http://proofofexistence.com[Proof of Existence] digital notarization service uses the 8-byte prefix "DOCPROOF," which is ASCII encoded as +44f4350524f4f46+ in hexadecimal.

このdataは80byteに制限され、多くの場合SHA256アルゴリズム(32バイト)の出力結果のようなハッシュになっています。多くのアプリケーションはアプリケーションを示すidをdataの前にprefixとして置いています。例えば、 http://proofofexistence.com[Proof of Existence] というデジタル公証人サービスは8byteのprefix "DOCPROOF" を使っていて、ASCIIコードで表すと１６進数で +44f4350524f4f46+ になります。

Keep in mind that there is no "unlocking script" that corresponds to +OP_RETURN+ that could possibly be used to "spend" an +OP_RETURN+ output. The whole point of +OP_RETURN+ is that you can't spend the money locked in that output, and therefore it does not need to be held in the UTXO set as potentially spendable—+OP_RETURN+ is _provably un-spendable_. +OP_RETURN+ is usually an output with a zero bitcoin amount, because any bitcoin assigned to such an output is effectively lost forever. If an +OP_RETURN+ is encountered by the script validation software, it results immediately in halting the execution of the validation script and marking the transaction as invalid. Thus, if you accidentally reference an +OP_RETURN+ output as an input in a transaction, that transaction is invalid. 

+OP_RETURN+ アウトプットを"使用する"ための"unlocking script"がないことを覚えておいてください。つまり、+OP_RETURN+ ではこのアウトプットでロックされている資金を使うことはできないのです。そして、使用可能なものとしてUTXOセットに保持しておく必要はありません。このアウトプットに割り当てられているどんなbitcoinも永遠に失われてしまうため、 +OP_RETURN+ アウトプットは通常0bitcoinを持ちます。もしスクリプト検証ソフトウェアが +OP_RETURN+ を見つけた場合には、検証スクリプトの実行を直ちに停止しトランザクションを無効にします。このため、もし偶然 +OP_RETURN+ アウトプットをトランザクションインプットが参照した場合は、このトランザクションは無効になります。

A standard transaction (one that conforms to the +isStandard()+ checks) can have only one +OP_RETURN+ output. However, a single +OP_RETURN+ output can be combined in a transaction with outputs of any other type. 

標準的なトランザクション( +isStandard()+ を確認してみてください)はたった１つだけしか +OP_RETURN+ アウトプットを持つことができませんが、 +OP_RETURN+ アウトプットは他の種類のアウトプットを持つトランザクションと結合することができます。

Two new command-line options have been added in Bitcoin Core as of version 0.10. The option +datacarrier+ controls relay and mining of OP_RETURN transactions, with the default set to "1" to allow them. The option +datacarriersize+ takes a numeric argument specifying the maximum size in bytes of the OP_RETURN data, 40 bytes by default.

現在のBitcoin Coreバージョン0.10では２つの新しいコマンドラインオプションが追加されました。 +datacarrier+ オプションはOP_RETURNトランザクションのリレーとマイニングを行うかどうかをコントロールしており、デフォルトは"1"でリレーとマイニングの実行を許可するものになっています。 +datacarriersize+ オプションは数値を引数として取りOP_RETURNデータの最大バイトサイズを指定します。この最大バイトサイズのデフォルトは40バイトです。

[NOTE]
====
OP_RETURN was initially proposed with a limit of 80 bytes, but the limit was reduced to 40 bytes when the feature was released. In February 2015, in version 0.10 of Bitcoin Core, the limit was raised back to 80 bytes. Nodes may choose not to relay or mine OP_RETURN, or only relay and mine OP_RETURN containing less than 80 bytes of data.

OP_RETURNは最初80バイトの制限を付けた形で提案されていましたが、この機能が実際にリリースされた時に制限が40バイトに削減されました。2015年2月にリリースされたBitcoin Coreバージョン0.10の中で、この制限は80バイトに引き上げられました。ノードはOP_RETURNトランザクションをリレー、マイニングしないか、または単にリレーだけして80バイトより小さいデータを持つOP_RETURNトランザクションだけをマイニングするか、を選べるようになっています。
====

[[p2sh]]
==== Pay-to-Script-Hash (P2SH)
==== Pay-to-Script-Hash (P2SH)

((("multi-signature scripts","P2SH and", id="ix_ch05-asciidoc17", range="startofrange")))((("Pay-to-script-hash (P2SH)", id="ix_ch05-asciidoc18", range="startofrange")))((("transactions","Pay-to-script-hash", id="ix_ch05-asciidoc19", range="startofrange")))Pay-to-script-hash (P2SH) was introduced in 2012 as a powerful new type of transaction that greatly simplifies the use of complex transaction scripts. To explain the need for P2SH, let's look at a practical example.

((("multi-signature scripts","P2SH and", id="ix_ch05-asciidoc17", range="startofrange")))((("Pay-to-script-hash (P2SH)", id="ix_ch05-asciidoc18", range="startofrange")))((("transactions","Pay-to-script-hash", id="ix_ch05-asciidoc19", range="startofrange")))pay-to-script-hash (P2SH)は2012年に導入されたもので、複雑なトランザクションスクリプトをはるかに簡単化した新しい種類のトランザクションです。P2SHを説明するために、実用的な例を見てみましょう。

In <<ch01_intro_what_is_bitcoin>> we introduced Mohammed, an electronics importer based in Dubai. Mohammed's company uses bitcoin's multi-signature feature extensively for its corporate accounts. Multi-signature scripts are one of the most common uses of bitcoin's advanced scripting capabilities and are a very powerful feature. Mohammed's company uses a multi-signature script for all customer payments, known in accounting terms as "accounts receivable," or AR. With the multi-signature scheme, any payments made by customers are locked in such a way that they require at least two signatures to release, from Mohammed and one of his partners or from his attorney who has a backup key. A multi-signature scheme like that offers corporate governance controls and protects against theft, embezzlement, or loss. 

<<ch01_intro_what_is_bitcoin>>で、ドバイで電子機器の輸入業をやっているムハンマドを紹介しました。ムハンマドの会社は会社の口座のためにBitcoinのマルチシグネチャー機能を利用しています。マルチシグネチャースクリプトはBitcoinの先進的なスクリプト言語の主要な使い方の１つで、とても強力な機能です。ムハンマドの会社は全ての顧客からの支払い(会計用語で"売掛金")にマルチシグネチャーを使っています。マルチシグネチャースキームを使い、顧客による全ての支払いは次のような方法で安全性を担保しています。支払いを実行するには少なくとも２つの署名が必要であり、登録されている人はムハンマド、彼のパートナーのうちの１人、バックアップキーを持っている彼の代理人です。このようなマルチシグネチャースキームはコーポレートガバナンスを提供し、盗難、横領、または紛失を防ぐ役割があります。

The resulting script is quite long and looks like this:

このためのスクリプトはとても長く、以下のようなものです。

----
2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> <Partner3 Public Key> <Attorney Public Key> 5 OP_CHECKMULTISIG
----

    
Although multi-signature scripts are a powerful feature, they are cumbersome to use. Given the preceding script, Mohammed would have to communicate this script to every customer prior to payment. Each customer would have to use special bitcoin wallet software with the ability to create custom transaction scripts, and each customer would have to understand how to create a transaction using custom scripts. Furthermore, the resulting transaction would be about five times larger than a simple payment transaction, because this script contains very long public keys. The burden of that extra-large transaction would be borne by the customer in the form of fees. Finally, a large transaction script like this would be carried in the UTXO set in RAM in every full node, until it was spent. All of these issues make using complex output scripts difficult in practice. 

マルチシグネチャースクリプトはとても強力な機能ですが、これは扱いにくいものなのです。というのは、ムハンマドは支払いをする前にこのスクリプトについて全ての顧客に説明する必要があるためです。それぞれの顧客は特別なトランザクションスクリプトを作ることができる特別なウォレットを使う必要があり、また特別なスクリプトを使ってどのようにトランザクションを作ればよいか理解する必要があります。さらに、このスクリプトがとても長い公開鍵を含んでいるため、作られたトランザクションのデータサイズは単純な支払いトランザクションと比べて約５倍も大きいのです。余分に大きいトランザクションの負担が顧客ごとのトランザクション手数料として乗っかってきます。最終的に、このような大きなトランザクションスクリプトは使用されるまで全てのfull nodeのRAM内のUTXOセットに保持されます。このような問題点によって実用上、複雑なアウトプットスクリプトの使用が難しくなってしまうのです。

Pay-to-script-hash (P2SH) was developed to resolve these practical difficulties and to make the use of complex scripts as easy as a payment to a bitcoin address. With P2SH payments, the complex locking script is replaced with its digital fingerprint, a cryptographic hash. When a transaction attempting to spend the UTXO is presented later, it must contain the script that matches the hash, in addition to the unlocking script. In simple terms, P2SH means "pay to a script matching this hash, a script that will be presented later when this output is spent." 

pay-to-script-hash (P2SH) はこれらの実用的な難点を解決するために開発され、Bitcoinアドレスでの支払いと同じくらい簡単に複雑なスクリプトが使えるようにしたのです。P2SHでの支払いで、複雑なlocking scriptは暗号学的なハッシュであるデジタルフィンガープリントに置き換えられます。UTXOを使おうとするトランザクションがのちに作られたとき、このトランザクションはunlocking scriptだけでなくこのハッシュとマッチするスクリプトを含んでいなければいけません。簡単に言って、P2SHは"このハッシュとマッチするスクリプトに対して支払い、スクリプトはこのアウトプットが使用されるときにのちに与えられます"という意味です。

In P2SH transactions, the locking script that is replaced by a hash is referred to as the((("redeem script"))) _redeem script_ because it is presented to the system at redemption time rather than as a locking script. <<without_p2sh>> shows the script without P2SH and <<with_p2sh>> shows the same script encoded with P2SH.

P2SHトランザクションでは、ハッシュによって置き換えられたlocking scriptは((("redeem script"))) _redeem script_ と呼ばれます。なぜなら、これがlocking scriptとしてよりはむしろ回収時にシステムに提供されるからです。<<without_p2sh>>はP2SHではないスクリプトを示し、<<with_p2sh>>はP2SHでエンコードされた同じスクリプトを示しています。

[[without_p2sh]]
.Complex script without P2SH
.P2SHを使用しない複雑なscript
|=======
| Locking Script | 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG
| Unlocking Script | Sig1 Sig2   
|=======

[[with_p2sh]]
.Complex script as P2SH
.P2SHを使用した複雑なscript
|=======
| Redeem Script | 2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG
| Locking Script | OP_HASH160 <20-byte hash of redeem script> OP_EQUAL
| Unlocking Script | Sig1 Sig2 redeem script 
|=======

As you can see from the tables, with P2SH the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, only a hash of it is in the locking script and the redeem script itself is presented later, as part of the unlocking script when the output is spent. This shifts the burden in fees and complexity from the sender to the recipient (spender) of the transaction. 

上記表にある通り、P2SHの場合locking scriptにアウトプットを使用するための詳細条件が書かれた複雑なスクリプトがありません。その代わり、redeem scriptのハッシュだけがlocking scriptにはあり、redeem script自身はアウトプットが使用されるときのunlocking scriptの一部としてあとで提供されます。

Let's look at Mohammed's company, the complex multi-signature script, and the resulting P2SH scripts. 

ムハンマドの会社の場合の複雑なマルチシグネチャースクリプトとP2SHスクリプトを見てみましょう。

First, the multi-signature script that Mohammed's company uses for all incoming payments from customers:

まず、ムハンマドの会社が顧客からの支払いに使っているマルチシグネチャースクリプトは以下です。

----
2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> <Partner3 Public Key> <Attorney Public Key> 5 OP_CHECKMULTISIG
----

If the placeholders are replaced by actual public keys (shown here as 520-bit numbers starting with 04) you can see that this script becomes very long:

上記の大なり小なり括弧を実際の公開鍵(04から始まる520bitの数値)に置き換えてみると、以下のようにとても長くなってしまうことが分かるはずです。

----
2 
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 OP_CHECKMULTISIG
----

This entire script can instead be represented by a 20-byte cryptographic hash, by first applying the SHA256 hashing algorithm and then applying the RIPEMD160 algorithm on the result. The 20-byte hash of the preceding script is:

このスクリプト全体は20byteの暗号学的ハッシュで表現でき、このハッシュは最初にSHA256ハッシュ化アルゴリズムを適用しその後この結果にRIPEMD160アルゴリズムを適用することで作成されます。前のスクリプトに対してのこのハッシュ化して得た20byteのハッシュは以下になります。

----
54c557e07dde5bb6cb791c7a540e0a4796f5e97e
----

A P2SH transaction locks the output to this hash instead of the longer script, using the locking script:

P2SHトランザクションは、長いスクリプトの代わりにこのハッシュを含めたlocking scriptでアウトプットをロックしています。

----
OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL
----
which, as you can see, is much shorter. Instead of "pay to this 5-key multi-signature script," the P2SH equivalent transaction is "pay to a script with this hash." A customer making a payment to Mohammed's company need only include this much shorter locking script in his payment. When Mohammed wants to spend this UTXO, they must present the original redeem script (the one whose hash locked the UTXO) and the signatures necessary to unlock it, like this:

見て分かるように前のlocking scriptよりもずいぶん短いことが分かります。"5つのキーのマルチシグネチャースクリプトに対する支払い"ではなく、P2SHでは"このハッシュを持ったスクリプトへの支払い(pay to a script with this hash)"になります。ムハンマドの会社への支払いをする顧客は彼の支払いの中にあるもっと短いlocking scriptを含めるだけで支払いができるのです。ムハンマドがこのUTXOを使いたいときは、オリジナルのredeem scriptと解除するための署名を以下のように提供しなければいけません。

----
<Sig1> <Sig2> <2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG>
----

The two scripts are combined in two stages. First, the redeem script is checked against the locking script to make sure the hash matches:

２つのスクリプトは２つの段階で結合されます。まず、このハッシュが合っているかを確認するためにlocking scriptに対してredeem scriptがチェックされます。

----
<2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG> OP_HASH160 <redeem scriptHash> OP_EQUAL
----
If the redeem script hash matches, the unlocking script is executed on its own, to unlock the redeem script:

もしredeem scriptハッシュが合っていれば、unlocking scriptはredeem scriptを解除するために実行されます。

----
<Sig1> <Sig2> 2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG
----

===== Pay-to-script-hash addresses
===== Pay-to-script-hashアドレス

((("addresses, bitcoin","Pay-to-Script-Hash (P2SH)")))((("Pay-to-script-hash (P2SH)","addresses")))Another important part of the P2SH feature is the ability to encode a script hash as an address, as defined in BIP0013. P2SH addresses are Base58Check encodings of the 20-byte hash of a script, just like bitcoin addresses are Base58Check encodings of the 20-byte hash of a public key. P2SH addresses use the version prefix "5", which results in Base58Check-encoded addresses that start with a "3". For example, Mohammed's complex script, hashed and Base58Check-encoded as a P2SH address becomes +39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw+. Now, Mohammed can give this "address" to his customers and they can use almost any bitcoin wallet to make a simple payment, as if it were a bitcoin address. The 3 prefix gives them a hint that this is a special type of address, one corresponding to a script instead of a public key, but otherwise it works in exactly the same way as a payment to a bitcoin address. 

((("addresses, bitcoin","Pay-to-Script-Hash (P2SH)")))((("Pay-to-script-hash (P2SH)","addresses")))P2SHに関してもう１つの重要な点は、BIP0013で定義されているようにスクリプトハッシュをエンコードしてアドレスとして使えるようにする点です。P2SHアドレスはスクリプトの20バイトハッシュをBase58Checkエンコードしたものです。これはちょうど公開鍵の20バイトハッシュのBase58CheckエンコードをしたBitcoinアドレスのようなものです。P2SHアドレスはversion prefixとして"5"が使われており、Base58Checkエンコードしたアドレスは"3"から始まるものになっています。例えば、ムハンマドの複雑なスクリプトでは、P2SHとして20バイトにハッシュ化されてBase58Checkエンコードを施されたP2SHアドレスは +39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw+ になります。ムハンマドはこの"アドレス"を彼の顧客に送ることで、彼の顧客はBitcoinアドレスに対する支払いとあたかも同じようにウォレットを使うことができます。3というprefixはこのアドレスが特別な種類のアドレスであることを示します。

P2SH addresses hide all of the complexity, so that the person making a payment does not see the script. 

P2SHアドレスは全ての複雑な点を隠蔽し、支払う人がスクリプトを見ることなく支払いができるようにしています。

===== Benefits of pay-to-script-hash 
===== pay-to-script-hashの利点

((("Pay-to-script-hash (P2SH)","benefits of")))The pay-to-script-hash feature offers the following benefits compared to the direct use of complex scripts in locking outputs:

((("Pay-to-script-hash (P2SH)","benefits of")))pay-to-script-hashはlocking scriptを複雑なまま直接扱うことに比べて以下の利点があります。 

* Complex scripts are replaced by shorter fingerprints in the transaction output, making the transaction smaller.
* Scripts can be coded as an address, so the sender and the sender's wallet don't need complex engineering to implement P2SH.
* P2SH shifts the burden of constructing the script to the recipient, not the sender.
* P2SH shifts the burden in data storage for the long script from the output (which is in the UTXO set) to the input (stored on the blockchain).
* P2SH shifts the burden in data storage for the long script from the present time (payment) to a future time (when it is spent).
* P2SH shifts the transaction fee cost of a long script from the sender to the recipient, who has to include the long redeem script to spend it.

* より短いフィンガープリントで複雑なスクリプトを置き換えることで、トランザクションのデータサイズを小さくする
* スクリプトがアドレスとして実装されることで、送り主と送り主のウォレットはP2SHに関する複雑な実装をする必要がない
* P2SHは、スクリプトを構成する負担を送り手ではなく受け手側に移している
* P2SHは、アウトプットが持つ長いスクリプト(これはUTXOセットに含まれるためメモリを圧迫する)をインプット側(ブロックチェーン上にのみ保存される)に移すことでデータストレージの負担をインプット側に移している
* P2SHは、支払い時点に生じる長いスクリプトを資金が使われる時点で生じるようにすることで、データストレージの負担が生じる時刻を移している
* P2SHは、送り手が長いスクリプトを伴って資金を送るときに負担するトランザクション手数料を、受け手がredeem scriptを使って資金を使うときに負担するように変更している

===== Redeem script and isStandard validation
===== redeem scriptとisStandard検証

((("pay-to-script-hash (P2SH)","isStandard validation")))((("pay-to-script-hash (P2SH)","redeem script for")))Prior to version 0.9.2 of the Bitcoin Core client, pay-to-script-hash was limited to the standard types of bitcoin transaction scripts, by the +isStandard()+ function. That means that the redeem script presented in the spending transaction could only be one of the standard types: P2PK, P2PKH, or multi-sig nature, excluding +OP_RETURN+ and P2SH itself.

((("pay-to-script-hash (P2SH)","isStandard validation")))((("pay-to-script-hash (P2SH)","redeem script for")))Bitcoin Coreクライアントのバージョン0.9.2より前では、pay-to-script-hashは +isStandard()+ 関数によって標準的なBitcoinトランザクションスクリプトに含められていませんでした。これは、トランザクションを使用するときに提供されるredeem scriptが、 +OP_RETURN+ とP2SH自身を除くP2PK、P2PKH、マルチシグネチャーのうちのどれか１つに統合されるしかないということを意味しています。

As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can contain any valid script, making the P2SH standard much more flexible and allowing for experimentation with many novel and complex types of transactions.  

現在のBitcoin Coreクライアントのバージョン0.9.2では、P2SHトランザクションは有効なスクリプトはなんでも含むことができ、P2SHはもっとフレキシブルになり、多くの斬新であり、またトランザクションが複合された実験が許可されています。

Note that you are not able to put a P2SH inside a P2SH redeem script, because the P2SH specification is not recursive. You are also still not able to use +OP_RETURN+ in a redeem script because +OP_RETURN+ cannot be redeemed by definition.

P2SH redeem scriptの中にP2SHを置くことはできないという点に注意してください。というのは、P2SHの設計で再帰ができないようになっているためです。また、まだredeem scriptの中で +OP_RETURN+ を使用することはできません。 +OP_RETURN+ は定義によってあとでこれを含むアウトプットを使用するということができないためです。

Note that because the redeem script is not presented to the network until you attempt to spend a P2SH output, if you lock an output with the hash of an invalid transaction it will be processed regardless. However, you will not be able to spend it because the spending transaction, which includes the redeem script, will not be accepted because it is an invalid script. This creates a risk, because you can lock bitcoin in a P2SH that cannot be spent later. The network will accept the P2SH encumbrance even if it corresponds to an invalid redeem script, because the script hash gives no indication of the script it represents. 

注意点として、redeem scriptはP2SHアウトプットを使用しようとするまでBitcoinネットワークに提供されません。このため、もし無効なトランザクションのハッシュを伴ったアウトプットをロックした場合も、お構いなしにBitcoinノードの検証をパスします。しかし、このアウトプットを使うことはできません。なぜなら、このアウトプットを使用しようとするトランザクションはredeem scriptを含んでいますが、このscriptが無効であるためトランザクションが受理されないのです。これはリスクを生み出してしまいます。というのは、あとで使用することができないP2SHにbitcoinがロックされてしまうためです。このredeem scriptハッシュだけではredeem scriptが無効であるか分からないため、たとえ無効なredeem scriptだとしてもBitcoinネットワークはP2SH解除条件をパスしてしまうでしょう。

[WARNING]
====
((("Pay-to-Script-Hash (P2SH)","locking scripts")))P2SH locking scripts contain the hash of a redeem script, which gives no clues as to the content of the redeem script itself. The P2SH transaction will be considered valid and accepted even if the redeem script is invalid. You might accidentally lock bitcoin in such a way that it cannot later be spent.(((range="endofrange", startref="ix_ch05-asciidoc19")))(((range="endofrange", startref="ix_ch05-asciidoc18")))(((range="endofrange", startref="ix_ch05-asciidoc17")))(((range="endofrange", startref="ix_ch05-asciidoc0"))) 

((("Pay-to-Script-Hash (P2SH)","locking scripts")))P2SH locking scriptはredeem scriptのハッシュを含んでいます。このハッシュは、redeem scriptそのものの推測に関して一切ヒントを与えません。もしこのredeem scriptが無効だったとしてもP2SHトランザクションは有効だと考えられ受け入れられてしまいます。間違ってあとで使えないような方法でbitcoinをロックしてしまうかもしれません。(((range="endofrange", startref="ix_ch05-asciidoc19")))(((range="endofrange", startref="ix_ch05-asciidoc18")))(((range="endofrange", startref="ix_ch05-asciidoc17")))(((range="endofrange", startref="ix_ch05-asciidoc0")))
====


[[bitcoin_network_ch06]]
== The Bitcoin Network
== Bitcoinネットワーク

=== Peer-to-Peer Network Architecture
=== Peer-to-Peer ネットワーク設計

((("bitcoin network", id="ix_ch06-asciidoc0", range="startofrange")))((("bitcoin network","architecture of")))((("peer-to-peer networks")))Bitcoin is structured as a peer-to-peer network architecture on top of the Internet. The term peer-to-peer, or P2P, means that the computers that participate in the network are peers to each other, that they are all equal, that there are no "special" nodes, and that all nodes share the burden of providing network services. The network nodes interconnect in a mesh network with a "flat" topology. There is no server, no centralized service, and no hierarchy within the network. Nodes in a peer-to-peer network both provide and consume services at the same time with reciprocity acting as the incentive for participation. Peer-to-peer networks are inherently resilient, decentralized, and open. The preeminent example of a P2P network architecture was the early Internet itself, where nodes on the IP network were equal. Today's Internet architecture is more hierarchical, but the Internet Protocol still retains its flat-topology essence. Beyond bitcoin, the largest and most successful application of P2P technologies is file sharing with Napster as the pioneer and BitTorrent as the most recent evolution of the architecture.

((("bitcoin network", id="ix_ch06-asciidoc0", range="startofrange")))((("bitcoin network","architecture of")))((("peer-to-peer networks")))Bitcoinはインターネット上のpeer-to-peerネットワークとして構築されています。peer-to-peer、またはP2Pという言葉は、ネットワークに参加しているコンピュータがそれぞれ同等の立場を持ち、"特別な"ノードがなく、全てのノードがサービス負荷を負担し合っていることを指します。ネットワークノードは"フラット"なトポロジーを持つメッシュネットワークの中で互いに繋がっています。ここにサーバ、どこかに中央を持つサービス、ネットワーク内の階層はありません。peer-to-peerネットワーク内のノードは、サービスを提供もしまた同時に消費もすることで、ネットワークへ参加することのインセンティブとしての相互利益を保っています。peer-to-peerネットワークは本質的に活発であり、非中央的でオープンです。P2Pネットワークの代表的な例は初期インターネットそのもので、IPネットワーク上のノードは全て平等でした。今日のインターネットの構造はより階層的になりましたが、インターネットプロトコルはまだフラットトポロジーのエッセンスを保っています。Bitcoinが現れる前にP2Pテクノロジーを使った最も大きく最も成功したサービスはファイル共有であり、パイオニアとしてはNapster、最近の発展の牽引としてはBitTorrentなどがあります。

Bitcoin's P2P network architecture is much more than a topology choice. Bitcoin is a peer-to-peer digital cash system by design, and the network architecture is both a reflection and a foundation of that core characteristic. Decentralization of control is a core design principle and that can only be achieved and maintained by a flat, decentralized P2P consensus network. 

Bitcoinは計画的に構築されたpeer-to-peerのデジタルキャッシュシステムで、ネットワークアーキテクチャはBIPによる自己反映型、Bitcoin Foundationによる統率型の両方の形で決められていきます。????非中央的コントロールはBitcoinのコアデザインの原則であり、フラットで非中央的なP2Pコンセンサスネットワークによってメンテナンスされています。

((("bitcoin network","defined")))The term "bitcoin network" refers to the collection of nodes running the bitcoin P2P protocol. In addition to the bitcoin P2P protocol, there are other protocols such as((("Stratum (STM) mining protocol"))) Stratum, which are used for mining and lightweight or mobile wallets. These additional protocols are provided by gateway routing servers that access the bitcoin network using the bitcoin P2P protocol, and then extend that network to nodes running other protocols. For example, Stratum servers connect Stratum mining nodes via the Stratum protocol to the main bitcoin network and bridge the Stratum protocol to the bitcoin P2P protocol. We use the term "extended bitcoin network" to refer to the overall network that includes the bitcoin P2P protocol, pool-mining protocols, the Stratum protocol, and any other related protocols connecting the components of the bitcoin system. 

((("bitcoin network","defined")))"Bitcoinネットワーク"という言葉は、Bitcoin P2Pプロトコルが動作しているBitcoinノード全体を指します。Bitcoin P2Pプロトコルに加えて、((("Stratum (STM) mining protocol"))) Stratumのような他のプロトコルもあり、Stratumはマイニング、軽量またはモバイルのウォレットに使われたりします。これらの他のプロトコルは、Bitcoin P2Pプロトコルを使っているBitcoinネットワークにアクセスするサーバをルーティングするゲートウェイで使われています。また、これにより他のプロトコルで動くノードにネットワークを拡げることができます。例えば、StratumサーバはStratumマイニングノードをStratumプロトコルを通してメインのBitcoinネットワークに接続させ、StratumプロトコルとBitcoin P2Pプロトコルの橋渡しをします。Bitcoin P2Pプロトコル、プールマイニングプロトコル、Stratumプロトコル、およびBitcoinシステムの各要素を繋げるその他の関連したプロトコルを全て含む全ネットワークを"拡張されたBitcoinネットワーク"という言葉で表します。

=== Nodes Types and Roles
=== ノードタイプと役割

((("bitcoin network","nodes")))((("nodes","roles of")))((("nodes","types of")))Although nodes in the bitcoin P2P network are equal, they may take on different roles depending on the functionality they are supporting. A bitcoin node is a collection of functions: routing, the blockchain database, mining, and wallet services. A full node with all four of these functions is shown in <<full_node_reference>>.

((("bitcoin network","nodes")))((("nodes","roles of")))((("nodes","types of")))Bitcoin P2Pネットワーク内のノードは平等ではありますが、これらはいくつかの役割に分かれています。Bitcoinノードは、ルーティング、ブロックチェーンデータベース、マイニング、ウォレットという機能の集合体です。これらの機能４つを全て持つfull-nodeが<<full_node_reference>>図で示されています。

[[full_node_reference]]
.A bitcoin network node with all four functions: wallet, miner, full blockchain database, and network routing
.４種類のBitcoinネットワークノード機能: ウォレット、マイナー、フルブロックチェーンデータベース、ネットワークルーティング
image::images/msbt_0601.png["FullNodeReferenceClient_Small"]

All nodes include the routing function to participate in the network and might include other functionality. All nodes validate and propagate transactions and blocks, and discover and maintain connections to peers. In the full-node example in <<full_node_reference>>, the routing function is indicated by an orange circle named "Network Routing Node." 

全てのノードはBitcoinネットワークに参加するためにルーティング機能を必ず持っていて、その他の機能は持っていたり持っていなかったりします。全てのノードはトランザクションとブロックを検証して伝搬し、その他のピアを発見してコネクションを常に保っています。<<full_node_reference>>図のfull-node例では、ルーティング機能を"Network Routing Node"と書いてあるオレンジの円で示しています。

Some nodes, called full nodes, also maintain a complete and up-to-date copy of the blockchain. Full nodes can autonomously and authoritatively verify any transaction without external reference. Some nodes maintain only a subset of the blockchain and verify transactions using a method called((("simplified payment verification (SPV) nodes","defined"))) _simplified payment verification_, or SPV. These nodes are known as SPV or lightweight nodes. In the full-node example in the figure, the full-node blockchain database function is indicated by a blue circle named "Full Blockchain." In <<bitcoin_network>>, SPV nodes are drawn without the blue circle, showing that they do not have a full copy of the blockchain. 

full-nodeと呼ばれるいくつかのノードは、完全で最新のブロックチェーンの管理もしています。full-nodeは外部への参照をすることなく閉じられた形で匿名的かつ厳然にトランザクションを検証します。いくつかのノードはブロックチェーンの一部の管理のみを行っており、((("simplified payment verification (SPV) nodes","defined"))) _simplified payment verification_ または SPV と呼ばれている方法でトランザクションを検証します。これらのノードはSPVまたは軽量ノードと呼ばれています。さきほどの図にあったfull-node例では、full-nodeのブロックチェーンデータベースを"Full Blockchain"と書いてあるブルーの円で示しています。<<bitcoin_network>>図では、SPVノードがブルーの円がない形で描かれており、これはブロックチェーンの完全なコピーを持たないということを表しています。

Mining nodes compete to create new blocks by running specialized hardware to solve the proof-of-work algorithm. Some mining nodes are also full nodes, maintaining a full copy of the blockchain, while others are lightweight nodes participating in pool mining and depending on a pool server to maintain a full node. The mining function is shown in the full node as a black circle named "Miner."

マイニングノードは新しいブロックを作り出す競争をしており、proof-of-workアルゴリズムを解くための特別なハードウェアを動作させて行っています。いくつかのマイニングノードはfull-nodeでもあり、ブロックチェーンの完全なコピーを管理しています。一方それ以外はマイニングプールに参加している軽量ノードであり、full-nodeを管理しているプールサーバに依存しています。 

User wallets might be part of a full node, as is usually the case with desktop bitcoin clients. Increasingly, many user wallets, especially those running on resource-constrained devices such as smartphones, are SPV nodes. The wallet function is shown in <<full_node_reference>> as a green circle named "Wallet".

ユーザウォレットは一部がfull nodeになっており、通常デスクトップBitcoinクライアントという形でfull nodeになっています。スマートフォンなどリソースが限られているデバイスでは多くのユーザウォレットがSPVノードになっています。ウォレット機能は<<full_node_reference>>図にある"Wallet"と書かれたグリーンの円で示されています。

In addition to the main node types on the bitcoin P2P protocol, there are servers and nodes running other protocols, such as specialized mining pool protocols and lightweight client-access protocols. 

Bitcoin P2Pプロトコル上の主なノードタイプに加えて、その他のプロトコルで動作しているノードもあります。例えば、マイニングプール特化型プロトコルや軽量クライアントアクセスプロトコルなどです。

<<node_type_ledgend>> shows the most common node types on the extended bitcoin network.

<<node_type_ledgend>>は拡張されたBitcoinネットワーク上の主なノードタイプを示しています。

=== The Extended Bitcoin Network
=== 拡張されたBitcoinネットワーク

((("bitcoin network","extended")))((("extended bitcoin network")))The main bitcoin network, running the bitcoin P2P protocol, consists of between 7,000 and 10,000 listening nodes running various versions of the bitcoin reference client (Bitcoin Core) and a few hundred nodes running various other implementations of the bitcoin P2P protocol, such as((("BitcoinJ library")))((("btcd")))((("libbitcoin library"))) BitcoinJ, Libbitcoin, and btcd. A small percentage of the nodes on the bitcoin P2P network are also mining nodes, competing in the mining process, validating transactions, and creating new blocks. Various large companies interface with the bitcoin network by running full-node clients based on the Bitcoin Core client, with full copies of the blockchain and a network node, but without mining or wallet functions. These nodes act as network edge routers, allowing various other services (exchanges, wallets, block explorers, merchant payment processing) to be built on top. 

((("bitcoin network","extended")))((("extended bitcoin network")))Bitcoin P2Pプロトコルが動作しているメインのBitcoinネットワークは7000から10000個のノードから構成されており、それぞれBitcoin参照クライアント(Bitcoin Core)のいろいろなバージョンが動作しています。また、数百個のノードはBitcoin P2Pプロトコルとは別の((("BitcoinJ library")))((("btcd")))((("libbitcoin library"))) BitcoinJ、Libbitcoin、およびbtcdなどの実装が動作しています。Bitcoin P2Pネットワーク上の少数のノードはマイニングノードも兼ねていて、マイニング、トランザクション検証、新ブロック生成の競争をしています。いろいろな大きな企業は、Bitcoin Coreクライアントをベースとするfull-nodeクライアントを使ってBitcoinネットワークと通信をしており、これらはブロックチェーンの完全なコピーやネットワークノードとしての機能を持っているもののマイニングやウォレットの機能は持ちません。これらのノードはネットワークエッジルーターとして機能しており、いろいろなその他のサービス(交換所、ウォレット、ブロックエクプローラ、決済システム)を構築できるようにしています。

The extended bitcoin network includes the network running the bitcoin P2P protocol, described earlier, as well as nodes running specialized protocols. Attached to the main bitcoin P2P network are a number of((("mining pools","on the bitcoin network"))) pool servers and protocol gateways that connect nodes running other protocols. These other protocol nodes are mostly pool mining nodes (see <<ch8>>) and lightweight wallet clients, which do not carry a full copy of the blockchain. 

以前説明したように拡張されたBitcoinネットワークはBitcoin P2Pプロトコルが動作しているネットワークを含んでおり、また一部分に特化したプロトコルで動作しているノードもあります。メインのBitcoin P2Pネットワークに接続しているノードは、多くの((("mining pools","on the bitcoin network")))プールサーバや、その他のプロトコルで動作しているノードに接続しているプロトコルゲートウェイです。

<<bitcoin_network>> shows the extended bitcoin network with the various types of nodes, gateway servers, edge routers, and wallet clients and the various protocols they use to connect to each other. 

<<bitcoin_network>>図は拡張されたBitcoinネットワークを示しており、ノードのいろいろなタイプ、ゲートウェイサーバ、エッジルーター、およびウォレットクライアント、またそれぞれが接続し合うために使っているいろいろなプロトコルを示しています。

[[node_type_ledgend]]
.Different types of nodes on the extended bitcoin network
.拡張されたBitcoinネットワーク上の様々なノードタイプ
image::images/msbt_0602.png["BitcoinNodeTypes"]

[[bitcoin_network]]
.The extended bitcoin network showing various node types, gateways, and protocols
.いろいろなノードタイプやゲートウェイ、プロトコルを表した拡張されたBitcoinネットワーク全体図
image::images/msbt_0603.png["BitcoinNetwork"]

=== Network Discovery
=== ネットワークをどのように発見するのか

((("bitcoin network","discovery", id="ix_ch06-asciidoc1", range="startofrange")))((("network discovery", id="ix_ch06-asciidoc2", range="startofrange")))((("nodes","network discovery and", id="ix_ch06-asciidoc3", range="startofrange")))((("peer-to-peer networks","discovery by new nodes", id="ix_ch06-asciidoc4", range="startofrange")))When a new node boots up, it must discover other bitcoin nodes on the network in order to participate. To start this process, a new node must discover at least one existing node on the network and connect to it. The geographic location of other nodes is irrelevant; the bitcoin network topology is not geographically defined. Therefore, any existing bitcoin nodes can be selected at random. 

((("bitcoin network","discovery", id="ix_ch06-asciidoc1", range="startofrange")))((("network discovery", id="ix_ch06-asciidoc2", range="startofrange")))((("nodes","network discovery and", id="ix_ch06-asciidoc3", range="startofrange")))((("peer-to-peer networks","discovery by new nodes", id="ix_ch06-asciidoc4", range="startofrange")))新しいノードが立ち上がったとき、Bitcoinネットワークに参加するには他のBitcoinノードを見つけなければいけません。このプロセスを始めるために、新しいノードは少なくとも１個のノードを見つけ接続しなければいけません。他のノードの地理的な位置は関係ありません。というのは、Bitcoinネットワークのトポロジーは地理と関連づけて決められてはいないからです。このため、ランダムにノードが選ばれ得ます。

((("peer-to-peer networks","connections")))To connect to a known peer, nodes establish a TCP connection, usually to port 8333 (the port generally known as the one used by bitcoin), or an alternative port if one is provided. Upon establishing a connection, the node will start a "handshake" (see <<network_handshake>>) by transmitting a((("version message")))  +version+ message, which contains basic identifying information, including:

((("peer-to-peer networks","connections")))知られているピアに接続するために、ノードはTCPコネクションを確立し、通常8333番ポート(一般にBitcoinによって使われているポート)または提供されているなら代替のポートを使います。コネクションを確立すると、ノードは((("version message"))) +version+ messageを送信することで"ハンドシェイク"を始めます(<<network_handshake>>参照)。version messageはと、以下のような基本的な識別情報を含んでいるものです。

+PROTOCOL_VERSION+:: A constant that defines the bitcoin P2P protocol version the client "speaks" (e.g., 70002)
+nLocalServices+:: A list of local services supported by the node, currently just +NODE_NETWORK+
+nTime+:: The current time
+addrYou+:: The IP address of the remote node as seen from this node
+addrMe+:: The IP address of the local node, as discovered by the local node
+subver+:: A sub-version showing the type of software running on this node (e.g., "/Satoshi:0.9.2.1/")+
+BestHeight+:: The block height of this node's blockchain

+PROTOCOL_VERSION+:: クライアントが"会話をする"Bitcoin P2Pプロトコルバージョンを示す定数 (例えば 70002)
+nLocalServices+:: ノードがサポートしているローカルサービスのリスト、現状 +NODE_NETWORK+ のみ
+nTime+:: 現在時刻
+addrYou+:: このノードから見えるリモートノードのIP address
+addrMe+:: ローカルノードのIP address
+subver+:: このノード上で動作しているソフトウェアの種類を示すサブバージョン (例えば "/Satoshi:0.9.2.1/")+
+BestHeight+:: このノードのブロックチェーンのブロック高

(See http://bit.ly/1qlsC7w[GitHub] for an example of the +version+ network message.)

(+version+ network messageの例については http://bit.ly/1qlsC7w[GitHub] 参照)

The peer node responds with +verack+ to acknowledge and establish a connection, and optionally sends its own +version+ message if it wishes to reciprocate the connection and connect back as a peer. 

ピアノードはコネクションを承認し確立するために +verack+ を返します。場合によっては、もしコネクションのお返しにピアとして接続し直す場合は自身の +version+ messageを送ります。????

How does a new node find peers? The first method is to query DNS using a number of ((("nodes","seed")))((("DNS seed")))"DNS seeds," which are DNS servers that provide a list of IP addresses of bitcoin nodes. Some of those DNS seeds provide a static list of IP addresses of stable bitcoin listening nodes. Some of the DNS seeds are custom implementations of BIND (Berkeley Internet Name Daemon) that return a random subset from a list of bitcoin node addresses collected by a crawler or a long-running bitcoin node.  The Bitcoin Core client contains the names of five different DNS seeds. The diversity of ownership and diversity of implementation of the different DNS seeds offers a high level or reliability for the initial bootstrapping process. In the Bitcoin Core client, the option to use the DNS seeds is controlled by the option switch +-dnsseed+ (set to 1 by default, to use the DNS seed).

新しいノードはどのようにしてピアを見つけるのでしょうか？最初の方法はたくさんの"DNSシード"を使ってDNSにクエリを投げることです。DNSシードはBitcoinノードのIPアドレスリストを提供するDNSサーバです。DNSシードのうちいくつかは安定的にリクエストを受け付けているBitcoinノードの静的なIPアドレスを返却しています。また、いくつかのDNSシードは、クローラや長期的に稼働しているBitcoinノードによって集められたBitcoinノードのリストからランダムにいくつかを選んで返却するカスタマイズされたBIND(Berkeley Internet Name Daemon)で実装されています。Bitcoin Coreクライアントは５つのDNSシードを含んでいます。これらは所有者やDNSシードの実装が多様になるように構成され、確実に初期状態構築プロセスが実行できるようになっています。Bitcoin Coreクライアントでは、DNSシードを使うかどうかを +-dnsseed+ オプションでコントロールできるようになっています(1がデフォルトで、デフォルトでDNSシードを使用するようになっています)。

Alternatively, a bootstrapping node that knows nothing of the network must be given the IP address of at least one bitcoin node, after which it can establish connections through further introductions. The command-line argument +-seednode+ can be used to connect to one node just for introductions, using it as a seed. After the initial seed node is used to form introductions, the client will disconnect from it and use the newly discovered peers. 

DNSシードを使わない場合、Bitcoinネットワークについて何も知らない初期状態構築中のノードには少なくとも１つのBitcoinノードのIPアドレスが与えられなければいけません。その後、このノードはさらに導入手続きを進めて他のノードとのコネクションを確立します。コマンドラインオプション +-seednode+ は一番最初のシードBitcoinノードとコネクションを確立するために使われます。導入手続きで最初のシードノードが使われた後、Bitcoinクライアントはこのシードノードとのコネクションを切り、新たに発見したピアを使うようになります。

[[network_handshake]]
.The initial handshake between peers
.ピア同士の最初のハンドシェイク
image::images/msbt_0604.png["NetworkHandshake"]

Once one or more connections are established, the new node will send an((("addr message"))) +addr+ message containing its own IP address to its neighbors. The neighbors will, in turn, forward the +addr+ message to their neighbors, ensuring that the newly connected node becomes well known and better connected. Additionally, the newly connected node can send +getaddr+ to the neighbors, asking them to return a list of IP addresses of other peers. That way, a node can find peers to connect to and advertise its existence on the network for other nodes to find it. <<address_propagation>> shows the address discovery protocol. 

一度１つまたはそれ以上のコネクションを確立すると、新しいノードは((("addr message"))) +addr+ messageという自身のIP addressが含まれた情報を隣接ノードに送信します。隣接ノードは次々に +addr+ messageを彼らの近くのノードに転送し、確実に新しく接続されたノードがwell knownになるようにします。また、新しく接続されたノードは +getaddr+ を隣接ノードに送ることができ、他のピアのIP addressリストを返してもらうようにお願いすることもできます。そうすれば、ノードは接続するピアを新たに見つけることができ、その存在を他のノードに知らせることができるのです。<<address_propagation>>図はアドレスを発見する手順を示しています。

[[address_propagation]]
.Address propagation and discovery
.自身のIPアドレスの伝搬と他のIPアドレスの発見
image::images/msbt_0605.png["AddressPropagation"]

A node must connect to a few different peers in order to establish diverse paths into the bitcoin network. Paths are not reliable—nodes come and go—and so the node must continue to discover new nodes as it loses old connections as well as assist other nodes when they bootstrap. Only one connection is needed to bootstrap, because the first node can offer introductions to its peer nodes and those peers can offer further introductions. It's also unnecessary and wasteful of network resources to connect to more than a handful of nodes. After bootstrapping, a node will remember its most recent successful peer connections, so that if it is rebooted it can quickly reestablish connections with its former peer network. If none of the former peers respond to its connection request, the node can use the seed nodes to bootstrap again. 

ノードは２、３個の異なったピアと接続し、Bitcoinネットワークへの多様なパスを確立しなければいけません。このパスは信頼できるものではありません(ノードは連絡なく通信が切れたり復活したりする)。このため、他のノードの初期状態構築時にアシストするという目的だけでなく、古いコネクションを失ったときのためにもノードは常に新しいノードを見つけ続けなければいけません。最初に接続するノードはそのピアノードに導入手順を提供するため、初期状態構築をするためには少なくとも１個のコネクションがなければなりません。初期状態構築を終えた後ノードは最も最近うまくコネクションを張れたピアを覚えておき、リブートしたときにすばやく覚えておいたピアとコネクションを張ります。以前繋がっていたどのピアもコネクションリクエストに答えなければ、そのノードは再度シードノードを使って初期状態構築を行うことができます。

On a node running the Bitcoin Core client, you can list the peer connections with the command((("getpeerinfo command"))) +getpeerinfo+:

Bitcoin Coreクライアントが動作しているノードでは、((("getpeerinfo command"))) +getpeerinfo+ のコマンドを使ってピアコネクションを表示することができます。

[source,bash]
----
$ bitcoin-cli getpeerinfo
----
[source,json]
----
[
    {
        "addr" : "85.213.199.39:8333",
        "services" : "00000001",
        "lastsend" : 1405634126,
        "lastrecv" : 1405634127,
        "bytessent" : 23487651,
        "bytesrecv" : 138679099,
        "conntime" : 1405021768,
        "pingtime" : 0.00000000,
        "version" : 70002,
        "subver" : "/Satoshi:0.9.2.1/",
        "inbound" : false,
        "startingheight" : 310131,
        "banscore" : 0,
        "syncnode" : true
    },
    {
        "addr" : "58.23.244.20:8333",
        "services" : "00000001",
        "lastsend" : 1405634127,
        "lastrecv" : 1405634124,
        "bytessent" : 4460918,
        "bytesrecv" : 8903575,
        "conntime" : 1405559628,
        "pingtime" : 0.00000000,
        "version" : 70001,
        "subver" : "/Satoshi:0.8.6/",
        "inbound" : false,
        "startingheight" : 311074,
        "banscore" : 0,
        "syncnode" : false
    }
]
----

((("peer-to-peer networks","automatic management, overriding")))To override the automatic management of peers and to specify a list of IP addresses, users can provide the option +-connect=<IPAddress>+ and specify one or more IP addresses. If this option is used, the node will only connect to the selected IP addresses, instead of discovering and maintaining the peer connections automatically. 

((("peer-to-peer networks","automatic management, overriding")))自動的に行われるピア管理ではなく特定のピアのIP addressを指定するために +-connect=<IPAddress>+ オプションが用意されていて、１つまたは複数のIP addressを指定できます。このオプションが使われると、自動的にピアを見つけたりすることはせずにノードは選択されたIP addressにしか接続しないようになります。

If there is no traffic on a connection, nodes will periodically send a message to maintain the connection. If a node has not communicated on a connection for more than 90 minutes, it is assumed to be disconnected and a new peer will be sought. Thus, the network dynamically adjusts to transient nodes and network problems, and can organically grow and shrink as needed without any central control.(((range="endofrange", startref="ix_ch06-asciidoc4")))(((range="endofrange", startref="ix_ch06-asciidoc3")))(((range="endofrange", startref="ix_ch06-asciidoc2")))(((range="endofrange", startref="ix_ch06-asciidoc1")))

コネクション上に何もトラフィックがない場合、ノードは定期的にコネクション維持のためメッセージを送ります。90分以上何の通信もしなかったコネクションがあった場合、ノードはコネクションが切れたとみなし新しいピアを探し始めます。このように、Bitcoinネットワークは常に一時的なノードやネットワークの問題を調整しながら、中央のコントロールなしに必要に応じて有機的に成長または縮小を繰り返します。

=== Full Nodes
=== Full Nodes

((("blockchains","full nodes and")))((("full nodes")))((("nodes","full")))Full nodes are nodes that maintain a full blockchain with all transactions. More accurately, they probably should be called "full blockchain nodes." In the early years of bitcoin, all nodes were full nodes and currently the Bitcoin Core client is a full blockchain node. In the past two years, however, new forms of bitcoin clients have been introduced that do not maintain a full blockchain but run as lightweight clients. We'll examine these in more detail in the next section. 

((("blockchains","full nodes and")))((("full nodes")))((("nodes","full")))full nodeは全てのトランザクションを持っている完全なブロックチェーンを管理しているノードです。もっと正確に言うと、full nodeはおそらく"フルブロックチェーンノード"と呼ばれるべきです。Bitcoinの初期の頃全てのノードはfull nodeでしたが、現在はBitcoin Coreがフルブロックチェーンノードです。これは２年前からBitcoinクライアントの新しい形が導入されてきたためです。新しい形というのは完全なブロックチェーンを管理する形ではなく軽量クライアントとして動かすという形です。次の節でこの詳細を説明します。

((("blockchains","on full nodes")))Full blockchain nodes maintain a complete and up-to-date copy of the bitcoin blockchain with all the transactions, which they independently build and verify, starting with the very first block (genesis block) and building up to the latest known block in the network. A full blockchain node can independently and authoritatively verify any transaction without recourse or reliance on any other node or source of information. The full blockchain node relies on the network to receive updates about new blocks of transactions, which it then verifies and incorporates into its local copy of the blockchain. 

((("blockchains","on full nodes")))フルブロックチェーンノードは完全で最新のブロックチェーンコピーを管理しており、これらノードは独立に最初のブロック(起源ブロック)から最新のブロックまでを構築し検証します。また、フルブロックチェーンノードは他のノードや情報源に頼ることなく独立的かつ厳然にどんなトランザクションでも検証します。フルブロックチェーンノードはBitcoinネットワークに頼ることで新しいトランザクションのブロックをBitcoinネットワークから受け取り、それらを検証した後ブロックチェーンのローカルコピーに追加していきます。

Running a full blockchain node gives you the pure bitcoin experience: independent verification of all transactions without the need to rely on, or trust, any other systems. It's easy to tell if you're running a full node because it requires 20+ gigabytes of persistent storage (disk space) to store the full blockchain. If you need a lot of disk and it takes two to three days to sync to the network, you are running a full node. That is the price of complete independence and freedom from central authority. 

フルブロックチェーンノードを動作させてみると分かるように、他のノードを全く信頼することも頼ることもなく全てのトランザクションの検証が独立に進められていきます。フルブロックチェーンを保持するために20GB強のストレージが必要であるため、フルブロックチェーンノードを走らせるには多くのディスク容量とBitcoinネットワークからブロックチェーンをダウンロードするための２、３日の時間が必要です。

There are a few alternative implementations of full blockchain bitcoin clients, built using different programming languages and software architectures. However, the most common implementation is the reference client((("Bitcoin Core client","and full nodes"))) Bitcoin Core, also known as the Satoshi client. More than 90% of the nodes on the bitcoin network run various versions of Bitcoin Core. It is identified as "Satoshi" in the sub-version string sent in the +version+ message and shown by the command +getpeerinfo+ as we saw earlier; for example, +/Satoshi:0.8.6/+.

いくつかのフルブロックチェーンBitcoinクライアントの代替実装があり、別のプログラミング言語やソフトウェア設計で構築されています。しかし、主な実装はBitcoin参照クライアント((("Bitcoin Core client","and full nodes"))) Bitcoin Coreであり、Satoshiクライアントと呼ばれています。Bitcoinネットワーク上の90%以上のノードがBitcoin Coreのいろいろなバージョンで動作しています。このバージョンは+/Satoshi:0.8.6/+のように表示され、"Satoshi"のあとに、前に見た+getpeerinfo+コマンドの結果に出てくるsubversionが付加された形になっています。

=== Exchanging "Inventory"
=== "Inventory"の交換

((("blockchains","creating on nodes")))((("blockchains","on new nodes")))((("blocks","on new nodes")))((("full nodes","creating full blockchains on")))The first thing a full node will do once it connects to peers is try to construct a complete blockchain. If it is a brand-new node and has no blockchain at all, it only knows one block, the genesis block, which is statically embedded in the client software. Starting with block #0 (the genesis block), the new node will have to download hundreds of thousands of blocks to synchronize with the network and re-establish the full blockchain. 

((("blockchains","creating on nodes")))((("blockchains","on new nodes")))((("blocks","on new nodes")))((("full nodes","creating full blockchains on")))full nodeがピアと接続して最初にやることは、完全なブロックチェーンを構築することです。もしノードが新しくできたもので全くブロックチェーンを持っていなければ、Bitcoin Coreに埋め込まれている１個のブロック、起源ブロック、しか知りません。このため、新しいノードは数十万ブロックものブロックをBitcoinネットワークからダウンロード＆同期して、フルブロックチェーンを再構築しなければいけません。

((("syncing the blockchain")))The process of syncing the blockchain starts with the +version+ message, because that contains +BestHeight+, a node's current blockchain height (number of blocks). A node will see the +version+ messages from its peers, know how many blocks they each have, and be able to compare to how many blocks it has in its own blockchain. Peered nodes will exchange a +getblocks+ message that contains the hash (fingerprint) of the top block on their local blockchain. One of the peers will be able to identify the received hash as belonging to a block that is not at the top, but rather belongs to an older block, thus deducing that its own local blockchain is longer than its peer's. 

((("syncing the blockchain")))ブロックチェーンの同期プロセスは、+version+ messageから始まります。というのは、+version+ messageにノードの現在のブロックチェーン高(ブロック数)を示す+BestHeight+が含まれているからです。ノードは+version+ messagesを見て相手のピアが何ブロック保持しているかを知ることで、自身のブロックチェーンと比較できるようになります。次にピアノードは互いにローカルブロックチェーンのトップブロックハッシュ(フィンガープリント)を含む +getblocks+ messageを交換します。ピアのうちの一つは、トップブロックのハッシュと受け取ったハッシュは違っても、古いブロックのハッシュと受け取ったハッシュが一致することが分かったとすると、このことから自身の持っているブロックチェーンが相手のピアよりも長いということを知ることができます。

The peer that has the longer blockchain has more blocks than the other node and can identify which blocks the other node needs in order to "catch up." It will identify the first 500 blocks to share and transmit their hashes using an((("inv messages"))) +inv+ (inventory) message. The node missing these blocks will then retrieve them, by issuing a series of +getdata+ messages requesting the full block data and identifying the requested blocks using the hashes from the +inv+ message.

より長いブロックチェーンを持っているピアは他のノードよりも多くのブロックを持っており、どのブロックを他のノードが欲しているかを特定することができます。他のノードと共有するべき最初の500ブロックを特定すると、これらブロックそれぞれのハッシュを((("inv messages"))) +inv+ (inventory) messageを使って他のノードに送ります。これらのブロックを持っていないノードは、+inv+ messageにあるハッシュから自身のブロックチェーンに足りないブロックのハッシュを選んだのち +getdata+ messagesを使ってフルブロックデータを送ってもらうようにリクエストを出します。

Let's assume, for example, that a node only has the genesis block. It will then receive an +inv+ message from its peers containing the hashes of the next 500 blocks in the chain. It will start requesting blocks from all of its connected peers, spreading the load and ensuring that it doesn't overwhelm any peer with requests. The node keeps track of how many blocks are "in transit" per peer connection, meaning blocks that it has requested but not received, checking that it does not exceed a limit((("MAX_BLOCKS_IN_TRANSIT_PER_PEER constant"))) (+MAX_BLOCKS_IN_TRANSIT_PER_PEER+). This way, if it needs a lot of blocks, it will only request new ones as previous requests are fulfilled, allowing the peers to control the pace of updates and not overwhelming the network. As each block is received, it is added to the blockchain, as we will see in <<blockchain>>. As the local blockchain is gradually built up, more blocks are requested and received, and the process continues until the node catches up to the rest of the network. 

例えば、あるノードが起源ブロックしか持っていないとしましょう。起源ブロックの次の500ブロックのハッシュを含む +inv+ messageを他のピアから受け取ります。このノードは接続しているピア全てに次の500ブロックに関するブロックデータ送信リクエストを送りますが、このリクエストを送りすぎることによってBitcoinネットワークが破綻しないようになっています。このノードはピアごとに何ブロックがまだ送られてきていない"未達"状態にあるかをトラッキングし続けており、１ピアに対する未達状態最大ブロック数((("MAX_BLOCKS_IN_TRANSIT_PER_PEER constant"))) ( +MAX_BLOCKS_IN_TRANSIT_PER_PEER+ )を越えないようにチェックし続けています。この方法により、もし多くのブロックが必要だったとしても、前のデータ送信リクエストが完了してから次のリクエストを送るようになっています。それぞれのブロックを受け取ると、<<blockchain>>図で見るように、ブロックチェーンに追加されていきます。ローカルブロックチェーンが徐々に構築されていくにつれて、より多くのブロックのリクエスト＆受信がされていき、このノードのブロックチェーンがBitcoinネットワークのブロックチェーンに追いつくまでこのプロセスは続きます。

This process of comparing the local blockchain with the peers and retrieving any missing blocks happens any time a node goes offline for any period of time. Whether a node has been offline for a few minutes and is missing a few blocks, or a month and is missing a few thousand blocks, it starts by sending +getblocks+, gets an +inv+ response, and starts downloading the missing blocks. <<inventory_synchronization>> shows the inventory and block propagation protocol. 

ローカルブロックチェーンと他のピアのブロックチェーンとの比較および不足ブロックの取得プロセスは、ノードがどれくらいの時間オフラインになっていても継続されます。ノードが数分オフラインであったために数ブロックが不足してしまったりしても、または数ヶ月オフラインであったために数千ブロックが不足してしまったりしても、このノードはまず +getblocks+ を送り、 +inv+ レスポンスを受け取り足りないブロックのダウンロードを開始します。


[[spv_nodes]]
=== Simplified Payment Verification (SPV) Nodes
=== Simplified Payment Verification (SPV) Nodes

((("nodes","SPV", id="ix_ch06-asciidoc5", range="startofrange")))((("nodes","lightweight", id="ix_ch06-asciidoc5a", range="startofrange")))((("simplified payment verification (SPV) nodes", id="ix_ch06-asciidoc6", range="startofrange")))Not all nodes have the ability to store the full blockchain. Many bitcoin clients are designed to run on space- and power-constrained devices, such as smartphones, tablets, or embedded systems. For such devices, a _simplified payment verification_ (SPV) method is used to allow them to operate without storing the full blockchain. These types of clients are called SPV clients or lightweight clients. As bitcoin adoption surges, the SPV node is becoming the most common form of bitcoin node, especially for bitcoin wallets.

((("nodes","SPV", id="ix_ch06-asciidoc5", range="startofrange")))((("nodes","lightweight", id="ix_ch06-asciidoc5a", range="startofrange")))((("simplified payment verification (SPV) nodes", id="ix_ch06-asciidoc6", range="startofrange")))全てのノードがフルブロックチェーンを保持する能力を備えているわけではありません。多くのBitcoinクライアントはディスク容量や計算スピードが限られているスマートフォンやタブレット、組み込みシステムなどのデバイス上で動作するように設計されています。このようなデバイスに対しては、フルブロックチェーンを保持することなしに前節で説明したプロセスを実行できるように _simplified payment verification_ (SPV)が使われます。この方法を用いるクライアントをSPVクライアントまたは軽量クライアントと呼びます。このクライアントが多く採用されるにつれて、SPVノードがBitcoinノードの主要な形、Bitcoinウォレット、になっています。

((("blockchains","on SPV nodes")))SPV nodes download only the block headers and do not download the transactions included in each block. The resulting chain of blocks, without transactions, is 1,000 times smaller than the full blockchain. SPV nodes cannot construct a full picture of all the UTXOs that are available for spending because they do not know about all the transactions on the network. SPV nodes verify transactions using a slightly different methodology that relies on peers to provide partial views of relevant parts of the blockchain on demand.

((("blockchains","on SPV nodes")))SPVノードはブロックヘッダだけをダウンロードしトランザクション自体はダウンロードしません。トランザクションがないヘッダだけのブロックチェーンはフルブロックチェーンの1/1000くらいの大きさになります。SPVノードはBitcoinネットワーク上の全てのトランザクションについて知っているわけではないため、使用可能な全てのUTXOを構築できません。SPVノードは、必要に応じてブロックチェーンの関連した部分のみを提供するピアに頼るという方法を用いてトランザクションを検証します。

[[inventory_synchronization]]
.Node synchronizing the blockchain by retrieving blocks from a peer
.ピアからブロックを取得することによってブロックチェーンと同期するノード
image::images/msbt_0606.png["InventorySynchronization"]

As an analogy, a full node is like a tourist in a strange city, equipped with a detailed map of every street and every address. By comparison, an SPV node is like a tourist in a strange city asking random strangers for turn-by-turn directions while knowing only one main avenue. Although both tourists can verify the existence of a street by visiting it, the tourist without a map doesn't know what lies down any of the side streets and doesn't know what other streets exist. Positioned in front of 23 Church Street, the tourist without a map cannot know if there are a dozen other "23 Church Street" addresses in the city and whether this is the right one. The mapless tourist's best chance is to ask enough people and hope some of them are not trying to mug him.

アナロジーとして、full nodeは行ったことのない町の全てのストリート、住所についての詳細な地図を持っている観光客に似ています。これに対して、SPVノードはメイン通りしか知らず行き当たりばったりで進む観光客のようなものです。両方の観光客ともメインストリートが確認できる点は同じですが、地図を持っていない観光客はメインストリートにどんな横道があるか、他にどんなストリートがあるかは分かりません。単に23 Church Streetというストリートにいるだけでは、地図を持っていない観光客は同じ名前のストリートが同じに町に他にも多くあるかどうか、目の前のストリートが行きたいストリートなのかどうかを知ることはできないのです。地図を持たない観光客が取れる最も良い方法は、十分な数の人々に尋ねることです。そのうちの何人かが彼をだまそうとしないことを祈りましょう。

Simplified payment verification verifies transactions by reference to their _depth_ in the blockchain instead of their _height_. Whereas a full blockchain node will construct a fully verified chain of thousands of blocks and transactions reaching down the blockchain (back in time) all the way to the genesis block, an SPV node will verify the chain of all blocks (but not all transactions) and link that chain to the transaction of interest. 

simplified payment verificationはブロックチェーンの _高さ_ の代わりにブロックチェーンの _深さ_ を参照することでトランザクションを検証します。フルブロックチェーンノードが完全に検証された数千ブロックのブロックチェーンや全てのトランザクションを構築する一方、SPVノードは全てのブロックチェーン(しかし全てのトランザクションではない)とこのSPVノードと関連のあるトランザクションだけを検証します。

For example, when examining a transaction in block 300,000, a full node links all 300,000 blocks down to the genesis block and builds a full database of UTXO, establishing the validity of the transaction by confirming that the UTXO remains unspent. An SPV node cannot validate whether the UTXO is unspent. Instead, the SPV node will establish a link between the transaction and the block that contains it, using a((("merkle trees","SPV and"))) _merkle path_ (see <<merkle_trees>>). Then, the SPV node waits until it sees the six blocks 300,001 through 300,006 piled on top of the block containing the transaction and verifies it by establishing its depth under blocks 300,006 to 300,001. The fact that other nodes on the network accepted block 300,000 and then did the necessary work to produce six more blocks on top of it is proof, by proxy, that the transaction was not a double-spend.

例えばブロック300,000にあるトランザクションを調べる場合、full nodeは300,000個のブロックを起源ブロックまで結びつけUTXOのフルデータベースを構築しUTXOが使用されていないことを確認することでトランザクションを検証していきます。SPVノードはUTXOが使用されていないかどうかは検証できません。その代わり、SPVノードは((("merkle trees","SPV and"))) _merkle path_(<<merkle_trees>>参照)を使うことでトランザクションとこのトランザクションを含んでいるブロックとの間を結びつけていきます。ブロック300,000のトランザクションを使用する場合、SPVノードは６個のブロック、300,001番目から300,006番目まで、を確認するまで待ちます。これは他のノードが、300,000番目のブロックにあるトランザクションが二重に使用されたものではないことを６回検証するまで待つためです。

An SPV node cannot be persuaded that a transaction exists in a block when the transaction does not in fact exist. The SPV node establishes the existence of a transaction in a block by requesting a merkle path proof and by validating the proof of work in the chain of blocks. However, a transaction's existence can be "hidden" from an SPV node. An SPV node can definitely prove that a transaction exists but cannot verify that a transaction, such as a double-spend of the same UTXO, doesn't exist because it doesn't have a record of all transactions. This vulnerability can be used in a denial-of-service attack or for a double-spending attack against SPV nodes. To defend against this, an SPV node needs to connect randomly to several nodes, to increase the probability that it is in contact with at least one honest node. This need to randomly connect means that SPV nodes also are vulnerable to network partitioning attacks or Sybil attacks, where they are connected to fake nodes or fake networks and do not have access to honest nodes or the real bitcoin network.

実際にトランザクションがブロックになかったときに、トランザクションがあるとSPVノードを説得することはできません。SPVノードはブロックの中のトランザクションの存在をmerkle path証明をリクエストすることで確認でき、ブロックチェーンにあるproof of workを検証できます。しかし、トランザクションの存在はSPVノードには"隠されて"います。SPVノードは確実にトランザクションは存在することを証明できますが、同じUTXOの二重使用のようなトランザクションが存在しているかどうかは検証できません。なぜなら、全てのトランザクションの記録を持っている訳ではないからです。これらの弱点は、DOS攻撃または二重使用攻撃に利用されてしまいます。これに対抗するために、SPVノードはランダムにいくつかのノードと接続するようにしておく必要があります。これは、できるだけ信頼できるノードと接続するようにしておくためです。ランダムに接続することで、ネットワーク分割攻撃またはSybil攻撃を回避することができます。というのは、SPVノードが攻撃者のノードまたは攻撃者のネットワークにのみに接続してしまうと、信頼できる正しいBitcoinネットワークに接続できなくなってしまうためです。

For most practical purposes, well-connected SPV nodes are secure enough, striking the right balance between resource needs, practicality, and security. For infallible security, however, nothing beats running a full blockchain node. 

実用上、バランスよくコネクションを持っているSPVノードは十分に安全で、必要なリソース量、実用性、安全性のよいバランスがとられています。しかし、絶対に確実なセキュリティという点では、フルブロックチェーンノードが最も良いです。

[TIP]
====
((("simplified payment verification (SPV) nodes","verification")))A full blockchain node verifies a transaction by checking the entire chain of thousands of blocks below it in order to guarantee that the UTXO is not spent, whereas an SPV node checks how deep the block is buried by a handful of blocks above it. 

((("simplified payment verification (SPV) nodes","verification")))フルブロックチェーンノードは、あるトランザクションより下の全てのブロックのチェーンをチェックすることでこのトランザクションを検証します。これは、このUTXOが未使用であることを保証するためです。一方、SPVノードはこのブロックよりも上の一握りだけのブロックを確認することで、このブロックがどれだけ深く埋められているかを確認しています。
====

((("block headers","getting on SPV nodes")))To get the block headers, SPV nodes use a((("getheaders message"))) +getheaders+ message instead of +getblocks+. The responding peer will send up to 2,000 block headers using a single +headers+ message. The process is otherwise the same as that used by a full node to retrieve full blocks. SPV nodes also set a filter on the connection to peers, to filter the stream of future blocks and transactions sent by the peers. Any transactions of interest are retrieved using a +getdata+ request. The peer generates a((("tx messages"))) +tx+ message containing the transactions, in response. <<spv_synchronization>> shows the synchronization of block headers.

((("block headers","getting on SPV nodes")))ブロックヘッダを得るために、SPVノードは +getblocks+ messageの代わりに ((("getheaders message"))) +getheaders+ message を使います。+getheaders+ message を受け取ったピアは2,000個までのブロックヘッダを１個の +headers+ message で返送します。このプロセスはfull nodeがブロックを集めるプロセスと同じです。また、SPVノードはピアが送信したブロックやトランザクションをフィルタリングしています。関連あるトランザクションを取得する際には +getdata+ request を使います。ピアはトランザクションが含まれている((("tx messages"))) +tx+ message を生成し返却します。<<spv_synchronization>>図はブロックヘッダの同期を示しています。


[[spv_synchronization]]
.SPV node synchronizing the block headers
.SPVノードのブロックヘッダ同期
image::images/msbt_0607.png["SPVSynchronization"]

Because SPV nodes need to retrieve specific transactions in order to selectively verify them, they also create a privacy risk. Unlike full blockchain nodes, which collect all transactions within each block, the SPV node's requests for specific data can inadvertently reveal the addresses in their wallet. For example, a third party monitoring a network could keep track of all the transactions requested by a wallet on an SPV node and use those to associate bitcoin addresses with the user of that wallet, destroying the user's privacy. 

SPVノードは関連あるトランザクションのみを取得するので、プライバシーリスクが生じてしまいます。フルブロックチェーンノードと違って、全てのトランザクションを取得するわけではなく関連あるデータだけを取得するためウォレットのBitcoinアドレスがもれてしまうのです。例えば、第三者のモニタリングツールはSPVノード上のウォレットからリクエストされたトランザクションを全て追跡することができ複数のBitcoinアドレスをウォレットのユーザと結びつけることができてしまいます。

Shortly after the introduction of SPV/lightweight nodes, the bitcoin developers added a feature called _bloom filters_ to address the privacy risks of SPV nodes. Bloom filters allow SPV nodes to receive a subset of the transactions without revealing precisely which addresses they are interested in, through a filtering mechanism that uses probabilities rather than fixed patterns.(((range="endofrange", startref="ix_ch06-asciidoc6")))(((range="endofrange", startref="ix_ch06-asciidoc5a")))(((range="endofrange", startref="ix_ch06-asciidoc5"))) 

SPV/軽量ノードが導入された後少しして、Bitcoinの開発者たちは _bloom filters_ と呼ばれるプライバシーを漏らさない機能を追加しました。bloom filtersは、SPVノードと関連あるBitcoinアドレスがどれかを漏らすことなくトランザクションの部分集合を取得する方法です。ただし、このフィルタリングメカニズムは正確なものではなく確率を利用したものです。(((range="endofrange", startref="ix_ch06-asciidoc6")))(((range="endofrange", startref="ix_ch06-asciidoc5a")))(((range="endofrange", startref="ix_ch06-asciidoc5")))

=== Bloom Filters
=== Bloom Filters

((("bitcoin network","bloom filters and", id="ix_ch06-asciidoc7", range="startofrange")))((("bloom filters", id="ix_ch06-asciidoc8", range="startofrange")))((("Simplified Payment Verification (SPV) nodes","bloom filters and", id="ix_ch06-asciidoc9", range="startofrange")))A bloom filter is a probabilistic search filter, a way to describe a desired pattern without specifying it exactly. Bloom filters offer an efficient way to express a search pattern while protecting privacy. They are used by SPV nodes to ask their peers for transactions matching a specific pattern, without revealing exactly which addresses they are searching for. 

((("bitcoin network","bloom filters and", id="ix_ch06-asciidoc7", range="startofrange")))((("bloom filters", id="ix_ch06-asciidoc8", range="startofrange")))((("Simplified Payment Verification (SPV) nodes","bloom filters and", id="ix_ch06-asciidoc9", range="startofrange")))bloom filterは確率的探索フィルタで、欲しいパターンを正確に特定しなくてもよい方法です。bloom filterはプライバシーを漏らさないような探索パターンを作り、SPVノードに特定のパターンに合ったトランザクションが含まれているかを他のピアに確認することができるのです。

In our previous analogy, a tourist without a map is asking for directions to a specific address, "23 Church St." If she asks strangers for directions to this street, she inadvertently reveals her destination. A bloom filter is like asking, "Are there any streets in this neighborhood whose name ends in R-C-H?" A question like that reveals slightly less about the desired destination than asking for "23 Church St." Using this technique, a tourist could specify the desired address in more detail as "ending in U-R-C-H" or less detail as "ending in H." By varying the precision of the search, the tourist reveals more or less information, at the expense of getting more or less specific results. If she asks a less specific pattern, she gets a lot more possible addresses and better privacy, but many of the results are irrelevant. If she asks for a very specific pattern, she gets fewer results but loses privacy. 

前の節でのアナロジーとして、地図を持っていない観光客は人にある住所 "23 Church St." への方向を尋ねます。もし彼女がこのストリートへの方向を知らない人に尋ねたら、情報を得ることなくうっかり彼女が行こうとしているところを明かしてしまうことになるのです。bloom filterは「この近くにRCHで終わるストリートはありますか？」と尋ねるようなものです。このような質問をすることで、わずかだけ行きたいストリートの場所を知ることができます。このテクニックを使って、観光客は行きたい場所を特定していくことができるかもしれません。質問の仕方を変えることで正確な返答ではありませんが、観光客は住所を特定できる可能性のある多くの結果とプライバシーを守ることができるのです。もっと直接的に質問すれば、もっと少ない質問で行きたい場所に行けますが、プライバシーを失ってしまいます。

Bloom filters serve this function by allowing an SPV node to specify a search pattern for transactions that can be tuned toward precision or privacy. A more specific bloom filter will produce accurate results, but at the expense of revealing what addresses are used in the user's wallet. A less specific bloom filter will produce more data about more transactions, many irrelevant to the node, but will allow the node to maintain better privacy. 

bloom filtersは、この例と同じことをSPVノードがトランザクションを探すときに使えるようにし、正確性とプライバシーのバランスを取ることができるようにします。より正確なbloom filterは正確な結果を返しますが、どのBitcoinアドレスをウォレットが使っているかを明かすことでプライバシーを犠牲にします。代わりに、より粗いbloom filterはこのBitcoinノードに関係しないより多くのトランザクションに関する多くのデータを返しますが、プライバシーを保てるようにします。

An SPV node will initialize a bloom filter as "empty" and in that state the bloom filter will not match any patterns. The SPV node will then make a list of all the addresses in its wallet and create a search pattern matching the transaction output that corresponds to each address. Usually, the search pattern is a((("pay-to-public-key-hash (P2PKH)","bloom filters and"))) pay-to-public-key-hash script that is the expected locking script that will be present in any transaction paying to the public-key-hash (address). If the SPV node is tracking the balance of a((("pay-to-script-hash (P2SH)","bloom filters and"))) P2SH address, the search pattern will be a pay-to-script-hash script, instead. The SPV node then adds each of the search patterns to the bloom filter, so that the bloom filter can recognize the search pattern if it is present in a transaction. Finally, the bloom filter is sent to the peer and the peer uses it to match transactions for transmission to the SPV node. 

SPVノードは、bloom filterを"空"の状態で初期化しますが、この状態ではどんなパターンもマッチしません。次に、SPVノードはウォレットが持っている全てのBitcoinアドレスのリストを作成し、それぞれのBitcoinアドレスごとに探索パターンを作成します。通常、探索パターンは ((("pay-to-public-key-hash (P2PKH)","bloom filters and"))) pay-to-public-key-hash script です。これは、public-key-hash(Bitcoinアドレス)への支払いをするトランザクションに提供されるlocking scriptです。もしSPVノードが((("pay-to-script-hash (P2SH)","bloom filters and"))) P2SH アドレスの残高をトラッキングしているのであれば、探索パターンはpay-to-public-key-hash script の代わりに pay-to-script-hash script になります。次に、SPVノードは、bloom filterが探索パターンを認識できるようにそれぞれのこれらの探索パターンをbloom filterに追加します。最後に、SPVノードはbloom filterをピアに送り、ピアは送られてきたbloom filterを使ってどのトランザクションが探索パターンにマッチするかを調べます。

Bloom filters are implemented as a variable-size array of N binary digits (a bit field) and a variable number of M hash functions. The hash functions are designed to always produce an output that is between 1 and N, corresponding to the array of binary digits. The hash functions are generated deterministically, so that any node implementing a bloom filter will always use the same hash functions and get the same results for a specific input. By choosing different length (N) bloom filters and a different number (M) of hash functions, the bloom filter can be tuned, varying the level of accuracy and therefore privacy. 

bloom filterはN個のビット列とM個のハッシュ関数で構成されています。ハッシュ関数はいつも1からNの間の値を生成するようになっており、この数はビット列の場所に対応しています。どのノードでも同じハッシュ関数を使い特定の入力に対して同じ結果を得られるように、ハッシュ関数は決定性的なものになっています。bloom filterの長さ(N)とハッシュ関数の数(M)として違ったものを選ぶことでbloom filterをチューニングすることができ、正確さのレベルおよびプライバシーの確保度合いを調整できます。

In <<bloom1>>, we use a very small array of 16 bits and a set of three hash functions to demonstrate how bloom filters work. 

<<bloom1>>図では、bloom filterがどのように動くかのデモンストレーションとしてとても小さい16個のビット列と3個のハッシュ関数を使っています。

[[bloom1]]
.An example of a simplistic bloom filter, with a 16-bit field and three hash functions
.16bitのフィールドと３つのハッシュ関数を持った極端にシンプルにしたbloom filterの例
image::images/msbt_0608.png["Bloom1"]

The bloom filter is initialized so that the array of bits is all zeros. To add a pattern to the bloom filter, the pattern is hashed by each hash function in turn. Applying the first hash function to the input results in a number between 1 and N. The corresponding bit in the array (indexed from 1 to N) is found and set to +1+, thereby recording the output of the hash function. Then, the next hash function is used to set another bit and so on. Once all M hash functions have been applied, the search pattern will be "recorded" in the bloom filter as M bits that have been changed from +0+ to +1+. 

bloom filterはまず全てのビット列が0のなるように初期化されます。bloom filterにパターンを追加するために、パターンをそれぞれのハッシュ関数で次々にハッシュ化しbloom filterに追加していきます。インプットパターンを最初のハッシュ関数に通して1からNまでの間の数を得ます。この数に対応したビット列(1からNまでのindexが振ってある)のビットを見つけ +1+ を立てます。次のハッシュ関数に対しても同様に行いM個のハッシュ関数全てに対して行うと、ビットが +0+ から +1+ に変わった模様としてトランザクションに対する探索パターンがbloom filterに "記録" されます。

<<bloom2>> is an example of adding a pattern "A" to the simple bloom filter shown in <<bloom1>>.

<<bloom2>>図はパターン"A"を<<bloom1>>図のbloom filterに記録した例です。


Adding a second pattern is as simple as repeating this process. The pattern is hashed by each hash function in turn and the result is recorded by setting the bits to +1+. Note that as a bloom filter is filled with more patterns, a hash function result might coincide with a bit that is already set to +1+, in which case the bit is not changed. In essence, as more patterns record on overlapping bits, the bloom filter starts to become saturated with more bits set to +1+ and the accuracy of the filter decreases. This is why the filter is a probabilistic data structure—it gets less accurate as more patterns are added. The accuracy depends on the number of patterns added versus the size of the bit array (N) and number of hash functions (M). A larger bit array and more hash functions can record more patterns with higher accuracy. A smaller bit array or fewer hash functions will record fewer patterns and produce less accuracy. 

２つ目のパターンを追加するプロセスは、１つ目のプロセスを繰り返すだけです。２つ目に対してもそれぞれのハッシュ関数を使ってハッシュ化し、ビット列の特定の場所のビットに +1+ を立てることでパターンを記録します。多くのパターンを記録していくにつれて、すでに +1+ のビットが立っている場所をもう一度 +1+ に立てようとするかもしれませんが、この場合このビットは変化しません。本質的に、bloom filterに多くのパターンを記録すればするほど +1+ が立っている場所が増え飽和していき、bloom filterの正確さは衰えていきます。これが、bloom filterが確率的なデータ構造、パターンを追加すればするほど正確性が失われる、になっている理由です。正確さはパターンの数が多くなればなるほど減り、逆に、ビット列の大きさ(N)とハッシュ関数の数(M)が大きくなればなるほどこの減り度合いを抑制できます。より大きなビット列と多くのハッシュ関数を使うことで多くのパターンをより正確に記録できるのです。

[[bloom2]]
.Adding a pattern "A" to our simple bloom filter
.前に示したシンプルなbloom filterにパターン"A"を与えた場合
image::images/msbt_0609.png["Bloom2"]

<<bloom3>> is an example of adding a second pattern "B" to the simple bloom filter.

<<bloom3>>図はパターン"B"をbloom filterに記録する例です。

[[bloom3]]
.Adding a second pattern "B" to our simple bloom filter
.前に示したシンプルなbloom filterに２番目のパターン"B"を与えた場合
image::images/msbt_0610.png["Bloom3"]

To test if a pattern is part of a bloom filter, the pattern is hashed by each hash function and the resulting bit pattern is tested against the bit array. If all the bits indexed by the hash functions are set to +1+, then the pattern is _probably_ recorded in the bloom filter. Because the bits may be set because of overlap from multiple patterns, the answer is not certain, but is rather probabilistic. In simple terms, a bloom filter positive match is a "Maybe, Yes." 

あるパターンがbloom filterの一部にあるかどうかチェックするために、このパターンをそれぞれのハッシュ関数でハッシュ化し得られたビットパターンとbloom filterのビット列を比較します。あるパターンのビットパターンの中で +1+ になっている場所がbloom filterのビット列でも +1+ になっていれば、あるパターンが _おそらく_ bloom filterに含まれているだろうと推察できます。bloom filterのビット列のあるビットは複数のパターンによる重複で +1+ になっているかもしれないので、答えとしては確実ではないですが、むしろ確率的な答えになります。簡単に言うと、bloom filterは"たぶん、含まれる"と答えるだけです。

<<bloom4>> is an example of testing the existence of pattern "X" in the simple bloom filter. The corresponding bits are set to +1+, so the pattern is probably a match.

<<bloom4>>図はパターン"X"がbloom filterに含まれているかチェックする例です。対応したビットは +1+ になっており、よっておそらくパターン"X"を含むということになります。

[[bloom4]]
.Testing the existence of pattern "X" in the bloom filter. The result is probabilistic positive match, meaning "Maybe."
.bloom filterを使ってパターン"X"が存在するかチェック。その結果は確率的な陽性、つまり"たぶんある"。
image::images/msbt_0611.png["Bloom4"]

On the contrary, if a pattern is tested against the bloom filter and any one of the bits is set to +0+, this proves that the pattern was not recorded in the bloom filter. A negative result is not a probability, it is a certainty. In simple terms, a negative match on a bloom filter is a "Definitely Not!" 

逆に、あるパターンがbloom filterに含まれていないということをチェックする場合は、対応したbloom filterのビット列のどれか１つが +0+ であることを確認すればよく、このことであるパターンがbloom filterには含まれていないということを証明することができます。含まれていないというチェックに対しては確率的ではなく、確実なものです。簡単に言うと、bloom filterは"絶対に含まれない！"と答えることができます。

<<bloom5>> is an example of testing the existence of pattern "Y" in the simple bloom filter. One of the corresponding bits is set to +0+, so the pattern is definitely not a match.

<<bloom5>>図はパターン"Y"がbloom filterに含まれているかチェックする例です。対応したビットの１つが +0+ になっており、よってパターン"Y"は全体に含まれないということになります。

[[bloom5]]
.Testing the existence of pattern "Y" in the bloom filter. The result is a definitive negative match, meaning "Definitely Not!"
.bloom filterを使ってパターン"Y"が存在するか確認。その結果は正確な陰性、つまり"確実にない！"。
image::images/msbt_0612.png[]

Bitcoin's implementation of bloom filters is described in Bitcoin Improvement Proposal 37 (BIP0037). See <<appdxbitcoinimpproposals>> or visit http://bit.ly/1x6qCiO[GitHub].

bloom filterのBitcoinでの実装は Bitcoin Improvement Proposal 37 (BIP0037) に記述されています。<<appdxbitcoinimpproposals>>を参照するか、またはhttp://bit.ly/1x6qCiO[GitHub]に行ってみてください。

=== Bloom Filters and Inventory Updates
=== Bloom FiltersとInventory更新

((("inventory updates, bloom filters and")))Bloom filters are used to filter the transactions (and blocks containing them) that an SPV node receives from its peers. SPV nodes will create a filter that matches only the addresses held in the SPV node's wallet. The SPV node will then send a((("filterload message"))) +filterload+ message to the peer, containing the bloom filter to use on the connection. After a filter is established, the peer will then test each transaction's outputs against the bloom filter. Only transactions that match the filter are sent to the node. 

((("inventory updates, bloom filters and")))bloom filterはSPVノードが受け取るトランザクション(およびそれらを含んでいるブロック)をフィルタリングするために使われます。SPVノードはSPVノードのウォレットにあるBitcoinアドレスのみにマッチするフィルタを作成します。SPVノードはbloom filterを含んでいる((("filterload message"))) +filterload+ messageをピアに送ります。bloom filterが送られると、ピアはそれぞれのトランザクションのアウトプットを送られてきたbloom filterでチェックします。bloom filterにマッチしたトランザクションだけがSPVノードに送られます。

In response to a +getdata+ message from the node, peers will send a +merkleblock+ message that contains only block headers for blocks matching the filter and a merkle path (see <<merkle_trees>>) for each matching transaction. The peer will then also send +tx+ messages containing the transactions matched by the filter.

+getdata+ messageに対するレスポンスとして、ピアはbloom filterにマッチしたブロックのヘッダとマッチしたトランザクションそれぞれに対するmerkle path(<<merkle_trees>>参照)を含む +merkleblock+ message をSPVノードに送ります。ピアはまたbloom filterにマッチしたトランザクションを含む +tx+ messages も送ります。

The node setting the bloom filter can interactively add patterns to the filter by sending a((("filteradd message"))) +filteradd+ message. To clear the bloom filter, the node can send a((("filterclear message"))) +filterclear+ message. Because it is not possible to remove a pattern from a bloom filter, a node has to clear and resend a new bloom filter if a pattern is no longer desired.(((range="endofrange", startref="ix_ch06-asciidoc9")))(((range="endofrange", startref="ix_ch06-asciidoc8")))(((range="endofrange", startref="ix_ch06-asciidoc7"))) 

SPVノードが新たにパターンを増やす場合は ((("filteradd message"))) +filteradd+ message をピアに送ることでパターンをbloom filterに追加できます。またbloom filterを削除するためには、((("filterclear message"))) +filterclear+ message をピアに送ります。bloom filterからあるパターンだけを削除することはできないので、この場合SPVノードは一度bloom filterを削除してから新しいbloom filterを送り直します。(((range="endofrange", startref="ix_ch06-asciidoc9")))(((range="endofrange", startref="ix_ch06-asciidoc8")))(((range="endofrange", startref="ix_ch06-asciidoc7")))

[[transaction_pools]]
=== Transaction Pools
=== トランザクションプール

((("bitcoin network","transaction pools")))((("transaction pools")))((("memory pool")))((("mempool")))((("transactions","unconfirmed, pools of")))((("unconfirmed transactions")))Almost every node on the bitcoin network maintains a temporary list of unconfirmed transactions called the _memory pool_, _mempool_, or _transaction pool_. Nodes use this pool to keep track of transactions that are known to the network but are not yet included in the blockchain. For example, a node that holds a user's wallet will use the transaction pool to track incoming payments to the user's wallet that have been received on the network but are not yet confirmed. 

((("bitcoin network","transaction pools")))((("transaction pools")))((("transactions","unconfirmed, pools of")))((("unconfirmed transactions")))Bitcoinネットワーク上のほとんどのノードは _メモリプール_ または _トランザクションプール_ と呼ばれる未検証トランザクションの一時リストを持っています。ノードはこのプールを使ってBitcoinネットワークに伝わっていてもまだブロックチェーンに含まれていないトランザクションをトラッキングしています。例えば、ウォレットを持っているノードは、Bitcoinネットワークに伝わっていてもまだ検証されていないウォレットへの入金トランザクションを一時的にこのトランザクションプールに保持しています。

As transactions are received and verified, they are added to the transaction pool and relayed to the neighboring nodes to propagate on the network.

トランザクションが到着したり検証されたりすると、これらはトランザクションプールに追加されたり隣接ノードに中継されBitcoinネットワーク上を伝搬していったりします。

((("orphan transaction pool")))Some node implementations also maintain a separate pool of orphaned transactions. If a transaction's inputs refer to a transaction that is not yet known, such as a missing parent, the orphan transaction will be stored temporarily in the orphan pool until the parent transaction arrives. 

((("orphan transaction pool")))いくつかのノードはまた孤児になっているトランザクションを入れておく別のプールも持っています。もしトランザクションインプットがまだノードが知らないトランザクションを参照していた場合、親トランザクション(トランザクションインプットにあるトランザクション)が到着するまでorphanトランザクションは一時的にorphanプールに保存されます。

When a transaction is added to the transaction pool, the orphan pool is checked for any orphans that reference this transaction's outputs (its children). Any matching orphans are then validated. If valid, they are removed from the orphan pool and added to the transaction pool, completing the chain that started with the parent transaction. In light of the newly added transaction, which is no longer an orphan, the process is repeated recursively looking for any further descendants, until no more descendants are found. Through this process, the arrival of a parent transaction triggers a cascade reconstruction of an entire chain of interdependent transactions by re-uniting the orphans with their parents all the way down the chain. 

トランザクションがトランザクションプールに追加されるとき、ノードはorphanプールにあるトランザクションが、トランザクションプールに追加されるトランザクションアウトプットを参照していないかチェックします。もし参照していれば、orphanプールから削除してトランザクションプールに追加されます。このプロセスはorphanプールにあるトランザクション全てに対して行われ、トランザクションが到着することを起点にして全トランザクションのチェーンが再構築されていきます。

((("orphan transaction pool","storage")))((("transaction pools","storage")))Both the transaction pool and orphan pool (where implemented) are stored in local memory and are not saved on persistent storage; rather, they are dynamically populated from incoming network messages. When a node starts, both pools are empty and are gradually populated with new transactions received on the network.

((("orphan transaction pool","storage")))((("transaction pools","storage")))トランザクションプールもorphanプール(もし実装されていれば)もローカルメモリに保持され、永続的なストレージには保存されません。むしろこれらは常にBitcoinネットワークからmessageが届くごとに書き変わっていくためローカルメモリのほうがよいのです。ノードが起動するときどちらのプールも空になっていて、Bitcoinネットワークからトランザクションが届くと次第に混み合ってきます。

Some implementations of the bitcoin client also maintain a UTXO database or UTXO pool, which is the set of all unspent outputs on the blockchain. Although the name "UTXO pool" sounds similar to the transaction pool, it represents a different set of data. Unlike the transaction and orphan pools, the UTXO pool is not initialized empty but instead contains millions of entries of unspent transaction outputs, including some dating back to 2009. The UTXO pool may be housed in local memory or as an indexed database table on persistent storage. 

いくつかのBitcoinクライアントの実装ではUTXOデータベースまたはUTXOプールも管理されています。このプールはブロックチェーン上の全ての未使用アウトプットを集めたものです。"UTXOプール"という名前の響きがトランザクションプールと似ていますが、別のデータの集まりです。トランザクションプールやorphanプールと違って、UTXOプールの初期状態は空ではなく最初から数百万個の未使用トランザクションアウトプット(2009年からのトランザクションアウトプット)を持っています。UTXOプールはローカルメモリまたは永続ストレージのデータベースに保持されています。

Whereas the transaction and orphan pools represent a single node's local perspective and might vary significantly from node to node depending upon when the node was started or restarted, the UTXO pool represents the emergent consensus of the network and therefore will vary little between nodes. Furthermore, the transaction and orphan pools only contain unconfirmed transactions, while the UTXO pool only contains confirmed outputs.

トランザクションプールとorphanプールはそれぞれのノードでの状態が異なりノードがいつ起動したか再起動したかによって変わってきますが、UTXOプールはBitcoinネットワーク内で合意されたものであり、ノードごとの違いはわずかです。さらに、トランザクションプールとorphanプールは未検証トランザクションのみを含み、UTXOプールは検証済アウトプットのみを含みます。

=== Alert Messages
=== アラートメッセージ

((("alert messages")))((("bitcoin network","alert messages")))Alert messages are a seldom used function, but are nevertheless implemented in most nodes. Alert messages are bitcoin's "emergency broadcast system," a means by which the core bitcoin developers can send an emergency text message to all bitcoin nodes. This feature is implemented to allow the core developer team to notify all bitcoin users of a serious problem in the bitcoin network, such as a critical bug that requires user action. The alert system has only been used a handful of times, most notably in early 2013 when a critical database bug caused a multiblock fork to occur in the bitcoin blockchain. 

((("alert messages")))((("bitcoin network","alert messages")))アラートメッセージは稀にしか使われない機能ですが、それにも関わらずほとんどのノードに実装されています。アラートメッセージはBitcoinの"緊急放送システム"で、コアのBitcoin開発者たちが緊急メッセージを全てのBitcoinノードに送れます。この機能を使うことで、コアのBitcoin開発者たちがBitcoinネットワーク内の重大な問題を全てのBitcoinユーザに通知できるようになっています。例えばユーザが何らかのアクションをとらなければならないクリティカルなバグのようなものを通知するためです。このアラートシステムはほんの数回だけしか使われておらず、最も大きなものとしては2013年初期にあったクリティカルなデータベースバグのときで、ブロックチェーンの分岐が起きてしまったときに使用されています。

Alert messages are propagated by the +alert+ message. The alert message contains several fields, including:

アラートメッセージは +alert+ messageによって伝搬されます。アラートメッセージは以下にあるフィールドを含んでいます。

ID::
An alert identified so that duplicate alerts can be detected
アラートを一意に指定するID

Expiration::
A time after which the alert expires
アラートが失効するまでの時間

RelayUntil::
A time after which the alert should not be relayed
アラートが中継されなくなるまでの時間

MinVer, MaxVer::
The range of bitcoin protocol versions that this alert applies to
アラートが適用されるBitcoinプロトコルバージョンの範囲

subVer::
The client software version that this alert applies to
アラートが適用されるクライアントバージョン

Priority::
An alert priority level, currently unused
アラートの優先レベル、現在使用されていない

Alerts are cryptographically signed by a public key. The corresponding private key is held by a few select members of the core development team. The digital signature ensures that fake alerts will not be propagated on the network.

アラートは公開鍵で暗号学的に署名されています。公開鍵に対応した秘密鍵は何人かの選ばれたコア開発メンバーによって保持されています。このデジタル署名によってBitcoinネットワークを嘘のアラートが伝搬しないようになっています。

Each node receiving this alert message will verify it, check for expiration, and propagate it to all its peers, thus ensuring rapid propagation across the entire network. In addition to propagating the alert, the nodes might implement a user interface function to present the alert to the user. 

アラートメッセージを受け取ったノードはそれを検証し、有効期間をチェックし、全てのピアにアラートメッセージを伝搬します。このため、Bitcoinネットワーク上をすばやく伝搬することができるようになっています。

((("Bitcoin Core client","alerts, configuring")))In the Bitcoin Core client, the alert is configured with the command-line option +-alertnotify+, which specifies a command to run when an alert is received. The alert message is passed as a parameter to the +alertnotify+ command. Most commonly, the +alertnotify+ command is set to generate an email message to the administrator of the node, containing the alert message. The alert is also displayed as a pop-up dialog in the graphical user interface (bitcoin-Qt) if it is running. 

((("Bitcoin Core client","alerts, configuring")))Bitcoin Coreクライアント内に、このアラートを表示することができるコマンドラインオプション +-alertnotify+ があり、アラートを受け取ったときに実行するコマンドを指定できます。アラートメッセージは +alertnotify+ コマンドにパラメーターとして渡されます。よくある設定は、 +alertnotify+ コマンドにノードの管理者にアラートメッセージを含むEメールを送る設定です。このアラートはまたグラフィカルなユーザインターフェイス(bitcoin-Qt)が動いていればポップアップダイアログとしても表示されます。

Other implementations of the bitcoin protocol might handle the alert in different ways. ((("mining","hardware, alerts and")))Many hardware-embedded bitcoin mining systems do not implement the alert message function because they have no user interface. It is strongly recommended that miners running such mining systems subscribe to alerts via a mining pool operator or by running a lightweight node just for alert purposes.(((range="endofrange", startref="ix_ch06-asciidoc0"))) 

Bitcoinプロトコルの他の実装では、アラートを別の形で受け取られているかもしれません。((("mining","hardware, alerts and")))多くのハードウェアに埋め込まれたBitcoinマイニングシステムではアラートメッセージ機能は実装されていません。というのは、ユーザインターフェイスがないためです。このようなマイニングシステムを動作させているマイナーは、マイニングプールオペレーターを通してアラートを受け取るか、アラートのためだけに軽量ノードを動作させておくことを強く推奨します。(((range="endofrange", startref="ix_ch06-asciidoc0")))



